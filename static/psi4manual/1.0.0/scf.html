

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>HF: Hartree–Fock Theory &mdash; Psi4 [1.0.0 6a9a71b] Docs</title>
    
    <link rel="stylesheet" href="_static/psi4.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="./" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0.0 6a9a71b',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/jquery.cookie.js"></script>
    <script type="text/javascript" src="_static/toggle_sections.js"></script>
    <script type="text/javascript" src="_static/toggle_sidebar.js"></script>
    <script type="text/javascript" src="_static/toggle_codeprompt.js"></script>
    <link rel="shortcut icon" href="_static/favicon-psi4.ico"/>
    <link rel="top" title="Psi4 [1.0.0 6a9a71b] Docs" href="index.html" />
    <link rel="up" title="Theoretical Methods: SCF to FCI" href="methods.html" />
    <link rel="next" title="DFT: Density Functional Theory" href="dft.html" />
    <link rel="prev" title="Notes on Options" href="notes_c.html" /> 
  </head>
  <body role="document">
    <div class="relbar-top">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="contents.html" title="Table Of Contents"
             accesskey="C">toc</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="dft.html" title="DFT: Density Functional Theory"
             accesskey="N">next</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="notes_c.html" title="Notes on Options"
             accesskey="P">previous</a> &nbsp; &nbsp;</li>
    <li><a href="index.html">Psi4 [1.0.0 6a9a71b]</a> &raquo; </li>

          <li class="nav-item nav-item-1"><a href="methods.html" accesskey="U">Theoretical Methods: SCF to FCI</a> &raquo;</li> 
      </ul>
    </div>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <a class="reference internal image-reference" href="_images/psi4banner.png"><img alt="Psi4 Project Logo" src="_images/psi4banner.png" style="width: 100%;" /></a>
<div class="section" id="hf-hartree-fock-theory">
<span id="sec-scf"></span><span id="index-0"></span><h1>HF: Hartree&#8211;Fock Theory<a class="headerlink" href="#hf-hartree-fock-theory" title="Permalink to this headline">¶</a></h1>
<p><em>Code author: Justin M. Turney, Robert M. Parrish, and Andrew C. Simmonett</em></p>
<p><em>Section author: Robert M. Parrish and Jerome F. Gonthier</em></p>
<p><em>Module:</em> <a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span>Keywords</span></a>, <a class="reference internal" href="autodir_psivariables/module__scf.html#apdx-scf-psivar"><span>PSI Variables</span></a>, <a class="reference external" href="https://github.com/psi4/psi4/blob/master/src/lib/libscf_solver">LIBSCF_SOLVER</a>, <a class="reference external" href="https://github.com/psi4/psi4/blob/master/src/lib/libmints">LIBMINTS</a>, <a class="reference external" href="https://github.com/psi4/psi4/blob/master/src/lib/libfock">LIBFOCK</a>, <a class="reference external" href="https://github.com/psi4/psi4/blob/master/src/lib/libdiis">LIBDIIS</a></p>
<div class="section" id="introduction">
<span id="sec-scfintro"></span><h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Self-Consistent-Field (SCF) theory forms the cornerstone of <em>ab initio</em> quantum
chemistry. Here SCF refers both to conventional Hartree&#8211;Fock (HF) molecular
orbital theory and also to generalized Kohn&#8211;Sham Density Functional Theory
(KS-DFT). <span class="sc">Psi4</span> contains a wholly rewritten SCF code, including many of the
most popular spin specializations, several efficient numerical methods for
treating Fock Matrix construction, and a brand new KS-DFT code featuring many of
the most popular DFT functional technologies.</p>
<p>An illustrative example of using the SCF module is as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>molecule {
0 3
O
O 1 1.21
}

set {
basis cc-pvdz
guess sad
reference uhf
scf_type direct
}

energy(&#39;scf&#39;)
</pre></div>
</div>
<p>This will run a UHF computation for triplet molecular oxygen (the ground state)
using a Direct algorithm for the Electron Repulsion Integrals (ERI) and starting
from a Superposition of Atomic Densities (SAD) guess. DF integrals are
automatically used to converge the DF-SCF solution before the Direct algorithm is
activated.  After printing all manner of titles, geometries, sizings, and
algorithm choices, the SCF finally reaches the iterations:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>                     Total Energy        Delta E     RMS |[F,P]|

@UHF iter   0:  -149.76816019169962   -1.49768e+02   1.36000e-01
@UHF iter   1:  -149.59759112756984    1.70569e-01   2.42437e-02
@UHF iter   2:  -149.62372414554761   -2.61330e-02   6.10239e-03 DIIS
@UHF iter   3:  -149.62643112722810   -2.70698e-03   2.17299e-03 DIIS
@UHF iter   4:  -149.62690062294968   -4.69496e-04   5.66895e-04 DIIS
@UHF iter   5:  -149.62694151409750   -4.08911e-05   1.26359e-04 DIIS
@UHF iter   6:  -149.62694337042228   -1.85632e-06   1.84114e-05 DIIS
@UHF iter   7:  -149.62694340901407   -3.85918e-08   2.91692e-06 DIIS
@UHF iter   8:  -149.62694340999002   -9.75945e-10   3.11857e-07 DIIS

DF guess converged.
...

@UHF iter   9:  -149.62730705470665   -3.63645e-04   8.63718e-05 DIIS
@UHF iter  10:  -149.62730737347948   -3.18773e-07   1.50227e-05 DIIS
@UHF iter  11:  -149.62730738537107   -1.18916e-08   3.80497e-06 DIIS
@UHF iter  12:  -149.62730738624032   -8.69250e-10   7.06690e-07 DIIS
</pre></div>
</div>
<p>The first set of iterations are from the DF portion of the computation, the
second set uses the exact (but much slower) Direct algorithm. Within the DF portion
of the computation, the zeroth-iteration uses a non-idempotent density matrix
obtained from the SAD guess, so the energy is unphysically low. However, the
first true iteration is quite close to the final DF energy, highlighting the
efficiency of the SAD guess. Pulay&#8217;s DIIS procedure is then used to accelerate
SCF convergence, with the DF phase reaching convergence in eight true
iterations. When used together, SAD and DIIS are usually sufficient to converge
the SCF for all but the most difficult systems. Additional convergence
techniques are available for more difficult cases, and are detailed below. At
this point, the code switches on the requested Direct integrals technology, which
requires only four full iterations to reach convergence, starting from the DF
guess. This hybrid DF/Direct procedure can significantly accelerate SCF
computations requiring exact integrals.</p>
<p>After the iterations are completed, a number of one-electron properties are
printed, and some bookkeeping is performed to set up possible correlated
computations. Additional one-electron properties are available by increasing the
<a class="reference internal" href="autodoc_glossary_options_c.html#term-print-globals"><span class="xref std std-term">PRINT</span></a> option. Also printed are the occupied and virtual orbital energies,
which are useful in elucidating the stability and reactivity of the system.</p>
</div>
<div class="section" id="theory">
<span id="index-1"></span><h2>Theory<a class="headerlink" href="#theory" title="Permalink to this headline">¶</a></h2>
<p>The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular
Orbitals (MOs) <img class="math" src="_images/math/379b06eeb89ae2553a8b20d66a28c63e78538db1.png" alt="\{\psi_i\}" style="vertical-align: -5px"/>,</p>
<div class="math">
<p><img src="_images/math/d9644c28110444d32c6ab10246ecd4ea0d49b754.png" alt="\psi_i(\vec x_1) = C_{\mu i} \phi_{\mu} (\vec x_1)."/></p>
</div><p>Here, <img class="math" src="_images/math/8995fc25737bf4c8bccd378edd9d255ebd05b0fe.png" alt="\{\phi_{\mu}\}" style="vertical-align: -6px"/> are the basis functions, which, in <span class="sc">Psi4</span> are
contracted cartesian Gaussian functions often referred to as Atomic Orbitals
(AOs). The matrix <img class="math" src="_images/math/fd695648e742589e2f6eb64090ad25e425f9edf0.png" alt="C_{\mu i}" style="vertical-align: -6px"/> contains the MO coefficients, which are the
constrained variational parameters in Hartree-Fock. The molecular orbitals, are
used to build the simplest possible antisymmetric wavefunction, a single Slater
determinant,</p>
<div class="math">
<p><img src="_images/math/617347db880c20559745a2974f144a630d12d9d4.png" alt="| \Psi_0 \rangle =
\frac{1}{\sqrt{N!}} \left | \begin{array}{cccc}
\psi_1 (\vec x_1) &amp; \psi_2(\vec x_1) &amp; \ldots &amp; \psi_N (\vec x_1) \\
\psi_1 (\vec x_2) &amp; \psi_2(\vec x_2) &amp; \ldots &amp; \psi_N (\vec x_2) \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\psi_1 (\vec x_N) &amp; \psi_2(\vec x_N) &amp; \ldots &amp; \psi_N (\vec x_N) \\
\end{array}\right |"/></p>
</div><p>This form for the Hartree-Fock wavefunction is actually entirely equivalent to
treating the electron correlation as a mean field repulsion in
<img class="math" src="_images/math/c4d1a3cc0bec86b810fa23d4b2e33bb74b0413aa.png" alt="\mathbb{R}^6" style="vertical-align: 0px"/> instead of a more complicated effect in
<img class="math" src="_images/math/45b99469d3013c746850966fb253dc409891d3a5.png" alt="\mathbb{R}^N" style="vertical-align: 0px"/>.</p>
<p>Considering the electronic Hamiltonian,</p>
<div class="math">
<p><img src="_images/math/2b39e2d21823d43d38ee0031b359f1b7d8fb1f34.png" alt="\hat H = \sum_{i} -\frac{1}{2} \nabla_i^2 + \sum_{i} \sum_{A} -
\frac{Z_A}{r_{iA}} + \sum_{i&gt;j} \frac{1}{r_{ij}},"/></p>
</div><p>the Hartree-Fock energy is, by Slater&#8217;s rules,</p>
<div class="math">
<p><img src="_images/math/6e084f310bb78e3e1617d9f1d5f88fb28a4accf4.png" alt="E_{\mathrm{HF}} =
\langle \Psi_0 | \hat H | \Psi_0 \rangle
= \sum_{i} \langle i | \hat h | i \rangle
+ \frac 1 2 \sum_{i,j} [ii|jj] - [ij|ji]"/></p>
</div><div class="math">
<p><img src="_images/math/5425e72aa2590cee595e6cbde518445614aa2879.png" alt="=
D_{\mu\nu}^\alpha \left(H_{\mu\nu} + F_{\mu\nu}^{\alpha} \right)
+ D_{\mu\nu}^\beta \left(H_{\mu\nu} + F_{\mu\nu}^{\beta} \right)"/></p>
</div><p>Here <img class="math" src="_images/math/5f75778e1fdbd0354edda2de5144510a5da029c1.png" alt="H" style="vertical-align: 0px"/> is the AO-basis one-electron potential, encapsulating both
electron-nuclear attraction and kinetic energy,</p>
<div class="math">
<p><img src="_images/math/11c6d27a4c9c752a902eaf24aaac9ddb91ba7333.png" alt="H_{\mu\nu} =
\left(\mu \left| -\frac{1}{2} \nabla^2 + \sum_{A} -\frac{Z_A}{r_{1A}} \right
| \nu \right),"/></p>
</div><p><img class="math" src="_images/math/38c3f1bb635d72c20480efe631525d3464136e24.png" alt="D" style="vertical-align: 0px"/> is the AO-basis density matrix, build from the occupied orbital
coefficients,</p>
<div class="math">
<p><img src="_images/math/c6d87facd5167c9934fb12b37cd5db55e6772321.png" alt="D_{\mu\nu}^{\alpha} =
C_{\mu i}^{\alpha} C_{\nu i}^{\alpha},"/></p>
</div><p>and <img class="math" src="_images/math/68b0fc4683e0c8842b3a6cc6920f022f1c0db3fa.png" alt="F" style="vertical-align: 0px"/> is the Fock matrix, which is the effective one-body potential at
the current value of the density,</p>
<div class="math">
<p><img src="_images/math/5d192161fa24e156fa02cf2da7880603039b2849.png" alt="F_{\mu\nu}^{\alpha} = H_{\mu\nu}
+ \underbrace{\left(D_{\lambda\sigma}^{\alpha} + D_{\lambda\sigma}^{\beta}\right)
(\mu\nu|\lambda\sigma)}_{J}
+ \underbrace{D_{\lambda\sigma}^{\alpha} (\mu\lambda|\sigma\nu)}_{K^{\alpha}}"/></p>
</div><p>Here the tensor <img class="math" src="_images/math/2476d43f8fd36c215824270614f15b14e3fd9028.png" alt="(\mu\nu|\lambda\sigma)" style="vertical-align: -5px"/> is an AO Electron-Repulsion
Integral (ERI) in chemists&#8217; notation,</p>
<div class="math">
<p><img src="_images/math/669ecb4ebb96d1d10bfa74dea626403acb638d11.png" alt="(\mu\nu|\lambda\sigma) = \iint_{\mathbb{R}^6}
\phi_{\mu} (\vec r_1)
\phi_{\nu} (\vec r_1)
\frac{1}{r_{12}}
\phi_{\lambda} (\vec r_2)
\phi_{\sigma} (\vec r_2)
\ \mathrm{d}^3 r_1
\ \mathrm{d}^3 r_2."/></p>
</div><p>The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,</p>
<div class="math">
<p><img src="_images/math/875da9f6bf9a382f26be6c4cf86a918e706b3471.png" alt="F^\alpha C^\alpha = S C^\alpha \epsilon^\alpha"/></p>
</div><p>The eigenvalues <img class="math" src="_images/math/1c67e848e51a0f11ff730889cbd43af9034630a0.png" alt="\epsilon" style="vertical-align: 0px"/> are the orbital energies, and the metric matrix
<img class="math" src="_images/math/c6263458cb30b8d89520cf776bc3431879c1f0b5.png" alt="S" style="vertical-align: 0px"/> is the AO-basis overlap matrix</p>
<div class="math">
<p><img src="_images/math/a57a2d9d5c2d0338c90efdd589f171f2417b4d71.png" alt="S_{\mu\nu} = (\mu | \nu )"/></p>
</div><p>Note that the Fock Matrix depends on the density (both alpha and beta), and
therefore the orbitals. Because of this, SCF is a nonlinear procedure, which
terminates when the generating orbitals are self-consistent with the Fock matrix
they generate.</p>
<p>The formation of the Coulomb matrix <img class="math" src="_images/math/361e13f27e8f76935d439ee1958ea404609325f3.png" alt="J" style="vertical-align: 0px"/> and the exchange matrix
<img class="math" src="_images/math/84e3b25a8d6bb3a6ddf471bda0aeea98b5fbd632.png" alt="K^{\alpha}" style="vertical-align: 0px"/> dominate the computational effort of the SCF procedure. For
very large systems, diagonalization of the Fock matrix can also present a
significant hurdle.</p>
</div>
<div class="section" id="minimal-input">
<h2>Minimal Input<a class="headerlink" href="#minimal-input" title="Permalink to this headline">¶</a></h2>
<p>Minimal input for a Hartree-Fock computation is a molecule block, basis set
option, and a call to <code class="docutils literal"><span class="pre">energy('scf')</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>molecule {
He
}

set basis sto-3g

energy(&#39;scf&#39;)
</pre></div>
</div>
<p>This will run a Restricted Hartree-Fock (RHF) on neutral singlet Helium in
<img class="math" src="_images/math/db75df3e2b5a073f500992eae10086986cebf33f.png" alt="D_{2h}" style="vertical-align: -3px"/> spatial symmetry with a minimal <code class="docutils literal"><span class="pre">STO-3G</span></code> basis, 1.0E-6
energy and 1.0E-5 density convergence criteria (since single-point, see
<a class="reference internal" href="#table-conv-scf"><span>SCF Convergence &amp; Algorithm</span></a>), a DF ERI algorithm, symmetric
orthogonalization, DIIS, and a core Hamiltonian guess. For more
information on any of these options, see the relevant section below.</p>
</div>
<div class="section" id="spin-symmetry-treatment">
<h2>Spin/Symmetry Treatment<a class="headerlink" href="#spin-symmetry-treatment" title="Permalink to this headline">¶</a></h2>
<p><span class="sc">Psi4</span> implements the most popular spin specializations of Hartree-Fock
theory, including:</p>
<dl class="docutils">
<dt>Restricted Hartree-Fock (RHF) [Default]</dt>
<dd>Appropriate only for closed-shell singlet systems, but twice as efficient
as the other flavors, as the alpha and beta densities are constrained to be
identical.</dd>
<dt>Unrestricted Hartree-Fock (UHF)</dt>
<dd>Appropriate for most open-shell systems, and fairly easy to converge.
The spatial parts of the alpha and beta orbitals are fully independent of each
other, which allows a considerable amount of flexibility in the wavefunction.
However, this flexibility comes at the cost of spin symmetry; UHF wavefunctions
need not be eigenfunctions of the <img class="math" src="_images/math/562122b811356a82fed11f9b452c375b184b68f8.png" alt="\hat S^2" style="vertical-align: 0px"/> operator. The deviation of
this operator from its expectation value is printed on the output file. If the
deviation is greater than a few hundredths, it is advisable to switch to an
ROHF to avoid this &#8220;spin-contamination&#8221; problem.</dd>
<dt>Restricted Open-Shell Hartree-Fock (ROHF)</dt>
<dd>Appropriate for open-shell systems where spin-contamination is problem.
Sometimes more difficult to converge, and assumes uniformly positive spin
polarization (the alpha and beta doubly-occupied orbitals are identical).</dd>
<dt>Constrained Unrestricted Hartree-Fock (CUHF)</dt>
<dd>A variant of ROHF that starts from a UHF ansatz, and is therefore often
easier to converge.</dd>
</dl>
<p>These can be invoked by the <a class="reference internal" href="autodoc_glossary_options_c.html#term-reference-scf"><span class="xref std std-term">REFERENCE</span></a> keyword, which defaults to <code class="docutils literal"><span class="pre">RHF</span></code>.
The charge and multiplicity may either be specified in the molecule definition:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>molecule h {
0 2 # Neutral doublet
H
}
</pre></div>
</div>
<p>or, dynamically, by setting the relevant attributes in the Python molecule
object:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">h</span><span class="o">.</span><span class="n">set_molecular_charge</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">h</span><span class="o">.</span><span class="n">set_multiplicity</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Abelian spatial symmetry is fully supported in <span class="sc">Psi4</span>, and can be used to
obtain physical interpretation of the molecular orbitals, to assist in difficult
convergence cases, and, in some methods, to obtain significant performance
gains. The point group of the molecule is inferred when reading the molecule
section, and may be overridden by the <code class="docutils literal"><span class="pre">symmetry</span></code> flag, as in:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>molecule h {
0 2
H
symmetry c1
}
</pre></div>
</div>
<p>or by the <code class="docutils literal"><span class="pre">set_point_group</span></code> Python molecule attribute:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">h</span><span class="o">.</span><span class="n">set_point_group</span><span class="p">(</span><span class="s1">&#39;c2v&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>During the SCF procedure, the occupation of orbitals is typically determined by
the Aufbau principal across all spatial symmetries. This may result in the
occupation shifting between iterations. If the occupations are known <em>a priori</em>,
they may be clamped throughout the procedure by using the <a class="reference internal" href="autodoc_glossary_options_c.html#term-docc-globals"><span class="xref std std-term">DOCC</span></a> and
<a class="reference internal" href="autodoc_glossary_options_c.html#term-socc-globals"><span class="xref std std-term">SOCC</span></a> options. For instance, all good quantum chemists know that
<img class="math" src="_images/math/ab44cf29f6b7cf2559186d6ec00af45f66958751.png" alt="C_{2v}" style="vertical-align: -3px"/> water is
actually,:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>molecule h2o {
0 1
O
H 1 1.0
H 1 1.0 2 104.5
}

set {
docc [3,0,1,1] # 1A1 2A1 1B1 3A1 1B2
basis cc-pvdz
}

energy(&#39;scf&#39;)
</pre></div>
</div>
</div>
<div class="section" id="broken-symmetry">
<h2>Broken Symmetry<a class="headerlink" href="#broken-symmetry" title="Permalink to this headline">¶</a></h2>
<p>For certain problems, such diradicals, allowing the spin-up and spin-down
orbitals to differ in closed-shell computations can be advantageous;
this is known as symmetry breaking.  The resulting unrestricted wavefunction
will often provide superior energetics, due to the increased flexibility,
but will suffer non-physicical spin contamination from higher multiplicity states.
A convenient approach to break symmetry is to perform a UHF or UKS calculation
with the guess HOMO and LUMO orbitals mixed.
Mixing of the guess orbitals can be requested by setting the <a class="reference internal" href="autodoc_glossary_options_c.html#term-guess-mix-scf"><span class="xref std std-term">GUESS_MIX</span></a>
keyword to true:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>set reference uhf
set guess_mix true
energy(&#39;scf&#39;)
</pre></div>
</div>
</div>
<div class="section" id="orthogonalization">
<h2>Orthogonalization<a class="headerlink" href="#orthogonalization" title="Permalink to this headline">¶</a></h2>
<p>One of the first steps in the SCF procedure is the determination of an
orthogonal basis (known as the OSO basis) from the atomic orbital basis (known
as the AO basis). The Molecular Orbital basis (MO basis) is then built as a
particular unitary transformation of the OSO basis. In <span class="sc">Psi4</span>, the
determination of the OSO basis is accomplished via either symmetric or canonical
orthogonalization. Symmetric orthogonalization uses the symmetric inverse square
root of the overlap matrix for the orthogonalization matrix. Use of symmetric
orthogonalization always yields the same number of OSO functions (and thereby
MOs) as AO functions. However, this may lead to numerical problems if the
overlap matrix has small eigenvalues, which may occur for large systems or for
systems where diffuse basis sets are used. This problem may be avoided by using
canonical orthogonalization, in which an asymmetric inverse square root of the
overlap matrix is formed, with numerical stability enhanced by the elimination
of eigenvectors corresponding to very small eigenvalues. As a few combinations
of AO basis functions may be discarded, the number of canonical-orthogonalized
OSOs and MOs may be slightly smaller than the number of AOs. In <span class="sc">Psi4</span>,
symmetric orthogonalization is used by default, unless the smallest overlap
eigenvalue falls below the user-supplied double option <a class="reference internal" href="autodoc_glossary_options_c.html#term-s-tolerance-scf"><span class="xref std std-term">S_TOLERANCE</span></a>, which
defaults to 1E-7. If the smallest eigenvalue is below this cutoff, canonical
orthogonalization is forced, and all eigenvectors corresponding to eigenvalues
below the cutoff are eliminated.  Use of canonical orthogonalization can be
forced by setting the <a class="reference internal" href="autodoc_glossary_options_c.html#term-s-orthogonalization-scf"><span class="xref std std-term">S_ORTHOGONALIZATION</span></a> option to <code class="docutils literal"><span class="pre">CANONICAL</span></code>. Note
that in practice, the MOs and OSOs are built separately within each irrep from
the symmetry-adapted combinations of AOs known as Unique Symmetry Orbitals
(USOs).  For canonical orthogonalization, this implies that the number of MOs
and OSOs per irrep may be slightly smaller than the number of USOs per irrep.</p>
<p>A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown
below:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>molecule h2o {
0 1
O
H 1 1.0
H 1 1.0 2 104.5
symmetry c2 # Two irreps is easier to comprehend
}

set {
s_tolerance 0.0001      # Set an unreasonably tight
                        # tolerance to force canonical
basis aug-cc-pv5z       # This diffuse basis will have
                        # small-ish eigenvalues for even H2O
}

energy(&#39;scf&#39;)
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>... Initialization ...

==&gt; Pre-Iterations &lt;==

Minimum eigenvalue in the overlap matrix is 1.6888059293E-05.
Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.
Overall, 3 of 287 possible MOs eliminated.

... Initial Orbital Guess Information ...

 -------------------------------------------------------
  Irrep   Nso     Nmo     Nalpha   Nbeta   Ndocc  Nsocc
 -------------------------------------------------------
   A        145     144       3       3       3       0
   B        142     140       2       2       2       0
 -------------------------------------------------------
  Total     287     284       5       5       5       0
 -------------------------------------------------------
</pre></div>
</div>
<p>In this example, there are 287 AO basis functions after spherical harmonics are
applied. These are used to produce 287 symmetry adapted USOs, 145 of which are
assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,
144 OSOs fall above the eigenvalue cutoff, and within irrep B 140 OSOs fall
above the eigenvalue cutoff. In total, 284 molecular orbitals are chosen from
287 AOs/USOs. The table also shows the initial assignment of electrons to
irreps.</p>
</div>
<div class="section" id="initial-guess-convergence-stabilization">
<h2>Initial Guess/Convergence Stabilization<a class="headerlink" href="#initial-guess-convergence-stabilization" title="Permalink to this headline">¶</a></h2>
<p>In each step of the SCF procedure, a new Fock or Kohn&#8211;Sham potential is built
according to the previous density, following which the potential is diagonalized
to produce new molecular orbitals, from which a new density is computed. This
procedure is continued until either convergence is reached or a preset maximum
number of iterations is exceeded. Convergence is determined by both change in
energy and root-mean-square change in density matrix values, which must be below
the user-specified <a class="reference internal" href="autodoc_glossary_options_c.html#term-e-convergence-scf"><span class="xref std std-term">E_CONVERGENCE</span></a> and <a class="reference internal" href="autodoc_glossary_options_c.html#term-d-convergence-scf"><span class="xref std std-term">D_CONVERGENCE</span></a>, respectively.
The maximum number of iterations is specified by the <a class="reference internal" href="autodoc_glossary_options_c.html#term-maxiter-scf"><span class="xref std std-term">MAXITER</span></a> option. It
should be noted that SCF is a chaotic process, and, as such, often requires
careful selection of initial orbitals and damping during iterations to ensure
convergence. This is particularly likely for large systems, metallic systems,
multireference systems, open-shell systems, anions, and systems with diffuse
basis sets.</p>
<p>For initial orbital selection, several options are available. These include:</p>
<dl class="docutils">
<dt>CORE [Default]</dt>
<dd>Diagonalization of the core Hamiltonian, removing even mean-field electron
repulsion. Simple, but often too far from the final solution for larger
systems.   READ becomes the default for the second and later iterations
of geometry optimizations.</dd>
<dt>SAD</dt>
<dd>Superposition of Atomic Densities. Builds the initial density as the
spin-averaged sum of atomic UHF computations in the current basis. If an
open-shell system, uniform scaling of the spin-averaged density matrices is
performed. If orbitals are needed (e.g., in density fitting), a partial
Cholesky factorization of the density matrices is used. Often extremely
accurate, particularly for closed-shell systems.</dd>
<dt>GWH</dt>
<dd>Generalized Wolfsberg-Helmholtz, a simple Huckel-Theory-like method based on
the overlap and core Hamiltonian matrices. May be useful in open-shell systems.</dd>
<dt>READ</dt>
<dd>Read the previous orbitals from a checkpoint file, casting from one basis to
another if needed. Useful for starting anion computations from neutral
orbitals, or after small geometry changes. At present, casting from a
different molecular point group is not supported.  This becomes the
default for the second and later iterations of geometry optimizations.</dd>
</dl>
<p>These are all set by the <a class="reference internal" href="autodoc_glossary_options_c.html#term-guess-scf"><span class="xref std std-term">GUESS</span></a> keyword. Also, an automatic Python
procedure has been developed for converging the SCF in a small basis, and then
casting up to the true basis. This can be done by adding
<a class="reference internal" href="autodoc_glossary_options_c.html#term-basis-guess-scf"><span class="xref std std-term">BASIS_GUESS</span></a> = SMALL_BASIS to the options list. We recommend the
3-21G basis for the small basis due to its efficient mix of flexibility and
compactness. An example of performing an RHF solution of water by SAD guessing
in a 3-21G basis and then casting up to cc-pVTZ is shown below:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>molecule h2o {
0 1
O
H 1 1.0
H 1 1.0 2 104.5
}

set {
basis cc-pvtz
basis_guess 3-21G
guess sad
}

energy(&#39;scf&#39;)
</pre></div>
</div>
<p>With regard to convergence stabilization, Pulay&#8217;s Direct Inversion of the
Iterative Subspace (DIIS) extrapolation,  Gill&#8217;s Maximum Overlap Method (MOM),
and damping are all implemented. A summary of each is presented below,</p>
<dl class="docutils">
<dt>DIIS [On by Default]</dt>
<dd>DIIS uses previous iterates of the Fock Matrix together
with an error criterion based on the orbital gradient to produce an informed
estimate of the next Fock Matrix. DIIS is almost always necessary to converge
the SCF procedure and is therefore turned on by default. In rare cases, the
DIIS algorithm may need to be modified or turned off altogether, which may be
accomplished via the options detailed below.</dd>
<dt>MOM [Off by Default]</dt>
<dd>MOM was developed to combat a particular class of convergence failure:
occupation flipping. In some cases, midway though the SCF procedure, a partially
converged orbital which should be occupied in the fully-optimized SCF solution
has a slightly higher orbital eigenvalue than some other orbital which should be
destined to be a virtual orbital. This results in the virtual orbital being
spuriously occupied for one or more iterations. Sometimes this resolves itself
without help, other times the occupation flips back and forth between two, four,
or more orbitals. This is typically visible in the output as a non-converging
SCF which eventually settles down to steady oscillation between two (or more)
different total energies. This behavior can be ameliorated by choosing occupied
orbitals by &#8220;shape&#8221; instead of by orbital eigenvalue, i.e., by choosing the set
of new orbitals which looks most like some previously known &#8220;good&#8221; set.  The
&#8220;good&#8221; set is typically the occupied orbitals from an one of the oscillating
iterations with the lowest total energy. For an oscillating system where the
lowest total energy occurs on iterations <img class="math" src="_images/math/956be6f41d8f86b1f8d2edffbb9afa4c6a59812b.png" alt="N,N+2,\ldots" style="vertical-align: -4px"/>, invoking
<a class="reference internal" href="autodoc_glossary_options_c.html#term-mom-start-scf"><span class="xref std std-term">MOM_START</span></a> <img class="math" src="_images/math/8c45b38d633fb6de83fc7087c4db116a5565752a.png" alt="N" style="vertical-align: 0px"/> can often rescue the convergence of the SCF. MOM can
be used in concert with DIIS, though care should be taken to not turn MOM on
until the oscillatory behavior begins.</dd>
<dt>Damping [Off by Default]</dt>
<dd>In some cases, a static mixing of Fock Matrices from adjacent iterations can
quench oscillations. This mixing, known as &#8220;damping&#8221; can be activated by setting
the <a class="reference internal" href="autodoc_glossary_options_c.html#term-damping-percentage-scf"><span class="xref std std-term">DAMPING_PERCENTAGE</span></a> keyword to a nonzero percent.</dd>
</dl>
</div>
<div class="section" id="eri-algorithms">
<h2>ERI Algorithms<a class="headerlink" href="#eri-algorithms" title="Permalink to this headline">¶</a></h2>
<p>The key difficulty in the SCF procedure is treatment of the four-index ERI
contributions to the Fock Matrix. A number of algorithms are available in
<span class="sc">Psi4</span> for these terms. The algorithm is selected by the <a class="reference internal" href="autodoc_glossary_options_c.html#term-scf-type-scf"><span class="xref std std-term">SCF_TYPE</span></a>
keyword, which may be one of the following</p>
<dl class="docutils">
<dt>PK [<a class="reference internal" href="#table-conv-scf"><span>Default</span></a>]</dt>
<dd>An out-of-core, presorted algorithm using exact ERIs. Quite fast for a
zero-error algorithm if enough memory is available. Integrals are
generated only once, and symmetry is utilized to reduce number of
integrals.</dd>
<dt>OUT_OF_CORE</dt>
<dd>An out-of-core, unsorted algorithm using exact ERIs. Overcomes the
memory bottleneck of the current PK algorithm. Integrals are generated
only once, and symmetry is utilized to reduce number of integrals.</dd>
<dt>DIRECT</dt>
<dd>A threaded, sieved, integral-direct algorithm, with full permutational
symmetry. This algorithm is brand new, but seems to be reasonably fast
up to 1500 basis function, uses zero disk, and can obtain significant
speedups with negligible error loss if the <a class="reference internal" href="autodoc_glossary_options_c.html#term-ints-tolerance-scf"><span class="xref std std-term">INTS_TOLERANCE</span></a> value
is set to 1.0E-8 or so.</dd>
<dt>DF [<a class="reference internal" href="#table-conv-scf"><span>Default</span></a>]</dt>
<dd>A density-fitted algorithm designed for computations with thousands of
basis functions. This algorithm is highly optimized, and is threaded
with a mixture of parallel BLAS and OpenMP. Note that this algorithm
should use the -JKFIT series of auxiliary bases, <em>not</em> the -RI or
-MP2FIT bases. The default guess for auxiliary basis set should work
for all Dunning bases, otherwise the <a class="reference internal" href="autodoc_glossary_options_c.html#term-df-basis-scf-scf"><span class="xref std std-term">DF_BASIS_SCF</span></a> keyword can
be used to manually specify the auxiliary basis.  This algorithm is
preferred unless either absolute accuracy is required
[<img class="math" src="_images/math/4fce696da14a7c670c978096a9ffcd38af09193f.png" alt="\gtrsim" style="vertical-align: -5px"/>CCSD(T)] or a -JKFIT auxiliary basis is unavailable
for the primary basis/atoms involved.</dd>
<dt>CD</dt>
<dd>A threaded algorithm using approximate ERI&#8217;s obtained by Cholesky
decomposition of the ERI tensor.  The accuracy of the Cholesky
decomposition is controlled by the keyword <a class="reference internal" href="autodoc_glossary_options_c.html#term-cholesky-tolerance-scf"><span class="xref std std-term">CHOLESKY_TOLERANCE</span></a>.
This algorithm is similar to the DF algorithm, but it is not suitable
for gradient computations.  The algorithm to obtain the Cholesky
vectors is not designed for computations with thousands of basis
functions.</dd>
</dl>
<p>For some of these algorithms, Schwarz and/or density sieving can be used to
identify negligible integral contributions in extended systems. To activate
sieving, set the <a class="reference internal" href="autodoc_glossary_options_c.html#term-ints-tolerance-scf"><span class="xref std std-term">INTS_TOLERANCE</span></a> keyword to your desired cutoff
(1.0E-12 is recommended for most applications).</p>
<p>Recently, we have added the automatic capability to use the extremely fast DF
code for intermediate convergence of the orbitals, for <a class="reference internal" href="autodoc_glossary_options_c.html#term-scf-type-scf"><span class="xref std std-term">SCF_TYPE</span></a>
<code class="docutils literal"><span class="pre">DIRECT</span></code>. At the moment, the code defaults to cc-pVDZ-JKFIT as the
auxiliary basis, unless the user specifies <a class="reference internal" href="autodoc_glossary_options_c.html#term-df-basis-scf-scf"><span class="xref std std-term">DF_BASIS_SCF</span></a> manually. For
some atoms, cc-pVDZ-JKFIT is not defined, so this procedure will fail. In these
cases, you will see an error message of the form:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>RuntimeError: sanity check failed! Gaussian94BasisSetParser::parser:
Unable to find the basis set for HE
</pre></div>
</div>
<p>This failure can be fixed by either setting <a class="reference internal" href="autodoc_glossary_options_c.html#term-df-basis-scf-scf"><span class="xref std std-term">DF_BASIS_SCF</span></a> to an auxiliary
basis set defined for all atoms in the system, or by setting <a class="reference internal" href="autodoc_glossary_options_c.html#term-df-scf-guess-scf"><span class="xref std std-term">DF_SCF_GUESS</span></a>
to false, which disables this acceleration entirely.</p>
</div>
<div class="section" id="second-order-convergence">
<h2>Second-order Convergence<a class="headerlink" href="#second-order-convergence" title="Permalink to this headline">¶</a></h2>
<p>Second-order convergence takes into account both the gradient and Hessian to
take a full Newton step with respect to the orbital parameters. This results in
quadratic convergence with respect to density for SCF methods. For cases where
normal acceleration methods either fail or take many iterations to converge,
second-order can reduce the total time to solution.</p>
<p>Solving second-order (SO) methods exactly would require an inversion of the
orbital Hessian (an expensive <img class="math" src="_images/math/3b904f58e26004a2e631555aef66e99d33c21850.png" alt="\mathbb{N}^6" style="vertical-align: 0px"/> operation); however, these
equations are normally solved iteratively where each iteration costs the same
as a normal Fock build (<img class="math" src="_images/math/2bb1e64b9af9e8c40921ac7e5ec672726701cc9b.png" alt="\mathbb{N}^4" style="vertical-align: 0px"/>). The overall SOSCF operation is
thus broken down into micro- and macroiterations where the microiterations
refer to solving the SOSCF equations and macroiterations are the construction
of a new Fock matrix based on the orbitals from a SOSCF step.</p>
<p>SOSCF requires that all elements of the gradient to be less than one before the
method is valid. To this end, pre-SOSCF SCF iterations use normal
gradient-based extrapolation procedures (e.g., DIIS) until the gradient
conditions are met. Note that while the total number of macroiterations will be
less for SOSCF than gradient-based convergence acceleration the cost of solving
the microiterations typically results in the overall cost being greater for
SOSCF than for gradient-based methods. Therefore, SOSCF should only be used if
it is difficult to locate a stable minimum.</p>
<p>SOSCF is only available for RHF, ROHF, and UHF reference. To turn on simply set
the option <a class="reference internal" href="autodoc_glossary_options_c.html#term-soscf-scf"><span class="xref std std-term">SOSCF</span></a> to <code class="docutils literal"><span class="pre">true</span></code>. Additional options to modify the number of
microiterations taken are as follows:</p>
<blockquote>
<div><p><a class="reference internal" href="autodoc_glossary_options_c.html#term-soscf-r-start-scf"><span class="xref std std-term">SOSCF_R_START</span></a>: when to start SOSCF based on the current density RMS</p>
<p><a class="reference internal" href="autodoc_glossary_options_c.html#term-soscf-max-iter-scf"><span class="xref std std-term">SOSCF_MAX_ITER</span></a>: the maximum number of SOSCF microiterations per macroiteration</p>
<p><a class="reference internal" href="autodoc_glossary_options_c.html#term-soscf-conv-scf"><span class="xref std std-term">SOSCF_CONV</span></a>: the relative convergence tolerance of the SOSCF microiterations</p>
<p><a class="reference internal" href="autodoc_glossary_options_c.html#term-soscf-print-scf"><span class="xref std std-term">SOSCF_PRINT</span></a>: option to print the microiterations or not</p>
</div></blockquote>
</div>
<div class="section" id="stability-analysis">
<h2>Stability Analysis<a class="headerlink" href="#stability-analysis" title="Permalink to this headline">¶</a></h2>
<p>SCF algorithms attempt to minimize the gradient of the energy with respect
to orbital variation parameters. At convergence, the gradient should be approximately zero
given a convergence criterion. Although this is enough to make sure the SCF converged to a
stationary point, this is not a sufficient condition for a minimal SCF solution. It may be
a sadle point or a maximum.</p>
<p>To ensure that a minimum has been found, the electronic Hessian, i.e. the matrix of second
derivatives of the energy with respect to orbital variation parameters, must be computed.
If one or more eigenvalues of the electronic Hessian are negative, the SCF solution is not a minimum.
In that case, orbital parameters can be varied along the lowest Hessian eigenvector to lower the energy.</p>
<p>Orbital variation parameters are usually constrained. For example, in RHF the
spatial parts of the <img class="math" src="_images/math/23bf3bdd8ce99fdb75f17e8b49934c62e9cf0841.png" alt="\alpha" style="vertical-align: 0px"/> and <img class="math" src="_images/math/3edbdde8cd7a5140ace3a7f0b62e850ca34dcafc.png" alt="\beta" style="vertical-align: -4px"/> orbitals are the same. In
UHF, the orbital coefficients are usually constrained to be real. A stability analysis
can check whether a lower SCF solution exists while respecting the constraints of the original
solution; this is an internal instability. If one or more constraints have to be relaxed to reach
a lower-energy solution, there is an external instability. In <span class="sc">Psi4</span>, the only external instability
that can be checked at present is the RHF-&gt;UHF one.</p>
<p>Currently, two algorithms exist in <span class="sc">Psi4</span> for stability analysis: the original
Direct Inversion and the newly implemented Davidson algorithms. We will first describe
options common to both algorithms. To request a stability analysis at the end of the SCF,
set the keyword <a class="reference internal" href="autodoc_glossary_options_c.html#term-stability-analysis-scf"><span class="xref std std-term">STABILITY_ANALYSIS</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>set stability_analysis check
</pre></div>
</div>
<p>to only compute the electronic Hessian eigenvalue and check if an actual SCF minimum
has been found, or:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>set stability_analysis follow
</pre></div>
</div>
<p>to rotate the converged orbitals along the lowest eigenvector, then invoke the SCF
procedure again to lower the energy. In case the minimization does not succeed
or ends up on the same unstable solution, you can tune the scale factor for the orbital
rotation through the keyword <a class="reference internal" href="autodoc_glossary_options_c.html#term-follow-step-scale-scf"><span class="xref std std-term">FOLLOW_STEP_SCALE</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>set follow_step_scale 0.5
</pre></div>
</div>
<p>The rotation angle is <img class="math" src="_images/math/c29f4f42805c9ef000476b771add2941ba339376.png" alt="\frac{\pi}{2}\mbox{ } \cdot" style="vertical-align: -6px"/> (<a class="reference internal" href="autodoc_glossary_options_c.html#term-follow-step-scale-scf"><span class="xref std std-term">FOLLOW_STEP_SCALE</span></a>). The default value of
0.5 usually provides a good guess and modification is only recommended in difficult cases.
The default behavior for the stability code is to stop after trying to reoptimize the orbitals once
if the instability still exists. For more attempts, set <a class="reference internal" href="autodoc_glossary_options_c.html#term-max-attempts-scf"><span class="xref std std-term">MAX_ATTEMPTS</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>set max_attempts 1
</pre></div>
</div>
<p>the default value of 1 is recommended. In case the SCF ends up in the same minimum, modification
of <a class="reference internal" href="autodoc_glossary_options_c.html#term-follow-step-scale-scf"><span class="xref std std-term">FOLLOW_STEP_SCALE</span></a> is recommended over increasing <a class="reference internal" href="autodoc_glossary_options_c.html#term-max-attempts-scf"><span class="xref std std-term">MAX_ATTEMPTS</span></a>.</p>
<p>The main algorithm available in <span class="sc">Psi4</span> is the Direct Inversion algorithm. It can <em>only</em>
work with <a class="reference internal" href="autodoc_glossary_options_c.html#term-scf-type-scf"><span class="xref std std-term">SCF_TYPE</span></a> <code class="docutils literal"><span class="pre">PK</span></code>, and it explicitly builds the full electronic Hessian
matrix before explicitly inverting it. As such, this algorithm is very slow and it should
be avoided whenever possible. Direct Inversion is automatically invoked if the newer algorithm
is not available.</p>
<p>The Davidson algorithm for stability analysis was implemented recently.
Only the lowest eigenvalues of the electronic Hessian are computed, and Hessian-vector
products are computed instead of the full Hessian. This algorithm is thus
much more efficient than the Direct Inversion, but is at present only available for UHF-&gt;UHF stability
analysis. The capabilities of both algorithms are summarized below:</p>
<table border="1" class="docutils" id="id11">
<span id="table-stab-methods"></span><caption><span class="caption-text">Stability analysis methods available in <span class="sc">Psi4</span></span><a class="headerlink" href="#id11" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="22%" />
<col width="22%" />
<col width="35%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Algorithm</th>
<th class="head"><a class="reference internal" href="autodoc_glossary_options_c.html#term-reference-scf"><span class="xref std std-term">REFERENCE</span></a></th>
<th class="head">Stability checked</th>
<th class="head"><a class="reference internal" href="autodoc_glossary_options_c.html#term-scf-type-scf"><span class="xref std std-term">SCF_TYPE</span></a></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td rowspan="2">Direct Inversion</td>
<td>RHF</td>
<td>Internal, External (-&gt;UHF)</td>
<td>PK only</td>
</tr>
<tr class="row-odd"><td>ROHF</td>
<td>Internal</td>
<td>PK only</td>
</tr>
<tr class="row-even"><td>Davidson</td>
<td>UHF</td>
<td>Internal</td>
<td>Anything</td>
</tr>
</tbody>
</table>
<p>The best algorithm is automatically selected, i.e. Davidson for UHF-&gt;UHF and Direct Inversion otherwise.</p>
<p>In addition to the options available for Direct Inversion, the Davidson algorithm can automatically
adapt <a class="reference internal" href="autodoc_glossary_options_c.html#term-follow-step-scale-scf"><span class="xref std std-term">FOLLOW_STEP_SCALE</span></a> to find a new SCF minimum. If <a class="reference internal" href="autodoc_glossary_options_c.html#term-max-attempts-scf"><span class="xref std std-term">MAX_ATTEMPTS</span></a> &gt; 1, additional attempts
will automatically increment <a class="reference internal" href="autodoc_glossary_options_c.html#term-follow-step-scale-scf"><span class="xref std std-term">FOLLOW_STEP_SCALE</span></a> by 0.2 every time the SCF falls back to the previously
found unstable minimum. The increment can be adjusted by setting <a class="reference internal" href="autodoc_glossary_options_c.html#term-follow-step-increment-scf"><span class="xref std std-term">FOLLOW_STEP_INCREMENT</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>set follow_step_increment 0.2
</pre></div>
</div>
<p>The default value is 0.2, adjust if needed to try different values of <a class="reference internal" href="autodoc_glossary_options_c.html#term-follow-step-scale-scf"><span class="xref std std-term">FOLLOW_STEP_SCALE</span></a> in a single compution.</p>
<p>The Davidson solver for the eigenvalues is controlled through several keywords. In the following
we only report the most pertinent for stability analysis, see documentation for the <a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span>CPHF</span></a>
module for a complete list.
Some default values were modified for the stability analysis code, in that case they are
explicitly indicated here.</p>
<blockquote>
<div><p><a class="reference internal" href="autodoc_glossary_options_c.html#term-solver-maxiter-cphf"><span class="xref std std-term">SOLVER_MAXITER</span></a>: maximum number of iterations</p>
<p><a class="reference internal" href="autodoc_glossary_options_c.html#term-solver-convergence-cphf"><span class="xref std std-term">SOLVER_CONVERGENCE</span></a>: eigenvector convergence threshold</p>
<p><a class="reference internal" href="autodoc_glossary_options_c.html#term-solver-n-root-cphf"><span class="xref std std-term">SOLVER_N_ROOT</span></a>: Solve for N eigenvectors in each irreducible representation</p>
<p><a class="reference internal" href="autodoc_glossary_options_c.html#term-solver-n-guess-cphf"><span class="xref std std-term">SOLVER_N_GUESS</span></a>: Use N guess vectors, this needs to be larger than the number of roots so that the lowest ones can be captured reliably. Default within this context: 3</p>
<p><a class="reference internal" href="autodoc_glossary_options_c.html#term-solver-min-subspace-cphf"><span class="xref std std-term">SOLVER_MIN_SUBSPACE</span></a>: Minimum size of the subspace when collapsing.</p>
<p><a class="reference internal" href="autodoc_glossary_options_c.html#term-solver-max-subspace-cphf"><span class="xref std std-term">SOLVER_MAX_SUBSPACE</span></a>: Maximum size of the subspace. Default within this context: 12</p>
</div></blockquote>
<p>In case convergence problems are encountered during the Davidson procedure,
it is recommended to first increase <a class="reference internal" href="autodoc_glossary_options_c.html#term-solver-max-subspace-cphf"><span class="xref std std-term">SOLVER_MAX_SUBSPACE</span></a>, especially if you solve
for a large number of roots. This will result in a higher computational cost of each iteration, but should
make the solver better behaved. However, note that <a class="reference internal" href="autodoc_glossary_options_c.html#term-solver-max-subspace-cphf"><span class="xref std std-term">SOLVER_MAX_SUBSPACE</span></a> should never be larger than
the full subspace minus the number of desired roots to avoid adding artificial zero eigenvalues.
This may happen in minimal basis sets, especially with symmetry, but the code automatically adjusts
<a class="reference internal" href="autodoc_glossary_options_c.html#term-solver-max-subspace-cphf"><span class="xref std std-term">SOLVER_MAX_SUBSPACE</span></a> if it is too large.
If the solver seems to converge on the wrong eigenvalue, try increasing <a class="reference internal" href="autodoc_glossary_options_c.html#term-solver-n-guess-cphf"><span class="xref std std-term">SOLVER_N_GUESS</span></a>.
Otherwise, if the solver is almost converged but reaches the maximum number of iterations, try increasing
<a class="reference internal" href="autodoc_glossary_options_c.html#term-solver-maxiter-cphf"><span class="xref std std-term">SOLVER_MAXITER</span></a>.</p>
</div>
<div class="section" id="external-potentials-and-qm-mm">
<h2>External potentials and QM/MM<a class="headerlink" href="#external-potentials-and-qm-mm" title="Permalink to this headline">¶</a></h2>
<p>In addition to the implementation of <a class="reference internal" href="libefp.html#sec-libefp"><span>EFP</span></a> for accurate QM/MM
computations, <span class="sc">Psi4</span> can perform more rudimentary QM/MM procedures via the
<a class="reference internal" href="autodoc_glossary_options_c.html#term-extern-scf"><span class="xref std std-term">EXTERN</span></a> keyword.  The following snippet, extracted from the
<a class="reference external" href="https://github.com/psi4/psi4/blob/master/samples/extern1/input.dat">extern1</a> test case, demonstrates its use for a TIP3P external potential:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Chrgfield</span> <span class="o">=</span> <span class="n">QMMM</span><span class="p">()</span>
<span class="n">Chrgfield</span><span class="o">.</span><span class="n">extern</span><span class="o">.</span><span class="n">addCharge</span><span class="p">(</span><span class="o">-</span><span class="mf">0.834</span><span class="p">,</span> <span class="mf">1.649232019048</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.356023604706</span><span class="p">)</span>
<span class="n">Chrgfield</span><span class="o">.</span><span class="n">extern</span><span class="o">.</span><span class="n">addCharge</span><span class="p">(</span> <span class="mf">0.417</span><span class="p">,</span> <span class="mf">0.544757019107</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.799961446760</span><span class="p">)</span>
<span class="n">Chrgfield</span><span class="o">.</span><span class="n">extern</span><span class="o">.</span><span class="n">addCharge</span><span class="p">(</span> <span class="mf">0.417</span><span class="p">,</span> <span class="mf">0.544757019107</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.912085762652</span><span class="p">)</span>
<span class="n">psi4</span><span class="o">.</span><span class="n">set_global_option_python</span><span class="p">(</span><span class="s1">&#39;EXTERN&#39;</span><span class="p">,</span><span class="n">Chrgfield</span><span class="o">.</span><span class="n">extern</span><span class="p">)</span>
</pre></div>
</div>
<p>First a QMMM object is created, then three separate particles are added to this
object before the SCF code is told about its existence on the last line.  The
calls to <code class="docutils literal"><span class="pre">addCharge</span></code> take the atomic charge, x coordinate, y coordinate, and
z coordinate in that order.  The atomic charge is specified in atomic units,
and the coordinates always use the same units as the geometry specification in
the regular QM region.  Additional MM molecules may be specified by adding
extra calls to <code class="docutils literal"><span class="pre">addCharge</span></code> to describe the full MM region.</p>
</div>
<div class="section" id="convergence-and-algorithm-defaults">
<h2>Convergence and Algorithm Defaults<a class="headerlink" href="#convergence-and-algorithm-defaults" title="Permalink to this headline">¶</a></h2>
<table border="1" class="docutils" id="id12">
<span id="table-conv-scf"></span><caption><span class="caption-text">SCF algorithm and convergence criteria defaults by calculation type <a class="footnote-reference" href="#f1" id="id1">[1]</a></span><a class="headerlink" href="#id12" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="20%" />
<col width="20%" />
<col width="22%" />
<col width="22%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><em>Ab Initio</em> Method</th>
<th class="head">Calculation Type</th>
<th class="head"><a class="reference internal" href="autodoc_glossary_options_c.html#term-e-convergence-scf"><span class="xref std std-term">E_CONVERGENCE</span></a></th>
<th class="head"><a class="reference internal" href="autodoc_glossary_options_c.html#term-d-convergence-scf"><span class="xref std std-term">D_CONVERGENCE</span></a></th>
<th class="head"><a class="reference internal" href="autodoc_glossary_options_c.html#term-scf-type-scf"><span class="xref std std-term">SCF_TYPE</span></a></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td rowspan="3">SCF of HF or DFT</td>
<td>energy</td>
<td>6</td>
<td>6</td>
<td rowspan="3">DF</td>
</tr>
<tr class="row-odd"><td>optimization</td>
<td>8</td>
<td>8</td>
</tr>
<tr class="row-even"><td>frequency <a class="footnote-reference" href="#f7" id="id2">[7]</a></td>
<td>8</td>
<td>8</td>
</tr>
<tr class="row-odd"><td rowspan="4">SCF of post-HF</td>
<td>energy</td>
<td>8</td>
<td>8</td>
<td rowspan="4">PK <a class="footnote-reference" href="#f3" id="id3">[3]</a></td>
</tr>
<tr class="row-even"><td>optimization</td>
<td>10</td>
<td>10</td>
</tr>
<tr class="row-odd"><td>frequency <a class="footnote-reference" href="#f7" id="id4">[7]</a></td>
<td>10</td>
<td>10</td>
</tr>
<tr class="row-even"><td>CC property <a class="footnote-reference" href="#f2" id="id5">[2]</a></td>
<td>10</td>
<td>10</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils" id="id13">
<span id="table-conv-corl"></span><caption><span class="caption-text">Post-SCF convergence criteria defaults by calculation type <a class="footnote-reference" href="#f4" id="id6">[4]</a></span><a class="headerlink" href="#id13" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="23%" />
<col width="23%" />
<col width="25%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><em>Ab Initio</em> Method</th>
<th class="head">Calculation Type</th>
<th class="head">E_CONVERGENCE <a class="footnote-reference" href="#f5" id="id7">[5]</a></th>
<th class="head">R_CONVERGENCE <a class="footnote-reference" href="#f6" id="id8">[6]</a></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td rowspan="4">post-HF of post-HF</td>
<td>energy</td>
<td>6</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>optimization</td>
<td>8</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>frequency <a class="footnote-reference" href="#f7" id="id9">[7]</a></td>
<td>8</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>CC property <a class="footnote-reference" href="#f2" id="id10">[2]</a></td>
<td>8</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Note that this table applies only the SCF module,
not to the final convergence criteria for post-HF methods or to methods
that use an alternate starting point, like MCSCF. SAPT computations, too,
set tighter values.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="f2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id5">1</a>, <a class="fn-backref" href="#id10">2</a>)</em> This applies to properties computed through the <a class="reference internal" href="prop.html#driver.property" title="driver.property"><code class="xref py py-func docutils literal"><span class="pre">property()</span></code></a> function.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="f3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>Post-HF methods that do not rely upon the usual 4-index AO integrals use a density-
fitted SCF reference. That is, for DF-MP2 and SAPT, the default <a class="reference internal" href="autodoc_glossary_options_c.html#term-scf-type-scf"><span class="xref std std-term">SCF_TYPE</span></a> is DF.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="f4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[4]</a></td><td>Note that this table applies to the final convergence criteria for
all the post-SCF modules that define a <a class="reference internal" href="autodoc_glossary_options_c.html#term-e-convergence-cceom"><span class="xref std std-term">E_CONVERGENCE</span></a> keyword.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="f5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[5]</a></td><td>The E_CONVERGENCE keyword is implemented for most post-SCF modules.
See a list beginning at <a class="reference internal" href="autodoc_glossary_options_c.html#term-e-convergence-cceom"><span class="xref std std-term">E_CONVERGENCE</span></a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="f6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[6]</a></td><td>The R_CONVERGENCE keyword places a convergence check on an internal
residual error measure and is implemented for several post-SCF
modules (see list beginning at <a class="reference internal" href="autodoc_glossary_options_c.html#term-r-convergence-ccenergy"><span class="xref std std-term">R_CONVERGENCE</span></a>). It is defined
according to the quantum chemical method and so its default value is set
by each module individually.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="f7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[7]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id4">2</a>, <a class="fn-backref" href="#id9">3</a>)</em> For frequency computations by finite difference of energies,
convergence criteria are tightened further still to 10 for
<a class="reference internal" href="autodoc_glossary_options_c.html#term-e-convergence-scf"><span class="xref std std-term">E_CONVERGENCE</span></a> and <a class="reference internal" href="autodoc_glossary_options_c.html#term-d-convergence-scf"><span class="xref std std-term">D_CONVERGENCE</span></a> for SCF of HF or DFT, 11
for <a class="reference internal" href="autodoc_glossary_options_c.html#term-e-convergence-scf"><span class="xref std std-term">E_CONVERGENCE</span></a> and <a class="reference internal" href="autodoc_glossary_options_c.html#term-d-convergence-scf"><span class="xref std std-term">D_CONVERGENCE</span></a> for SCF of post-HF,
and 10 for E_CONVERGENCE for post-HF of post-HF.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="recommendations">
<h2>Recommendations<a class="headerlink" href="#recommendations" title="Permalink to this headline">¶</a></h2>
<p>The SCF code is already quite flexible and powerful, with new features being
added weekly. We have tried as much as possible to keep the number of options to
a minimum, and to allow all options to be used in the presence of all other
options. Below are some rough words of advice about using the SCF code for
practical calculations:</p>
<ul class="simple">
<li>For <a class="reference internal" href="autodoc_glossary_options_c.html#term-guess-scf"><span class="xref std std-term">GUESS</span></a>, the <code class="docutils literal"><span class="pre">SAD</span></code> guess is usually your
friend, even for open-shell systems (at the very least, it gets the right
number of electrons, unlike some other programs). For instance, we have found
that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis
and then performing a cast-up, at a fraction of the cost.  However, SAD and
DOCC/SOCC arrays do not play very well together at the moment. Also, the SAD
UHF guess is very slow in large basis sets, so you may want to cast up for
&gt;TZ.</li>
<li>For wall time, <code class="docutils literal"><span class="pre">DF</span></code> may be a factor of ten or more faster than the exact
integral technologies available in PSI4.
Use <code class="docutils literal"><span class="pre">DF</span></code> unless you need absolute accuracy or do not
have a -JKFIT auxiliary set for your primary basis/atom type. Then use
<code class="docutils literal"><span class="pre">DIRECT</span></code>.</li>
<li>Don&#8217;t mess with the DIIS convergence options unless convergence is a problem.
We have optimized the parameters for efficiency over a wide array of system
types.</li>
<li>Buy a developer a beer!</li>
</ul>
<p>The &#8220;best-practice&#8221; input file for HF is:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>memory 1 GB # As much as you&#39;ve got, the DF algorithm can use

molecule {
O
H 1 1.0
H 1 1.0 2 104.5
}

set {
basis cc-pvdz
scf_type df
guess sad
ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK
}

energy(&#39;scf&#39;)
</pre></div>
</div>
<style type="text/css"><!--
 .green {color: red;}
 .sc {font-variant: small-caps;}
 --></style></div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">HF: Hartree&#8211;Fock Theory</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#theory">Theory</a></li>
<li><a class="reference internal" href="#minimal-input">Minimal Input</a></li>
<li><a class="reference internal" href="#spin-symmetry-treatment">Spin/Symmetry Treatment</a></li>
<li><a class="reference internal" href="#broken-symmetry">Broken Symmetry</a></li>
<li><a class="reference internal" href="#orthogonalization">Orthogonalization</a></li>
<li><a class="reference internal" href="#initial-guess-convergence-stabilization">Initial Guess/Convergence Stabilization</a></li>
<li><a class="reference internal" href="#eri-algorithms">ERI Algorithms</a></li>
<li><a class="reference internal" href="#second-order-convergence">Second-order Convergence</a></li>
<li><a class="reference internal" href="#stability-analysis">Stability Analysis</a></li>
<li><a class="reference internal" href="#external-potentials-and-qm-mm">External potentials and QM/MM</a></li>
<li><a class="reference internal" href="#convergence-and-algorithm-defaults">Convergence and Algorithm Defaults</a></li>
<li><a class="reference internal" href="#recommendations">Recommendations</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="notes_c.html"
                        title="previous chapter">Notes on Options</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="dft.html"
                        title="next chapter">DFT: Density Functional Theory</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/scf.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="relbar-bottom">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="contents.html" title="Table Of Contents"
             >toc</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="dft.html" title="DFT: Density Functional Theory"
             >next</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="notes_c.html" title="Notes on Options"
             >previous</a> &nbsp; &nbsp;</li>
    <li><a href="index.html">Psi4 [1.0.0 6a9a71b]</a> &raquo; </li>

          <li class="nav-item nav-item-1"><a href="methods.html" >Theoretical Methods: SCF to FCI</a> &raquo;</li> 
      </ul>
    </div>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, The Psi4 Project.
      Last updated on Tuesday, 05 July 2016 02:54AM.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5.
    </div>
    <!-- cloud_sptheme 1.3 -->
  </body>
</html>