<!-- 
#
# @BEGIN LICENSE
#
# Psi4: an open-source quantum chemistry software package
#
# Copyright (c) 2007-2017 The Psi4 Developers.
#
# The copyrights for code used from other parties are included in
# the corresponding files.
#
# This file is part of Psi4.
#
# Psi4 is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, version 3.
#
# Psi4 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with Psi4; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# @END LICENSE
# -->





<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Keywords by Alpha</title>
    
    <link rel="stylesheet" href="_static/psi4.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" type="text/css" />
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noticia+Text|Open+Sans|Droid+Sans+Mono" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     'add49b9',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/jquery.cookie.js"></script>
    <script type="text/javascript" src="_static/cloud.js"></script>
    <link rel="shortcut icon" href="_static/favicon-psi4.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Keywords by Module" href="autodoc_options_c_bymodule.html" />
    <link rel="prev" title="Appendices" href="appendices.html" /> 
        <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body role="document">
    <div class="relbar-top">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">Index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="autodoc_options_c_bymodule.html" title="Keywords by Module"
             accesskey="N"><i class="fa fa-long-arrow-right fa-lg"></i></a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="appendices.html" title="Appendices"
             accesskey="P"><i class="fa fa-long-arrow-left fa-lg"></i></a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="index.html" title="Table Of Contents"
             accesskey="C"><i class="fa fa-book fa-lg"></i></a> &nbsp; &nbsp;</li>
    <li><a href="http://psicode.org/"><i class="fa fa-home fa-lg"></i></a></li>
    <li><a href="http://github.com/psi4/psi4"><i class="fa fa-github fa-lg"></i></a></li>
    <li><a href="http://forum.psicode.org"><i class="fa fa-comments-o fa-lg"></i></a></li>
    <li><a href="https://github.com/psi4/psi4/edit/master/doc/sphinxman/source/autodoc_glossary_options_c.rst"><i class="fa fa-pencil fa-lg"></i></a></li>
    <li style="color: #1a4162">&nbsp;&middot;&nbsp;</li>
    <li><a href="https://github.com/psi4/psi4/tree/add49b9">1.1</a></li>
    <li style="color: #1a4162">&nbsp;&middot;&nbsp;</li>
    <li class="nav-item nav-item-0"><a href="index.html">
        <span style="font-family: Optima, sans-serif;">P<span style="font-size: 82%;">SI</span>4</span>
        </a><i class="fa fa-angle-double-right" style="color: #a2a7b3; text-shadow: none;"></i></li>

          <li class="nav-item nav-item-1"><a href="appendices.html" accesskey="U">Appendices</a><i class="fa fa-angle-double-right" style="color: #a2a7b3; text-shadow: none;"></i></li> 
      </ul>
    </div>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="keywords-by-alpha">
<span id="apdx-options-c-alpha"></span><h1>Keywords by Alpha<a class="headerlink" href="#keywords-by-alpha" title="Permalink to this headline">¶</a></h1>
<dl class="glossary docutils">
<dt id="term-a-ras3-max-detci">A_RAS3_MAX (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — maximum number of alpha electrons in RAS III</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: -1</li>
</ul>
</dd>
<dt id="term-abcd-ccenergy">ABCD (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Type of ABCD algorithm will be used</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NEW, OLD</li>
<li><strong>Default</strong>: NEW</li>
</ul>
</dd>
<dt id="term-abcd-cceom">ABCD (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Type of ABCD algorithm will be used</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NEW, OLD</li>
<li><strong>Default</strong>: NEW</li>
</ul>
</dd>
<dt id="term-abcd-cclambda">ABCD (CCLAMBDA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cclambda.html#apdx-cclambda"><span class="std std-ref">CCLAMBDA</span></a> — Type of ABCD algorithm will be used</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: NEW</li>
</ul>
</dd>
<dt id="term-abcd-ccresponse">ABCD (CCRESPONSE)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccresponse.html#apdx-ccresponse"><span class="std std-ref">CCRESPONSE</span></a> — Type of ABCD algorithm will be used</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: NEW</li>
</ul>
</dd>
<dt id="term-active-globals">ACTIVE (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — An array giving the number of active orbitals (occupied plus unoccupied) per irrep (shorthand to make MCSCF easier to specify than using RAS keywords)</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-active-nat-orbs-fnocc">ACTIVE_NAT_ORBS (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> — An array containing the number of virtual natural orbitals per irrep (in Cotton order) so a user can specify the number of retained natural orbitals rather than determining them with <a class="reference internal" href="#term-occ-tolerance-fnocc"><span class="xref std std-term">OCC_TOLERANCE</span></a>. This keyword overrides <a class="reference internal" href="#term-occ-tolerance-fnocc"><span class="xref std std-term">OCC_TOLERANCE</span></a> and <a class="reference internal" href="#term-occ-percentage-fnocc"><span class="xref std std-term">OCC_PERCENTAGE</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-add-auxiliary-bonds-optking">ADD_AUXILIARY_BONDS (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Do add bond coordinates at nearby atoms for non-bonded systems?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-ael-ccdensity">AEL (CCDENSITY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccdensity.html#apdx-ccdensity"><span class="std std-ref">CCDENSITY</span></a> <strong>(Expert)</strong> — Do compute the approximate excitation level? See Stanton and Bartlett, JCP, 98, 1993, 7034.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-aio-cphf-sapt">AIO_CPHF (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-aio-df-ints-sapt">AIO_DF_INTS (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-algorithm-dcft">ALGORITHM (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> — Algorithm to use for the density cumulant and orbital updates in the DCFT energy computation. Two-step algorithm is usually more efficient for small systems, but for large systems simultaneous algorithm (default) is recommended. If convergence problems are encountered (especially for highly symmetric systems) QC algorithm can be used.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: TWOSTEP, SIMULTANEOUS, QC</li>
<li><strong>Default</strong>: SIMULTANEOUS</li>
</ul>
</dd>
<dt id="term-analyze-ccenergy">ANALYZE (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Do analyze T2 amplitudes</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-analyze-ccresponse">ANALYZE (CCRESPONSE)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccresponse.html#apdx-ccresponse"><span class="std std-ref">CCRESPONSE</span></a> — Do analyze X2 amplitudes</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-ao-basis-ccdensity">AO_BASIS (CCDENSITY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccdensity.html#apdx-ccdensity"><span class="std std-ref">CCDENSITY</span></a> — The algorithm to use for the <span class="math">\(\left\langle VV||VV\right \rangle\)</span> terms</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NONE, DISK, DIRECT</li>
<li><strong>Default</strong>: NONE</li>
</ul>
</dd>
<dt id="term-ao-basis-ccenergy">AO_BASIS (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> <strong>(Expert)</strong> — The algorithm to use for the <span class="math">\(\left\langle VV||VV\right\rangle\)</span> terms If AO_BASIS is <code class="docutils literal"><span class="pre">NONE</span></code>, the MO-basis integrals will be used; if AO_BASIS is <code class="docutils literal"><span class="pre">DISK</span></code>, the AO-basis integrals stored on disk will be used; if AO_BASIS is <code class="docutils literal"><span class="pre">DIRECT</span></code>, the AO-basis integrals will be computed on the fly as necessary. NB: The <code class="docutils literal"><span class="pre">DIRECT</span></code> option is not fully implemented and should only be used by experts. Default is NONE. Note: The developers recommend use of this keyword only as a last resort because it significantly slows the calculation. The current algorithms for handling the MO-basis four-virtual-index integrals have been significantly improved and are preferable to the AO-based approach.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NONE, DISK, DIRECT</li>
<li><strong>Default</strong>: NONE</li>
</ul>
</dd>
<dt id="term-ao-basis-cclambda">AO_BASIS (CCLAMBDA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cclambda.html#apdx-cclambda"><span class="std std-ref">CCLAMBDA</span></a> — The algorithm to use for the <span class="math">\(\left\langle VV||VV \right\rangle\)</span> terms</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NONE, DISK, DIRECT</li>
<li><strong>Default</strong>: NONE</li>
</ul>
</dd>
<dt id="term-ao-basis-cctransort">AO_BASIS (CCTRANSORT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cctransort.html#apdx-cctransort"><span class="std std-ref">CCTRANSORT</span></a> — The algorithm to use for the <span class="math">\(\left\langle VV||VV \right\rangle\)</span> terms</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NONE, DISK, DIRECT</li>
<li><strong>Default</strong>: NONE</li>
</ul>
</dd>
<dt id="term-ao-basis-dcft">AO_BASIS (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> — Controls whether to avoid the AO-&gt;MO transformation of the two-electron integrals for the four-virtual case (<span class="math">\(\langle VV|| VV \rangle\)</span>) by computing the corresponding terms in the AO basis. AO_BASIS = DISK algorithm reduces the memory requirements and can significantly reduce the cost of the energy computation if SIMULTANEOUS algorithm is used. For the TWOSTEP algorithm, however, AO_BASIS = DISK option is not recommended due to extra I/O.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NONE, DISK</li>
<li><strong>Default</strong>: DISK</li>
</ul>
</dd>
<dt id="term-auxiliary-bond-factor-optking">AUXILIARY_BOND_FACTOR (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — This factor times standard covalent distance is used to add extra stretch coordinates.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 2.5</li>
</ul>
</dd>
<dt id="term-avg-states-detci">AVG_STATES (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Array giving the root numbers of the states to average in a state-averaged procedure such as SA-CASSCF. Root numbering starts from 0.</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-avg-weights-detci">AVG_WEIGHTS (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Array giving the weights for each state in a state-averaged procedure</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-b-ras3-max-detci">B_RAS3_MAX (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — maximum number of beta electrons in RAS III</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: -1</li>
</ul>
</dd>
<dt id="term-basis-dfmp2">BASIS (DFMP2)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfmp2.html#apdx-dfmp2"><span class="std std-ref">DFMP2</span></a> — Primary basis set</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: <a class="reference internal" href="basissets_byelement.html#apdx-basiselement"><span class="std std-ref">basis string</span></a></li>
<li><strong>Default</strong>: NONE</li>
</ul>
</dd>
<dt id="term-basis-mints">BASIS (MINTS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mints.html#apdx-mints"><span class="std std-ref">MINTS</span></a> — Primary basis set. <a class="reference internal" href="basissets_byelement.html#apdx-basiselement"><span class="std std-ref">Available basis sets</span></a></p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: <a class="reference internal" href="basissets_byelement.html#apdx-basiselement"><span class="std std-ref">basis string</span></a></li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-basis-sapt">BASIS (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — Primary basis set, describes the monomer molecular orbitals</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: <a class="reference internal" href="basissets_byelement.html#apdx-basiselement"><span class="std std-ref">basis string</span></a></li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-basis-scf">BASIS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Primary basis set</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: <a class="reference internal" href="basissets_byelement.html#apdx-basiselement"><span class="std std-ref">basis string</span></a></li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-basis-guess-scf">BASIS_GUESS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Accelerate convergence by performing a preliminary scf with this small basis set followed by projection into the full target basis. A value of <code class="docutils literal"><span class="pre">TRUE</span></code> turns on projection using the 3-21G small basis set.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: FALSE</li>
</ul>
</dd>
<dt id="term-basis-relativistic-globals">BASIS_RELATIVISTIC (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-bccd-maxiter-ccenergy">BCCD_MAXITER (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Convert ROHF MOs to semicanonical MOs</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 50</li>
</ul>
</dd>
<dt id="term-bench-globals">BENCH (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — Some codes (DFT) can dump benchmarking data to separate output files</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-bendazzoli-detci">BENDAZZOLI (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Do use some routines based on the papers of Bendazzoli et al. to calculate sigma? Seems to be slower and not worthwhile; may disappear eventually. Works only for full CI and I don&#8217;t remember if I could see how their clever scheme might be extended to RAS in general.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-brueckner-maxiter-fnocc">BRUECKNER_MAXITER (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> — Maximum number of iterations for Brueckner orbitals optimization</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 20</li>
</ul>
</dd>
<dt id="term-brueckner-orbs-r-convergence-ccenergy">BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest <span class="math">\(T_1\)</span> amplitude. Default adjusts depending on <a class="reference internal" href="#term-e-convergence-ccenergy"><span class="xref std std-term">E_CONVERGENCE</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-5</li>
</ul>
</dd>
<dt id="term-cachelevel-adc">CACHELEVEL (ADC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__adc.html#apdx-adc"><span class="std std-ref">ADC</span></a> — How to cache quantities within the DPD library</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-cachelevel-ccdensity">CACHELEVEL (CCDENSITY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccdensity.html#apdx-ccdensity"><span class="std std-ref">CCDENSITY</span></a> — The amount of caching of data to perform</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-cachelevel-ccenergy">CACHELEVEL (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., <span class="math">\(\langle ij | ab \rangle\)</span> integrals) may be held in the cache.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-cachelevel-cceom">CACHELEVEL (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., <span class="math">\(\left\langle ij | ab \right\rangle\)</span> integrals) may be held in the cache.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-cachelevel-cchbar">CACHELEVEL (CCHBAR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cchbar.html#apdx-cchbar"><span class="std std-ref">CCHBAR</span></a> — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., <span class="math">\(\langle ij | ab \rangle\)</span> integrals) may be held in the cache.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-cachelevel-cclambda">CACHELEVEL (CCLAMBDA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cclambda.html#apdx-cclambda"><span class="std std-ref">CCLAMBDA</span></a> — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., <span class="math">\(\left\langle ij | ab \right\rangle\)</span> integrals) may be held in the cache.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-cachelevel-ccresponse">CACHELEVEL (CCRESPONSE)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccresponse.html#apdx-ccresponse"><span class="std std-ref">CCRESPONSE</span></a> — Caching level for libdpd</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-cachelevel-cctransort">CACHELEVEL (CCTRANSORT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cctransort.html#apdx-cctransort"><span class="std std-ref">CCTRANSORT</span></a> — Caching level for libdpd</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-cachelevel-dcft">CACHELEVEL (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> <strong>(Expert)</strong> — Controls how to cache quantities within the DPD library</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-cachelevel-occ">CACHELEVEL (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., <span class="math">\(\langle ij | ab \rangle\)</span> integrals) may be held in the cache.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-cachetype-ccenergy">CACHETYPE (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of <code class="docutils literal"><span class="pre">LOW</span></code> selects a &#8220;low priority&#8221; scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a &#8220;least recently used&#8221; scheme in which the oldest item in the cache will be the first one deleted.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: LOW, LRU</li>
<li><strong>Default</strong>: LOW</li>
</ul>
</dd>
<dt id="term-cachetype-cceom">CACHETYPE (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — The criterion used to retain/release cached data</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: LOW, LRU</li>
<li><strong>Default</strong>: LRU</li>
</ul>
</dd>
<dt id="term-calc-s-squared-detci">CALC_S_SQUARED (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Do calculate the value of <span class="math">\(\langle S^2\rangle\)</span> for each root? Only supported for <a class="reference internal" href="#term-icore-detci"><span class="xref std std-term">ICORE</span></a> = 1.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-canonicalize-active-favg-mcscf">CANONICALIZE_ACTIVE_FAVG (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-canonicalize-inactive-favg-mcscf">CANONICALIZE_INACTIVE_FAVG (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> — Do canonicalize the inactive (DOCC and Virtual) orbitals such that the average Fock matrix is diagonal?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cart-hess-read-optking">CART_HESS_READ (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Do read Cartesian Hessian? Only for experts - use <a class="reference internal" href="#term-full-hess-every-optking"><span class="xref std std-term">FULL_HESS_EVERY</span></a> instead.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cc-detci">CC (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Do coupled-cluster computation?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cc3-follow-root-cceom">CC3_FOLLOW_ROOT (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Do turn on root following for CC3</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cc-a-ras3-max-detci">CC_A_RAS3_MAX (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — maximum number of alpha electrons in RAS III, for CC</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: -1</li>
</ul>
</dd>
<dt id="term-cc-b-ras3-max-detci">CC_B_RAS3_MAX (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — maximum number of beta electrons in RAS III, for CC</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: -1</li>
</ul>
</dd>
<dt id="term-cc-diis-max-vecs-dfocc">CC_DIIS_MAX_VECS (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Maximum number of vectors used in amplitude DIIS</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 6</li>
</ul>
</dd>
<dt id="term-cc-diis-max-vecs-occ">CC_DIIS_MAX_VECS (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Maximum number of vectors used in amplitude DIIS</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 6</li>
</ul>
</dd>
<dt id="term-cc-diis-min-vecs-dfocc">CC_DIIS_MIN_VECS (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Minimum number of vectors used in amplitude DIIS</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-cc-diis-min-vecs-occ">CC_DIIS_MIN_VECS (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Minimum number of vectors used in amplitude DIIS</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-cc-ex-level-detci">CC_EX_LEVEL (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — The CC excitation level</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-cc-fix-external-detci">CC_FIX_EXTERNAL (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Do fix amplitudes involving RAS I or RAS IV? Useful in mixed MP2-CC methods.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cc-fix-external-min-detci">CC_FIX_EXTERNAL_MIN (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Number of external indices before amplitude gets fixed by <a class="reference internal" href="#term-cc-fix-external-detci"><span class="xref std std-term">CC_FIX_EXTERNAL</span></a>. Experimental.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-cc-lambda-dfocc">CC_LAMBDA (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Do solve lambda amplitude equations?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cc-macro-detci">CC_MACRO (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — CC_MACRO = [ [ex_lvl, max_holes_I, max_parts_IV, max_I+IV], [ex_lvl, max_holes_I, max_parts_IV, max_I+IV], ... ] Optional additional restrictions on allowed excitations in coupled-cluster computations, based on macroconfiguration selection. For each sub-array, [ex_lvl, max_holes_I, max_parts_IV, max_I+IV], eliminate cluster amplitudes in which: [the excitation level (holes in I + II) is equal to ex_lvl] AND [there are more than max_holes_I holes in RAS I, there are more than max_parts_IV particles in RAS IV, OR there are more than max_I+IV quasiparticles in RAS I + RAS IV].</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cc-maxiter-dfocc">CC_MAXITER (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Maximum number of iterations to determine the amplitudes</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 50</li>
</ul>
</dd>
<dt id="term-cc-maxiter-occ">CC_MAXITER (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Maximum number of iterations to determine the amplitudes</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 50</li>
</ul>
</dd>
<dt id="term-cc-mixed-detci">CC_MIXED (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Do ignore block if num holes in RAS I and II is <span class="math">\(&gt;\)</span> cc_ex_lvl and if any indices correspond to RAS I or IV (i.e., include only all-active higher excitations)?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-cc-num-threads-ccenergy">CC_NUM_THREADS (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Number of threads</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-cc-num-threads-cceom">CC_NUM_THREADS (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Number of threads</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-cc-num-threads-cctriples">CC_NUM_THREADS (CCTRIPLES)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cctriples.html#apdx-cctriples"><span class="std std-ref">CCTRIPLES</span></a> — Number of threads</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-cc-num-threads-psimrcc">CC_NUM_THREADS (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — Number of threads</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-cc-os-scale-ccenergy">CC_OS_SCALE (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Coupled-cluster opposite-spin scaling value</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.27</li>
</ul>
</dd>
<dt id="term-cc-ras34-max-detci">CC_RAS34_MAX (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — maximum number of electrons in RAS III + IV, for CC</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: -1</li>
</ul>
</dd>
<dt id="term-cc-ras3-max-detci">CC_RAS3_MAX (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — maximum number of electrons in RAS III, for CC</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: -1</li>
</ul>
</dd>
<dt id="term-cc-ras4-max-detci">CC_RAS4_MAX (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — maximum number of electrons in RAS IV, for CC</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: -1</li>
</ul>
</dd>
<dt id="term-cc-scale-os-fnocc">CC_SCALE_OS (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> — Oppposite-spin scaling factor for SCS-CCSD</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.27</li>
</ul>
</dd>
<dt id="term-cc-scale-ss-fnocc">CC_SCALE_SS (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> — Same-spin scaling factor for SCS-CCSD</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.13</li>
</ul>
</dd>
<dt id="term-cc-ss-scale-ccenergy">CC_SS_SCALE (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Coupled-cluster same-spin scaling value</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.13</li>
</ul>
</dd>
<dt id="term-cc-timings-fnocc">CC_TIMINGS (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> — Do time each cc diagram?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cc-type-globals">CC_TYPE (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — Algorithm to use for CC or CEPA computation (e.g., CCD, CCSD(T), CEPA(3), ACPF). See <a class="reference internal" href="notes_c.html#table-managedmethods"><span class="std std-ref">Cross-module Redundancies</span></a> for details.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: DF, CONV, CD</li>
<li><strong>Default</strong>: CONV</li>
</ul>
</dd>
<dt id="term-cc-update-eps-detci">CC_UPDATE_EPS (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Do update T amplitudes with orbital eigenvalues? (Usually would do this). Not doing this is experimental.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-cc-val-ex-level-detci">CC_VAL_EX_LEVEL (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — The CC valence excitation level</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-cc-variational-detci">CC_VARIATIONAL (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Do use variational energy expression in CC computation? Experimental.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cc-vecs-read-detci">CC_VECS_READ (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Do import a CC vector from disk?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cc-vecs-write-detci">CC_VECS_WRITE (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Do export a CC vector to disk?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-ccd-e-convergence-sapt">CCD_E_CONVERGENCE (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — E converge value for CCD</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-8</li>
</ul>
</dd>
<dt id="term-ccd-maxiter-sapt">CCD_MAXITER (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — Max CCD iterations</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 50</li>
</ul>
</dd>
<dt id="term-ccd-t-convergence-sapt">CCD_T_CONVERGENCE (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — Convergence tolerance for CCD amplitudes</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-8</li>
</ul>
</dd>
<dt id="term-ccl-energy-occ">CCL_ENERGY (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Do compute CC Lambda energy? In order to this option to be valid one should use &#8220;TPDM_ABCD_TYPE = COMPUTE&#8221; option.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cepa-level-fnocc">CEPA_LEVEL (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> <strong>(Expert)</strong> — Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won&#8217;t have any effect on the procedure.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: CEPA(0)</li>
</ul>
</dd>
<dt id="term-cepa-no-singles-fnocc">CEPA_NO_SINGLES (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> — Flag to exclude singly excited configurations from a coupled-pair computation.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cepa-os-scale-occ">CEPA_OS_SCALE (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — CEPA opposite-spin scaling value from SCS-CCSD</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.27</li>
</ul>
</dd>
<dt id="term-cepa-sos-scale-occ">CEPA_SOS_SCALE (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — CEPA Spin-opposite scaling (SOS) value</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.3</li>
</ul>
</dd>
<dt id="term-cepa-ss-scale-occ">CEPA_SS_SCALE (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — CEPA same-spin scaling value from SCS-CCSD</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.13</li>
</ul>
</dd>
<dt id="term-cepa-type-occ">CEPA_TYPE (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: CEPA0</li>
<li><strong>Default</strong>: CEPA0</li>
</ul>
</dd>
<dt id="term-cfour-abcdtype-cfour">CFOUR_ABCDTYPE (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the way the <span class="math">\(\langle ab||cd \rangle\)</span> molecular orbital integrals are handled in post-MP2 calculations. STANDARD (= 0) uses directly the corresponding MO integrals and thus results in an algorithm which in particular for large-scale calculations results in excessive use of disk space (storage of all <span class="math">\(\langle ab||cd\rangle\)</span> integrals. AOBASIS (=2) uses an AO-based algorithm to evaluate all terms involving the <span class="math">\(\langle ab||cd\rangle\)</span> integrals and significantly reduces the amount of disk storage. The use of ABCDTYPE=AOBASIS is strongly recommended for all CC calculations up to CCSD(T) and has been implemented for energy, gradient, second-derivative, and excitation energy calculations.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: STANDARD, AOBASIS</li>
<li><strong>Default</strong>: STANDARD</li>
</ul>
</dd>
<dt id="term-cfour-active-orbi-cfour">CFOUR_ACTIVE_ORBI (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the active orbitals used in a TCSCF calculation and has to be used in combination with the keyword <a class="reference internal" href="#term-cfour-core-orbitals-cfour"><span class="xref std std-term">CFOUR_CORE_ORBITALS</span></a>. The active orbitals are specified by either NIRREP or 2*NIRREP integers specifying the number of active orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. For more information and an example see <a class="reference internal" href="#term-cfour-occupation-cfour"><span class="xref std std-term">CFOUR_OCCUPATION</span></a> .</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cfour-anh-algorithm-cfour">CFOUR_ANH_ALGORITHM (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies which algorithm is used for <a class="reference internal" href="#term-cfour-anharmonic-cfour"><span class="xref std std-term">CFOUR_ANHARMONIC</span></a> =VIBROT, VPT2, and FULLQUARTIC calculations. If STANDARD (=0) is chosen, then simply invoking <code class="docutils literal"><span class="pre">xcfour</span></code> will cause a complete job to be run with all second-derivative calculations being done in series. If PARALLEL (=1), then the job stops after the second-derivative calculation at the reference geometry and generates out all input geometries for the remaining calculation. These can be then processed in &#8220;parallel&#8221; (currently not recommended). Note that it is recommended to carry out all calculations with PARALLEL, even when the actual calculation is carried out in a sequential mode.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: STANDARD, PARALLEL</li>
<li><strong>Default</strong>: STANDARD</li>
</ul>
</dd>
<dt id="term-cfour-anh-derivatives-cfour">CFOUR_ANH_DERIVATIVES (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether the anharmonic force field is calculated using analytic gradients (=FIRST) or analytic Hessians (=SECOND).</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: FIRST, SECOND</li>
<li><strong>Default</strong>: SECOND</li>
</ul>
</dd>
<dt id="term-cfour-anh-stepsize-cfour">CFOUR_ANH_STEPSIZE (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Controls the stepsize used in anharmonic force field calculations. The value is specified in reduced normal coordinates, which are dimensionless. The actual stepsize used in the calculation is <span class="math">\(\times 10^6\)</span> the integer value specified.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 50000</li>
</ul>
</dd>
<dt id="term-cfour-anh-symmetry-cfour">CFOUR_ANH_SYMMETRY (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether non-abelian symmetry is to be exploited in determining displacements for <a class="reference internal" href="#term-cfour-anharmonic-cfour"><span class="xref std std-term">CFOUR_ANHARMONIC</span></a> =VIBROT or VPT2 calculations. If set to NONABELIAN (=0), maximum advantage will be taken of symmetry and the full set of cubic force constants will be generated from a skeleton set by application of the totally symmetric projection operator. If set to ABELIAN (=1), only the operations of the abelian subgroup will be exploited. Note: It is important to point out that the symmetrization currently works only for cubic constants. Therefore, if you require quartic force constants (for frequency calculations), you <em>must</em> use the ABELIAN option. Moreover, the latter work for only asymmetric tops and linear molecules.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: ABELIAN, NONABELIAN</li>
<li><strong>Default</strong>: ABELIAN</li>
</ul>
</dd>
<dt id="term-cfour-anharmonic-cfour">CFOUR_ANHARMONIC (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies treatment of anharmonic effects by calculating cubic and/or quartic force fields. VIBROT (=3) requests calculation of only those cubic constants of the form <span class="math">\(\phi_{nij}\)</span>, where n is a totally symmetric coordinate. These are sufficient to determine the vibration-rotation interaction constants needed to calculate vibrational corrections to rotational constants, but are <em>not</em> sufficient to generate the corresponding cubic constants of isotopologs that have a lower point-group symmetry (<em>i.e.</em> HOD isotopolog of water). VPT2 (=1, note that the old value CUBIC can be still used and is equivalent to VPT2) generates all cubic constants and all quartic constants apart from those of the form <span class="math">\(\phi_{ijkl}\)</span>, which is enough for: 1) generation of cubic constants of isotopologs (see manual entries associated with anharmonic calculations for an example); 2) calculation of vibrational energy levels with VPT2. This keyword also directs the program to analyze resonances and calculate intensities of one- and two-quantum transitions. FULLQUARTIC (=2) (not part of the public release) is largely self-explanatory; it directs the program to calculate all quartic constants. This is sufficient (but this has not been implemented) to generate the full quartic force field of all isotopologs.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: CUBIC, VPT2, FULLQUARTIC, VIBROT, OFF</li>
<li><strong>Default</strong>: OFF</li>
</ul>
</dd>
<dt id="term-cfour-ao-ladders-cfour">CFOUR_AO_LADDERS (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Can be used to control the algorithm used by CFOUR when terms involving <span class="math">\(\langle ab||cd\rangle\)</span> molecular orbital integrals are calculated in the atomic orbital basis (see <a class="reference internal" href="#term-cfour-abcdtype-cfour"><span class="xref std std-term">CFOUR_ABCDTYPE</span></a>). MULTIPASS (= 0) uses an approach where the AO integral file is read a number of times in order to ensure maximal vectorization and is usually the optimal strategy on supercomputers; SINGLEPASS (= 1) determines the contributions with only a single pass through the AO integrals, but at the cost of significantly reduced vectorization. In general, however, SINGLEPASS is definitely preferable on workstations with RISC architectures. (Default : MULTIPASS on all 64-bit machines (e.g., CRAY-YMP) ; SINGLEPASS on all 32-bit machines (e.g., IBM-RS6000, HP-735, SGI-Indigo, DEC alphastations)). SPARSE_AO (=2) uses a sparse matrix algorithm which first rearranges the integral matrix in order to get &#8220;well-occupied&#8221; and &#8220;very sparse&#8221; blocks. &#8220;Well-occupied&#8221; blocks will be multiplied by matrix multiplication while in &#8220;very sparse&#8221; blocks only the non-zero elements are considered. The computational time is further reduced using symmetrized and anti-symmetrized integral and amplitude matrices in the multiplication. Substantial saving is assumed if SPARSE_AO (=2) is used.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: MULTIPASS, SINGLEPASS</li>
<li><strong>Default</strong>: SINGLEPASS</li>
</ul>
</dd>
<dt id="term-cfour-av-scf-cfour">CFOUR_AV_SCF (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Experimental Use! ON (=1) requests and averaged SCF over two states. So far only implemented for degenerate doublet-Pi states and used in conjunction with SOPERT.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cfour-basis-cfour">CFOUR_BASIS (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the AO basis used in the calculation. One can either specify a basis known to CFOUR or via BASIS=SPECIAL (=0) requests an arbitrary basis (see non-standard basis-set input). However, the latter must be available in the supplied GENBAS file. As standard basis sets, currently the following are available. <strong>Psi4 Interface:</strong> Recommended to use instead <a class="reference internal" href="#term-basis-mints"><span class="xref std std-term">BASIS</span></a> for larger basis set selection and greater flexibility. When <a class="reference internal" href="#term-basis-mints"><span class="xref std std-term">BASIS</span></a> used, <a class="reference internal" href="#term-cfour-spherical-cfour"><span class="xref std std-term">CFOUR_SPHERICAL</span></a> is set appropriately.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: STO-3G, 3-21G, 4-31G, 6-31G, 6-31G*, 6-31G**, 6-311G, 6-311G*, 6-311G**, DZ, DZP, TZ, TZP, TZ2P, PVDZ, PVTZ, PVQZ, PV5Z, PV6Z, PCVDZ, PCVTZ, PCVQZ, PCV5Z, PCV6Z, AUG-PVDZ, AUG-PVTZ, AUG-PVTZ, AUG-PVQZ, AUG-PV5Z, AUG-PV6Z, D-AUG-PVDZ, D-AUG-PVTZ, D-AUG-PVQZ, D-AUG-PV5Z, D-AUG-PV6Z, cc-pVDZ, cc-pVTZ, cc-pVQZ, cc-pV5Z, cc-pV6Z, cc-pCVDZ, cc-pCVTZ, cc-pCVQZ, cc-pCV5Z, cc-pCV6Z, PWCVDZ, PWCVTZ, PWCVQZ, PWCV5Z, PWCV6Z, PwCVDZ, PwCVTZ, PwCVQZ, PwCV5Z, PwCV6Z, svp, dzp, tzp, tzp2p, qz2p, pz3d2f, 13s9p4d3f, WMR, ANO0, ANO1, ANO2, EVEN_TEMPERED, SPECIAL</li>
<li><strong>Default</strong>: SPECIAL</li>
</ul>
</dd>
<dt id="term-cfour-bruck-conv-cfour">CFOUR_BRUCK_CONV (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — experimental use</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 4</li>
</ul>
</dd>
<dt id="term-cfour-brueckner-cfour">CFOUR_BRUECKNER (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether Brueckner orbitals are to be determined for the specified CC method. OFF(=0) Brueckner orbitals are not to be determined, ON (=1) they are to be determined.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cfour-cache-recs-cfour">CFOUR_CACHE_RECS (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — The number of records held in the i/o cache used by the post-SCF programs. The maximum number of records which can be held is 100.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 10</li>
</ul>
</dd>
<dt id="term-cfour-calc-level-cfour">CFOUR_CALC_LEVEL (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Defines the level of calculation to be performed. <strong>Psi4 Interface:</strong> Keyword set from argument of computation command: CCSD if <code class="docutils literal"><span class="pre">energy('c4-ccsd')</span></code>, <em>etc.</em> See <a class="reference internal" href="cfour_table_energy.html#table-energy-cfour"><span class="std std-ref">Energy (CFOUR)</span></a> and <a class="reference internal" href="cfour_table_grad.html#table-grad-cfour"><span class="std std-ref">Gradient (CFOUR)</span></a>. for all available.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: SCF, HF, MBPT(2), MP2, MBPT(3), MP3, SDQ-MBPT(4), SDQ-MP4, MBPT(4), MP4, CCD, CCSD, CCSD(T), CCSDT-1, CCSDT-1b, CCSDT-2, CCSDT-3, CCSDT-4, CCSDT, CC2, CC3, QCISD, QCISD(T), CID, CISD, UCC(4), B-CCD</li>
<li><strong>Default</strong>: SCF</li>
</ul>
</dd>
<dt id="term-cfour-cc-conv-cfour">CFOUR_CC_CONV (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the convergence criterion for the CC amplitude equations. The amplitudes are considered to be converged when the maximum of all (absolute) changes in the amplitudes is less than <span class="math">\(10^N\)</span>, where <span class="math">\(N\)</span> is the value associated with the keyword.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 7</li>
</ul>
</dd>
<dt id="term-cfour-cc-exporder-cfour">CFOUR_CC_EXPORDER (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the maximum number of expansion vectors used in the iterative subspace to enhance convergence in the solution of the CC equations.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 5</li>
</ul>
</dd>
<dt id="term-cfour-cc-extrapolation-cfour">CFOUR_CC_EXTRAPOLATION (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the type of convergence acceleration used to solve the CC equations. RLE (=0) uses the RLE methods of Purvis and Bartlett, DIIS (=1) uses the DIIS approach by Pulay, NOJACOBI (=2) uses RLE with continuous extrapolation, OFF (=3) uses no convergence acceleration. In general, DIIS provides the best results and is recommended, while OFF often results in poor convergence and thus cannot be recommended.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: RLE, DIIS, NOJACOBI, OFF</li>
<li><strong>Default</strong>: DIIS</li>
</ul>
</dd>
<dt id="term-cfour-cc-maxcyc-cfour">CFOUR_CC_MAXCYC (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the maximum number of iterations in solving the CC amplitude equations.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 50</li>
</ul>
</dd>
<dt id="term-cfour-cc-program-cfour">CFOUR_CC_PROGRAM (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies which CC program is used. The available options are VCC (=0), ECC (=1), MRCC (=2), and EXTERNAL (=3). The default for all calculations is currently VCC which requests usage of <code class="docutils literal"><span class="pre">xvcc</span></code>, but in many cases (e.g., for CCSD and CCSD(T)) ECC should be preferred due to the better performance of <code class="docutils literal"><span class="pre">xecc</span></code> (available currently for CCSD, CCSD+T, CCSD(T), and closed-shell CCSDT-n, CC3, and CCSDT). MRCC and External are intended for CC programs outside the CFOUR suite, e.g., the general CC module mrcc written by M. Kallay (Budapest, Hungary). Default: VCC Note: Using the option ECC is not recommended for ROHF gradients. That is, if you are doing a geometry optimization with ROHF as your reference wave function then it is safe to use the option VCC. <strong>Psi4 Interface:</strong> Keyword set according to best practice for the computational method <a class="reference internal" href="#term-cfour-calc-level-cfour"><span class="xref std std-term">CFOUR_CALC_LEVEL</span></a>, reference <a class="reference internal" href="#term-cfour-reference-cfour"><span class="xref std std-term">CFOUR_REFERENCE</span></a> (NYI) and derivative level <a class="reference internal" href="#term-cfour-deriv-level-cfour"><span class="xref std std-term">CFOUR_DERIV_LEVEL</span></a> according to Table <a class="reference internal" href="cfour.html#table-cfour-cc-program"><span class="std std-ref">Best Practices</span></a> when method specified by argument to computation command (<em>e.g.</em>, when <code class="docutils literal"><span class="pre">energy('c4-ccsd')</span></code> requested but not when <code class="docutils literal"><span class="pre">energy('cfour')</span></code> requested). Value can always be set explicitly.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: VCC, ECC, MRCC, EXTERNAL</li>
<li><strong>Default</strong>: VCC</li>
</ul>
</dd>
<dt id="term-cfour-charge-cfour">CFOUR_CHARGE (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the molecular charge. <strong>Psi4 Interface:</strong> Keyword set from active molecule.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-cfour-cis-conv-cfour">CFOUR_CIS_CONV (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the convergence threshold as <span class="math">\(10^{-N}\)</span> for CIS calculations.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 5</li>
</ul>
</dd>
<dt id="term-cfour-continuum-cfour">CFOUR_CONTINUUM (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Signifies that one or more &#8220;continuum&#8221; orbitals should be added to the calculation. VIRTUAL and DVIRTUAL specify one or two orbital which should be initially unoccupied (in the SCF calculation), while OCCUPIED and DOCCUPIED specify one or two orbitals which should be initially occupied.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NONE, VIRTUAL, DVIRTUAL, OCCUPIED, DOCCUPIED</li>
<li><strong>Default</strong>: NONE</li>
</ul>
</dd>
<dt id="term-cfour-contraction-cfour">CFOUR_CONTRACTION (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the contraction scheme used by the integral and integral derivative program. SEGMENTED (=0) uses a segmented contraction scheme; GENERAL (=1) uses a general contraction scheme, and UNCONTRACTED (=2) uses the corresponding uncontracted sets. Note that even for truly segmented basis sets, the integral programs run significantly faster in the GENERAL mode.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: SEGMENTED, GENERAL, UNCONTRACTED</li>
<li><strong>Default</strong>: GENERAL</li>
</ul>
</dd>
<dt id="term-cfour-convergence-cfour">CFOUR_CONVERGENCE (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Identical to <a class="reference internal" href="#term-cfour-geo-conv-cfour"><span class="xref std std-term">CFOUR_GEO_CONV</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 4</li>
</ul>
</dd>
<dt id="term-cfour-coordinates-cfour">CFOUR_COORDINATES (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the type of coordinates used in the input file ZMAT. Value INTERNAL (=0) means that the geometry is supplied in the usual Z-matrix format, while CARTESIAN (=1) means that the geometry is given in Cartesian coordinates. A third option is XYZINT (=2) for which a Z-matrix connectivity is defined, but with values of the internal coordinates defined implicitly by supplying Cartesian coordinates. Note that geometry optimizations are currently only possible for INTERNAL and XYZ2INT. <strong>Psi4 Interface:</strong> Keyword set from active molecule, always CARTESIAN. Above restrictions on geometry optimizations no longer apply.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: INTERNAL, CARTESIAN, XYZINT</li>
<li><strong>Default</strong>: INTERNAL</li>
</ul>
</dd>
<dt id="term-cfour-core-orbitals-cfour">CFOUR_CORE_ORBITALS (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the core orbitals used in a TCSCF calculation and has to be used in combination with the keyword <a class="reference internal" href="#term-cfour-active-orbi-cfour"><span class="xref std std-term">CFOUR_ACTIVE_ORBI</span></a>. The core orbitals are specified by either NIRREP or 2*NIRREP integers specifying the number of core orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. For more information and an example see <a class="reference internal" href="#term-cfour-occupation-cfour"><span class="xref std std-term">CFOUR_OCCUPATION</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cfour-cphf-conver-cfour">CFOUR_CPHF_CONVER (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the convergence criterion for the iterative solution of the CPHF and Z-vector equations. The solutions are considered to be converged when the residual norm of the error vector falls below <span class="math">\(10^N\)</span>.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 12</li>
</ul>
</dd>
<dt id="term-cfour-cphf-maxcyc-cfour">CFOUR_CPHF_MAXCYC (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the maximum number of cycles allowed for the solution of the CPHF- and/or Z-vector equations.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 64</li>
</ul>
</dd>
<dt id="term-cfour-curvilinear-cfour">CFOUR_CURVILINEAR (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether or not Hessian matrix is transformed (nonlinearly) to curvilinear internal coordinates. A value of 0 (or OFF) turns the transformation off if the analytic force constants are not available, while it is always performed if CURVILINEAR=1 (or ON). Values higher than 1 (or NO) unconditionally turn the transformation off.(Default: ON if analytic Hessian is available, OFF otherwise).</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-cfour-dboc-cfour">CFOUR_DBOC (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether the diagonal Born-Oppenheimer correction (DBOC) to the energy is evaluated (ON =1) or not (OFF =0). DBOC calculations are currently only available for HF-SCF and CCSD using RHF or UHF reference functions.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cfour-dct-cfour">CFOUR_DCT (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether the Dipole Coupling Tensor (DCT) is calculated (ON =1) or not (OFF =0).</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cfour-deriv-level-cfour">CFOUR_DERIV_LEVEL (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether or not energy derivatives are to be calculated and if so whether first or second derivatives are computed. ZERO (= 0) derivatives are not calculated, FIRST (=1) first derivatives are calculated, SECOND (=2) second derivatives are calculated. Note that this keyword usually needs not be set in any calculation since it is automatically set if the appropriate other options in the CFOUR namelist are turned on. <strong>Psi4 Interface:</strong> Keyword set from type of computation command: ZERO if <code class="xref py py-func docutils literal"><span class="pre">energy()</span></code>, FIRST if <code class="xref py py-func docutils literal"><span class="pre">gradient()</span></code> or <code class="xref py py-func docutils literal"><span class="pre">optimization()</span></code>, <em>etc.</em></p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: ZERO, FIRST, SECOND</li>
<li><strong>Default</strong>: ZERO</li>
</ul>
</dd>
<dt id="term-cfour-diff-type-cfour">CFOUR_DIFF_TYPE (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether orbital-relaxed (RELAXED =0) or orbital-unrelaxed (UNRELAXED =1) derivatives are computed in the CC calculation.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: RELAXED, UNRELAXED</li>
<li><strong>Default</strong>: RELAXED</li>
</ul>
</dd>
<dt id="term-cfour-dropmo-cfour">CFOUR_DROPMO (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies which molecular orbitals will be dropped from the post-SCF calculation. The orbitals are numbered in ascending order from the most stable (negative energy) to the most unstable (largest positive energy). Individual orbitals must be separated with a dash, while x&gt;y means orbitals x through y inclusive. For example, the string <code class="docutils literal"><span class="pre">1&gt;10-55-58&gt;64</span></code>, would result in orbitals 1,2,3,4,5,6,7,8,9,10,55,58,59,60,61,62,63 and 64 being dropped. For UHF calculations, the appropriate orbitals are deleted for both spin cases. No dropped virtual MOs are currently allowed for gradient or property calculations.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cfour-ecp-cfour">CFOUR_ECP (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether effective core potentials (pseudopotentials) are used (ON, =1) or not (OFF, =0).</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cfour-eigenvector-cfour">CFOUR_EIGENVECTOR (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies which eigenvector of the totally symmetric part of the block-factored Hessian is to be followed uphill in a transition state search. Eigenvectors are indexed by their eigenvalues &#8211; the lowest eigenvalue is 1, the next lowest is 2, etc. The default is 1, which should always be used if you are not looking for a specific transition state which you know corresponds to motion along a different mode. In the future, relatively sophisticated generation of a guessed eigenvector will be implemented, but this is the way things are for now. Of course, this keyword has no meaning if <a class="reference internal" href="#term-cfour-method-cfour"><span class="xref std std-term">CFOUR_METHOD</span></a> is not set to TS.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-cfour-el-anharm-cfour">CFOUR_EL_ANHARM (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Experimental use, ON = 1 requests the evaluation of electrical anharmonicities</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cfour-eom-nonit-cfour">CFOUR_EOM_NONIT (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Controls whether non-iterative triples corrections are applied after various types of EOM-CCSD calculation. Works with <a class="reference internal" href="#term-cfour-excite-cfour"><span class="xref std std-term">CFOUR_EXCITE</span></a> set to EOMIP, might work with EOMEE, certainly doesn&#8217;t work with EOMEA. Use with great caution, preferably after having a few drinks.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cfour-estate-conv-cfour">CFOUR_ESTATE_CONV (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the threshold used in converging CC-LR/EOM-CC calculations. The iterative diagonalization is continued until the RMS residual falls below <span class="math">\(10^{-N}\)</span> with <span class="math">\(N\)</span> as the value specified with this keyword.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 5</li>
</ul>
</dd>
<dt id="term-cfour-estate-maxcyc-cfour">CFOUR_ESTATE_MAXCYC (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — The maximum number of expansion vectors used in the solution of EOMCC equations (Default: 20, hard-coded to 4 in triples calculations)</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 20</li>
</ul>
</dd>
<dt id="term-cfour-estate-prop-cfour">CFOUR_ESTATE_PROP (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — This keyword applies only to EOM-CC calculations and specifies whether any excited or ionized state one-electron properties are to be calculated. Proper use of this keyword requires a relatively advanced knowledge of quantum chemistry and the available options are discussed here. The options are: OFF (=0) [no properties or transition moments are calculated]; EXPECTATION (=1) [transition moments and dipole strengths are calculated along with selected one-electron properties which are evaluated as expectation values]; UNRELAXED (=2) [selected one-electron properties are calculated in an approximation that neglects relaxation of molecular orbitals]; RESPONSE (=3) [selected one-electron properties are calculated as analytic first derivatives of the energy]. Except for EOMCC calculations on two-electron systems (which are exact), properties obtained by the three approaches will not be equivalent. The default value for this keyword is slightly complicated. For TDA calculations, the default is EXPECTATION since the evaluation of transition moments involves only a negligible amount of additional computation relative to the evaluation of the excitation energies. For EOMCC, the default is OFF since evaluation of any transition moments or properties requires approximately twice the computational time. Transition moments and dipole strengths are evaluated by default for all values of ESTATE_PROP other than OFF.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: OFF, EXPECTATION, UNRELAXED, RESPONSE</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cfour-estate-sym-cfour">CFOUR_ESTATE_SYM (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the number of excited states which are to be determined in each irreducible representation of the computational subgroup. The program attempts to find all of the lowest roots, but this is not guaranteed because the eigenvalue problem is not solved by direct matrix diagonalization, but rather by an iterative (modified Davidson) algorithm. For excited state gradient calculations, only one root (clearly) is used. In such a case, one and only one non-zero entry in the string can be used, and this value is usually set to one (<em>i.e.</em> 0/1/0/0). (However sometimes one wants to calculate the gradient for, say, the second root of a given symmetry, and in such a case, one could use 0/2/0/0. What happens is that both roots are calculated, but only the second one is used in the subsequent density matrix and gradient calculation.) The format used for this keyword is identical to that used in <a class="reference internal" href="#term-cfour-occupation-cfour"><span class="xref std std-term">CFOUR_OCCUPATION</span></a>. For example, for a computational subgroup having four symmetry species, the string 3/1/0/2 specifies that 6 total roots should be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the <code class="docutils literal"><span class="pre">%excite*</span></code> input, if present, takes precedence over this keyword. Default: All zeros.</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cfour-estate-trans-cfour">CFOUR_ESTATE_TRANS (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether just the excitation energies (OFF, =0) or in addition transition moments (EXPECTATION, =1) are calculated. Note that this keyword should not be used in excited-state calculations involving analytic gradients and that transition moments are essentially only available for EOM-CCSD/CCSD-LR.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: OFF, EXPECTATION</li>
<li><strong>Default</strong>: OFF</li>
</ul>
</dd>
<dt id="term-cfour-eval-hess-cfour">CFOUR_EVAL_HESS (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Tells the program, in the course of a geometry optimization, to calculate the Hessian explicitly every N cycles. 0 means never calculated explicitly. <strong>Psi4 Interface:</strong> Geometry optimizations run through PSI (except in sandwich mode) use PSI&#8217;s optimizer and so this keyword has no effect. Use <a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">optking</span></a> keywords instead, particularly <a class="reference internal" href="#term-full-hess-every-optking"><span class="xref std std-term">FULL_HESS_EVERY</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-cfour-excitation-cfour">CFOUR_EXCITATION (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies in CC calculations using mrcc the excitation level if the calculation level has been chosen as CC(n), CI(n), or CCn(n).</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-cfour-excite-cfour">CFOUR_EXCITE (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the type of EOM-CC/LR-CC treatment to be performed. Available options are NONE (=0), EOMEE (=3, the EOM-CC/CC-LR approach for the treatment of excited states), EOMIP (=4, the EOM-CC/CC-LR approach for the treatment of ionized states), EOMEA (=7, the EOM-CC/CC-LR approach for the treatment of electron-attached states).</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NONE, EOMEE, EOMIP, EOMEA</li>
<li><strong>Default</strong>: NONE</li>
</ul>
</dd>
<dt id="term-cfour-fc-field-cfour">CFOUR_FC_FIELD (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the strength of a Fermi-Contact perturbation as required for finite-field calculations of spin densities and the FC contributions to indirect spin-spin coupling constants. The value must be specified as an integer and the FC strength used by the program will be the value of the keyword <span class="math">\(\times 10^{-6}\)</span>. The atom for which the FC perturbation is switched on is specified in the ZMAT file after the CFOUR command line and potential basis set input, as follows %spin density N with N as the number of atom (in (X5,I3) format) in the order they are written by JODA to the MOL file. Be aware that for some atoms, the calculation has to be run in lower symmetry or even without symmetry. (Default : 0)</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-cfour-fd-calctype-cfour">CFOUR_FD_CALCTYPE (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the algorithm used to compute the harmonic force constants in finite-difference calculations.GRADONLY (=0) evaluates the force constants and dipole moment derivatives by numerical differentiation of analytic gradients; ENERONLY (=1) evaluates the force constants by second differences of energies (dipole moment derivatives are not evaluated); while MIXED (=2) evaluates 1x1 blocks of symmetry-blocked force constants by second differences pf energies and all other elements by first differences of gradients. the GRADONLY and MIXED approaches may, of course, only be used hwen using computational methods for which analytic gradients are available.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: GRADONLY, ENERONLY, MIXED</li>
<li><strong>Default</strong>: GRADONLY</li>
</ul>
</dd>
<dt id="term-cfour-fd-irreps-cfour">CFOUR_FD_IRREPS (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Requests that only vibrational frequencies of certain symmetry types are evaluated in a VIBRATION=FINDIF calculation. The numbers of the irreducible representations for which vibrational analysis is to be performed are separated by slashes. For example, FD_IRREP=1/3/4 means compute the frequencies of modes transforming as the first, third, and fourth irreducible representations. If a symmetry is specified for which there are no vibrational modes, the program will terminate. The labels of the irreducible representations for this keyword are not usually the same as those used in the rest of the calculation. Moreover, for some point groups, for example, those of linear molecules, the two sets of labels refer to different subgroups. There is as yet no straightforward way to determine what they will be without starting a calculation. If one runs the <code class="docutils literal"><span class="pre">xjoda</span></code> and then the <code class="docutils literal"><span class="pre">xsymcor</span></code> executables, the relevant irreducible representations will be listed. If all vibrational frequencies are desired, this keyword need not be included. Default : compute vibrational frequencies for all irreducible representations</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cfour-fd-project-cfour">CFOUR_FD_PROJECT (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether or not rotational degrees of freedoms are projected out from the symmetry-adapted coordinates in a finite difference calculations. ON (=0) uses rotationally projected coordinates, while OFF (=1) retains the rotational degrees of freedom. At a stationary point on the potential energy surface, both options will give equivalent harmonic force fields, but OFF should be used at non-stationary points.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: ON, OFF</li>
<li><strong>Default</strong>: ON</li>
</ul>
</dd>
<dt id="term-cfour-fd-stepsize-cfour">CFOUR_FD_STEPSIZE (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the step length in mass-weighted coordinates (in <span class="math">\(10^{-4} amu^{1/2} bohr\)</span> ) used in generating the force constant matrix by finite difference of Cartesian gradients.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 5</li>
</ul>
</dd>
<dt id="term-cfour-fd-usegroup-cfour">CFOUR_FD_USEGROUP (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — In finite difference calculations using the FINDIF option, this keyword specifies the point group to be used in generating the symmetry-adapted vibrational coordinates. FULL (= 0) specifies the full molecular point group, COMP (= 1) specifies the Abelian subgroup used in the electronic structure calculation.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: FULL, COMP</li>
<li><strong>Default</strong>: FULL</li>
</ul>
</dd>
<dt id="term-cfour-file-recsiz-cfour">CFOUR_FILE_RECSIZ (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — This specifies the physical length (in integer words) of the records used in the word-addressable direct access files used by CFOUR. This value should always be chosen as a multiple of 512 bytes, as your local system manager certainly understands.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2048</li>
</ul>
</dd>
<dt id="term-cfour-file-stripe-cfour">CFOUR_FILE_STRIPE (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — This option allows the splitting of files. Input is required in the form N1/N2/N3/N4/N5, where N1, N2, N3, N4, and N5 specify the number of files in which <code class="docutils literal"><span class="pre">MOINTS</span></code>, <code class="docutils literal"><span class="pre">GAMLAM</span></code>, <code class="docutils literal"><span class="pre">MOABCD</span></code>, <code class="docutils literal"><span class="pre">DERINT</span></code>, and <code class="docutils literal"><span class="pre">DERGAM</span></code> are split, respectively.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: 0/0/0/0/0</li>
</ul>
</dd>
<dt id="term-cfour-finite-perturbation-cfour">CFOUR_FINITE_PERTURBATION (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the field strength for a perturbation (defined within a <code class="docutils literal"><span class="pre">%perturbation</span></code> section). The value must be given as an integer, and the field strength used by the program will be then the value of the keyword <span class="math">\(\times 10^{-6}\)</span>.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-cfour-fock-cfour">CFOUR_FOCK (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — This option is used to control the algorithm used for construction of the Fock matrix in SCF calculations. PK (=0) uses the PK-supermatrix approach while AO (=1) constructs the matrix directly from the basis function integrals. In general, PK is somewhat faster, but results in considerable use of disk space when out-of-core algorithms are required. (Default: FOCK).</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: PK, AO</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cfour-freq-algorithm-cfour">CFOUR_FREQ_ALGORITHM (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — FREQ_ALGORIT experimental use</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: STANDARD, PARALLEL</li>
<li><strong>Default</strong>: STANDARD</li>
</ul>
</dd>
<dt id="term-cfour-frozen-core-cfour">CFOUR_FROZEN_CORE (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether in the correlation treatment all electron (OFF =0) or only the valence electrons (ON =1) are considered. This keyword provides an alternative to the <a class="reference internal" href="#term-cfour-dropmo-cfour"><span class="xref std std-term">CFOUR_DROPMO</span></a> keyword, as it allows frozen-core calculation without explicitly specifying the corresponding inner-shell orbitals.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cfour-frozen-virt-cfour">CFOUR_FROZEN_VIRT (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether in the correlation treatment all virtual orbitals (OFF =0) or only a subset of virtual orbitals (ON =1) are used. In the latter case, the threshold for deleting virtual orbitals based on the orbital energy needs to be specified in a <code class="docutils literal"><span class="pre">%frozen_virt</span></code> section.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cfour-gamma-abcd-cfour">CFOUR_GAMMA_ABCD (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Used to control the handling and storage of two-particle density matrix elements with four virtual indices <span class="math">\(\Gamma(abcd)\)</span>. DISK (=0) directs the program to calculate and store all elements of <span class="math">\(\Gamma(abcd)\)</span>, while DIRECT (=1) tells the program to use alternative algorithms in which <span class="math">\(\Gamma(abcd)\)</span> is calculated and used &#8220;on the fly&#8221;. Note that this option might be not available for all type of calculations.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: DISK, DIRECT</li>
<li><strong>Default</strong>: DISK</li>
</ul>
</dd>
<dt id="term-cfour-genbas-1-cfour">CFOUR_GENBAS_1 (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — This keyword applies only to Hydrogen and Helium atoms and specifies the number of contracted Gaussian functions per shell. There is usually no need to use this keyword, but it can be useful for using a subset of the functions in a particular entry in the <code class="docutils literal"><span class="pre">GENBAS</span></code> file, particularly for generally contracted WMR basis sets. For example, if entry H:BASIS in the <code class="docutils literal"><span class="pre">GENBAS</span></code> file contains 7 contracted s functions, 4 p functions and a single d function, then setting GENBAS_1=730 would eliminate the last p function and the d function. Default: use the unaltered <code class="docutils literal"><span class="pre">GENBAS</span></code> entry.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cfour-genbas-2-cfour">CFOUR_GENBAS_2 (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — This keyword performs the same function as <a class="reference internal" href="#term-cfour-genbas-1-cfour"><span class="xref std std-term">CFOUR_GENBAS_1</span></a> above, but applies to second-row atoms.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cfour-genbas-3-cfour">CFOUR_GENBAS_3 (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — This keyword performs the same function as <a class="reference internal" href="#term-cfour-genbas-1-cfour"><span class="xref std std-term">CFOUR_GENBAS_1</span></a> and <a class="reference internal" href="#term-cfour-genbas-2-cfour"><span class="xref std std-term">CFOUR_GENBAS_2</span></a> , but applies to third-row atoms.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cfour-genbas-4-cfour">CFOUR_GENBAS_4 (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — This keyword performs the same function as <a class="reference internal" href="#term-cfour-genbas-1-cfour"><span class="xref std std-term">CFOUR_GENBAS_1</span></a> , <a class="reference internal" href="#term-cfour-genbas-2-cfour"><span class="xref std std-term">CFOUR_GENBAS_2</span></a> , and <a class="reference internal" href="#term-cfour-genbas-3-cfour"><span class="xref std std-term">CFOUR_GENBAS_3</span></a> , but applies to fourth-row atoms.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cfour-geo-conv-cfour">CFOUR_GEO_CONV (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below <span class="math">\(10^{-N}\)</span> Hartree/bohr, where <span class="math">\(N\)</span> is the specified value. <strong>Psi4 Interface:</strong> Geometry optimizations run through PSI (except in sandwich mode) use PSI&#8217;s optimizer and so this keyword has no effect. Use <a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">optking</span></a> keywords instead, particularly <a class="reference internal" href="#term-g-convergence-optking"><span class="xref std std-term">G_CONVERGENCE</span></a> =CFOUR, which should be equivalent except for different internal coordinate definitions.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 5</li>
</ul>
</dd>
<dt id="term-cfour-geo-maxcyc-cfour">CFOUR_GEO_MAXCYC (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the maximum allowed number of geometry optimization cycles. <strong>Psi4 Interface:</strong> Geometry optimizations run through PSI (except in sandwich mode) use PSI&#8217;s optimizer and so this keyword has no effect. Use <a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">optking</span></a> keywords instead, particularly <a class="reference internal" href="#term-geom-maxiter-optking"><span class="xref std std-term">GEOM_MAXITER</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 50</li>
</ul>
</dd>
<dt id="term-cfour-geo-maxstep-cfour">CFOUR_GEO_MAXSTEP (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies largest step (in millibohr) which is allowed in geometry optimizations. <strong>Psi4 Interface:</strong> Geometry optimizations run through PSI (except in sandwich mode) use PSI&#8217;s optimizer and so this keyword has no effect. Use <a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">optking</span></a> keywords instead, particularly <a class="reference internal" href="#term-intrafrag-step-limit-optking"><span class="xref std std-term">INTRAFRAG_STEP_LIMIT</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 300</li>
</ul>
</dd>
<dt id="term-cfour-geo-method-cfour">CFOUR_GEO_METHOD (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the used geometry optimization methods. The following values are permitted: NR (=0) &#8212; straightforward Newton-Raphson search for minimum; RFA (=1) &#8212; Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) &#8212; Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); SINGLE_POINT (=5) for a single-point energy calculation. ENERONLY (=6) requests a geometry optimization based on single-point energy calculations. Default: SINGLE-POINT (NR as soon as variables are marked to be optimized).</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NR, RFA, TS, MANR, SINGLE_POINT, ENERONLY</li>
<li><strong>Default</strong>: SINGLE_POINT</li>
</ul>
</dd>
<dt id="term-cfour-giao-cfour">CFOUR_GIAO (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether gauge-including atomic orbitals are used (ON) or not (OFF). Default: ON for <a class="reference internal" href="#term-cfour-props-cfour"><span class="xref std std-term">CFOUR_PROPS</span></a> =NMR and =MAGNETIC, otherwise OFF</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: ON, OFF</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cfour-grid-cfour">CFOUR_GRID (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Keyword used to control type of grid calculation (see later section in this manual). Options are OFF (=0), no grid calculation; CARTESIAN (=1), steps are in Cartesian coordinates (which must be run with <a class="reference internal" href="#term-cfour-coordinates-cfour"><span class="xref std std-term">CFOUR_COORDINATES</span></a> =CARTESIAN); INTERNAL (=2), steps are in Z-matrix internal coordinates; QUADRATURE (=3) steps are chosen for an integration based on Gauss-Hermite quadrature. (Default: OFF)</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: OFF, CARTESIAN, INTERNAL, QUADRATURE</li>
<li><strong>Default</strong>: OFF</li>
</ul>
</dd>
<dt id="term-cfour-guess-cfour">CFOUR_GUESS (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Where the initial SCF eigenvectors are read from. MOREAD means to read from the disk (the <code class="docutils literal"><span class="pre">JOBARC</span></code> file) and CORE means to use a core Hamiltonian initial guess. If MOREAD is chosen but no disk file is present, the core Hamiltonian is used. (Default: MOREAD)</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: MOREAD, CORE</li>
<li><strong>Default</strong>: MOREAD</li>
</ul>
</dd>
<dt id="term-cfour-hbar-cfour">CFOUR_HBAR (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — This keyword determines which action is taken by the linear response program. ON (=1) the full effective Hamiltonian is calculated and written to disk; OFF (=0) the &#8220;lambda&#8221; linear response equations are solved.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cfour-hfstability-cfour">CFOUR_HFSTABILITY (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Control analysis of the stability of RHF, ROHF and UHF wavefunctions, as well as a possible search for a lower SCF solution. There are three possible options for this keyword. OFF (=0) does nothing, while ON (=1) performs a stability analysis and returns the number of negative eigenvalues in the orbital rotation Hessian. A third option, FOLLOW (=2) performs the stability analysis and then proceeds to rotate the SCF orbitals in the direction of a particular negative eigenvalue of the orbital rotation Hessian (see the explanation of keyword <a class="reference internal" href="#term-cfour-rot-evec-cfour"><span class="xref std std-term">CFOUR_ROT_EVEC</span></a>), after which the SCF is rerun.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: OFF, ON, FOLLOW</li>
<li><strong>Default</strong>: OFF</li>
</ul>
</dd>
<dt id="term-cfour-incore-cfour">CFOUR_INCORE (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — This keyword can be used to significantly reduce disk i/o, and should be implemented very soon. The following options are available: OFF (= 0), no special algorithms are used (the default case); ALL (=1) all quantities except the <span class="math">\(\langle ab\vert\vert cd\rangle\)</span> molecular integral lists are held in core; PARTIAL (= 2), the T2 and T1 vectors are held in core throughout the calculation; (=4) all quantities except the <span class="math">\(\langle ab\vert\vert cd\rangle\)</span> and <span class="math">\(\langle ab\vert\vert ci\rangle\)</span> integrals are held in core; (=5) <span class="math">\(\langle ij\vert\vert kl\rangle\)</span> and <span class="math">\(\langle ij\vert\vert ka\rangle\)</span> and two-index quantities are held in core; (=6) all direct access files (<code class="docutils literal"><span class="pre">MOINTS</span></code>, <code class="docutils literal"><span class="pre">GAMLAM</span></code>, etc.) are held in core. At present, these options have been implemented only in the energy code <code class="docutils literal"><span class="pre">xvcc</span></code> and the excitation energy code <code class="docutils literal"><span class="pre">xvee</span></code>. (Default: 0)</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: OFF, ALL, PARTIAL</li>
<li><strong>Default</strong>: OFF</li>
</ul>
</dd>
<dt id="term-cfour-input-mrcc-cfour">CFOUR_INPUT_MRCC (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether an input for mrcc is written (ON, =0) or not (OFF, =1) if <a class="reference internal" href="#term-cfour-cc-program-cfour"><span class="xref std std-term">CFOUR_CC_PROGRAM</span></a> =EXTERNAL has been specified.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-cfour-integrals-cfour">CFOUR_INTEGRALS (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — This keyword defines what type of integral input will be written by <code class="docutils literal"><span class="pre">xjoda</span></code>. VMOL (=1) has to be used with the programs of CFOUR. Using ARGOS (=0), input for Pitzer&#8217;s ARGOS integral program will be written. (Default: VMOL).</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: VMOL, ARGOS</li>
<li><strong>Default</strong>: VMOL</li>
</ul>
</dd>
<dt id="term-cfour-joda-print-cfour">CFOUR_JODA_PRINT (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Controls amount of debug printing performed by <code class="docutils literal"><span class="pre">xjoda</span></code>. The higher the number, the more information is printed. Values of 25 or higher generally do not produce anything of interest to the general user. Do not set JODA_PRINT to 999 as this will cause the core vector to be dumped to disk.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-cfour-lineq-conv-cfour">CFOUR_LINEQ_CONV (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Convergence threshold for linear equations controlled by LINEQ_TYPE. Equations are iterated until smallest residual falls below <span class="math">\(10^{-N}\)</span>, where <span class="math">\(N\)</span> is the value associated with this keyword.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 7</li>
</ul>
</dd>
<dt id="term-cfour-lineq-maxcy-cfour">CFOUR_LINEQ_MAXCY (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — The maximum number of iterations in all linear CC equations.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 50</li>
</ul>
</dd>
<dt id="term-cfour-lineq-type-cfour">CFOUR_LINEQ_TYPE (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Determines the algorithm used to solve linear equations ( <span class="math">\(\Lambda\)</span> and derivative <span class="math">\(T\)</span> and <span class="math">\(\Lambda\)</span> ). POPLE (=0) uses Pople&#8217;s method of successively orthogonalized basis vectors, while DIIS (=1) uses Pulay&#8217;s DIIS method. The latter offers the practical advantage of requiring much less disk space, although it is not guaranteed to converge. Moreover, POPLE has not been tested for some time and should definitely be checked! (Default : DIIS)</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: POPLE, DIIS</li>
<li><strong>Default</strong>: DIIS</li>
</ul>
</dd>
<dt id="term-cfour-lock-orbocc-cfour">CFOUR_LOCK_ORBOCC (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — This keyword is used by the SCF program to determine if the orbital occupancy (by symmetry block) is allowed to change in the course of the calculation. ON (=1) locks the occupation to that set by the keyword <a class="reference internal" href="#term-cfour-occupation-cfour"><span class="xref std std-term">CFOUR_OCCUPATION</span></a> (or the initial guess if omitted); OFF (= 0) permits the occupation to change. (Default : 1 if the occupation is specified with <a class="reference internal" href="#term-cfour-occupation-cfour"><span class="xref std std-term">CFOUR_OCCUPATION</span></a> and for second and later steps of optimizations; 0 if <a class="reference internal" href="#term-cfour-occupation-cfour"><span class="xref std std-term">CFOUR_OCCUPATION</span></a> omitted.)</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cfour-maxstep-cfour">CFOUR_MAXSTEP (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Identical to <a class="reference internal" href="#term-cfour-geo-maxstep-cfour"><span class="xref std std-term">CFOUR_GEO_MAXSTEP</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 300</li>
</ul>
</dd>
<dt id="term-cfour-mem-unit-cfour">CFOUR_MEM_UNIT (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the units in which the amount of requested core memory is given. Possible choices are INTEGERWORDS (default), kB, MB, GB, and TB. <strong>Psi4 Interface:</strong> Keyword set from memory input command when given, always MB.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: INTEGERWORDS, KB, MB, GB, TB</li>
<li><strong>Default</strong>: INTEGERWORDS</li>
</ul>
</dd>
<dt id="term-cfour-memory-size-cfour">CFOUR_MEMORY_SIZE (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the amount of core memory used in integer words (default) or in the units specified via the keyword <a class="reference internal" href="#term-cfour-mem-unit-cfour"><span class="xref std std-term">CFOUR_MEM_UNIT</span></a>. Default: 100 000 000 (approximately 381 or 762 MB for 32 or 64 bit machines, respectively). <strong>Psi4 Interface:</strong> Keyword set in MB from memory input command when given.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 100000000</li>
</ul>
</dd>
<dt id="term-cfour-method-cfour">CFOUR_METHOD (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the geometry optimization strategy. Four values are permitted: NR (=0) &#8211; Straightforward Newton-Raphson search for minimum; RFA (=1) &#8211; Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) &#8211; Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); 4 is currently unavailable; SINGLE_POINT (=5) is a single point calculation. <strong>Psi4 Interface:</strong> Geometry optimizations run through PSI (except in sandwich mode) use PSI&#8217;s optimizer and so this keyword has no effect. Use <a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">optking</span></a> keywords instead, particularly <a class="reference internal" href="#term-opt-type-optking"><span class="xref std std-term">OPT_TYPE</span></a> and <a class="reference internal" href="#term-step-type-optking"><span class="xref std std-term">STEP_TYPE</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NR, RFA, TS, MANR, SINGLE_POINT</li>
<li><strong>Default</strong>: SINGLE_POINT</li>
</ul>
</dd>
<dt id="term-cfour-mrcc-cfour">CFOUR_MRCC (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the type of MRCC calculation. MK performs a MR-CC calculation based on Mukherjee&#8217;s ansatz.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cfour-multiplicity-cfour">CFOUR_MULTIPLICITY (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the spin multiplicity. <strong>Psi4 Interface:</strong> Keyword set from active molecule.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-cfour-nacoupling-cfour">CFOUR_NACOUPLING (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Calculation of non-adiabatic coupling. In case of ON (=1) the method by Ichino, Gauss, Stanton is used to obtain the lambda coupling, while in case of LVC (=3) the lambda coupling is computed by means of the algorithm by Tajti and Szalay. Furthermore, NACV (=2) requests the computation of the full non-adiabatic coupling. Note that for calculations using LVC or NACV options the multiroot diagonalization has to be used, as requested via the keyword CFOUR_EOM_NSTATES (dne?) =MULTIROOT.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: ON, NACV, LVC</li>
<li><strong>Default</strong>: OFF</li>
</ul>
</dd>
<dt id="term-cfour-negeval-cfour">CFOUR_NEGEVAL (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies what to do if negative eigenvalues are encountered in the totally symmetric Hessian during an NR or MANR geometry-optimization search. If ABORT (=0), the job will terminate with an error message; if SWITCH (=1) the program will just switch the eigenvalue to its absolute value and keep plugging away (this is strongly discouraged!); and if RFA (=2), the keyword <a class="reference internal" href="#term-cfour-geo-method-cfour"><span class="xref std std-term">CFOUR_GEO_METHOD</span></a> is switched to RFA internally and the optimization is continued. <strong>Psi4 Interface:</strong> Geometry optimizations run through PSI (except in sandwich mode) use PSI&#8217;s optimizer and so this keyword has no effect. Use <a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">optking</span></a> keywords instead.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: ABORT, SWITCH, RFA</li>
<li><strong>Default</strong>: ABORT</li>
</ul>
</dd>
<dt id="term-cfour-newnorm-cfour">CFOUR_NEWNORM (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — All components of spherical AO&#8217;s are normalized to 1. This feature can help with numerical convergence issues if AO integrals are involved. Currently only working for single-point energy calculations.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cfour-nonhf-cfour">CFOUR_NONHF (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether the reference function used in the correlation energy calculation satisfies the (spin-orbital) HF equations or not. Usually there is no need to set this parameter (OFF = 0 and ON =1), since standard non-HF reference functions (QRHF and ROHF) set this flag automatically.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cfour-ntop-tamp-cfour">CFOUR_NTOP_TAMP (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies how many t amplitudes will be printed for each spin case and excitation level. For =N, The largest N amplitudes for each spin case and excitation level will be printed.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 15</li>
</ul>
</dd>
<dt id="term-cfour-occupation-cfour">CFOUR_OCCUPATION (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the orbital occupancy of the reference function in terms of the occupation numbers of the orbitals and their irreducible representations. The occupancy is specified by either NIRREP or 2*NIRREP integers specifying the number of occupied orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. If the reference function is for an open-shell system, two strings of NIRREP occupation numbers separated by a slash are input for the <span class="math">\(\alpha\)</span> and <span class="math">\(\beta\)</span> sets of orbitals. An example of the use of the OCCUPATION keyword for the water molecule would be OCCUPATION=3-1-1-0. For the <span class="math">\(^2A_1\)</span> water cation, an open-shell system, the keyword would be specified by OCCUPATION=3-1-1-0/2-1-1-0. It should be noted that the <code class="docutils literal"><span class="pre">xvmol</span></code> integral program orders the irreducible representations in a strange way, which most users do not perceive to be a logical order. Hence, it is usually advisable initially to run just a single point integral and HF-SCF calculation in order to determine the number and ordering of the irreducible representations. The occupation keyword may be omitted, in which case an initial orbital occupancy is determined by diagonalization of the core Hamiltonian. In many cases, HF-SCF calculations run with the core Hamiltonian guess will usually converge to the lowest energy HF-SCF solution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). <strong>Psi4 Interface:</strong> The arrays above are specified in PSI as (white space tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]].</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cfour-omp-num-threads-cfour">CFOUR_OMP_NUM_THREADS (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> <strong>(Expert)</strong> — Sets the OMP_NUM_THREADS environment variable before calling CFOUR. If the environment variable <span class="target" id="index-0"></span><a class="reference internal" href="external.html#envvar-OMP_NUM_THREADS"><code class="xref std std-envvar docutils literal"><span class="pre">OMP_NUM_THREADS</span></code></a> is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the <code class="docutils literal"><span class="pre">-n</span></code> command-line option described in section <a class="reference internal" href="external.html#sec-threading"><span class="std std-ref">Threading</span></a> does not affect CFOUR.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-cfour-open-shell-cfour">CFOUR_OPEN-SHELL (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies which kind of open-shell CC treatment is employed. The default is a spin-orbital CC treatment (SPIN-ORBITAL =1) which is the only possible choice for UHF-CC schemes anyways. For ROHF-CC treatments, the possible options are beside the standard spin-orbital scheme a spin-restricted CC approach (SR-CC=3), as well as a corresponding linear approximation (which in the literature usually is referred to as partially-spin-adapted CC scheme) (PSA-CC=1). SR-CC and PSA-CC are within the CCSD approximation restricted to excitations defined by the first-order interacting space arguments. With the keywords PSA-CC_FULL (=2) or SR-CC_FULL (=6) inclusion of the so called &#8220;pseudo-triples&#8221; beyond the first-order interacting space is also possible. The two-determinant CC method for open-shell singlet states can be activated by TD-CC (=8).</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: SPIN-ORBITAL, SR-CC, PSA-CC_FULL, SR-CC_FULL, TD-CC</li>
<li><strong>Default</strong>: SPIN-ORBITAL</li>
</ul>
</dd>
<dt id="term-cfour-opt-maxcyc-cfour">CFOUR_OPT_MAXCYC (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Identical to <a class="reference internal" href="#term-cfour-geo-maxcyc-cfour"><span class="xref std std-term">CFOUR_GEO_MAXCYC</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 50</li>
</ul>
</dd>
<dt id="term-cfour-orbitals-cfour">CFOUR_ORBITALS (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the type of molecular orbitals used in post-HF calculations. STANDARD (=0) requests usage of the orbitals (from a corresponding HF-SCF calculation) without any modification. These are in the case of RHF/UHF the usual canonical HF orbitals and in the case of ROHF calculations the standard ROHF-orbitals with equal spatial parts for both the <span class="math">\(\alpha\)</span> and the <span class="math">\(\beta\)</span> spin orbitals. SEMICANONICAL (=1) forces in ROHF type calculations a transformation to so-called semicanonical orbitals which diagonalize the occupied-occupied and virtual-virtual blocks of the usual Fock-matrices. The use of semicanonical orbitals is, for example, required for ROHF-CCSD(T) calculations and for those calculations also automatically set. LOCAL requests a localization of the HF orbitals and this is currently done according to the Pipek-Mezey localization criterion. Note that it is strongly recommended not to use this keyword unless you know what are you doing. Default: STANDARD except for ROHF-CCSD(T) and ROHF-MP4 calculations for which SEMICANONICAL is the default.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: STANDARD, SEMICANONICAL</li>
<li><strong>Default</strong>: STANDARD</li>
</ul>
</dd>
<dt id="term-cfour-pert-orb-cfour">CFOUR_PERT_ORB (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the type of perturbed orbitals used in energy derivative calculations. STANDARD means that the gradient formulation assumes that the perturbed orbitals are not those in which the (perturbed) Fock matrix is diagonal. CANONICAL means that the perturbed orbitals are assumed to be canonical. This keyword is set automatically to CANONICAL in derivative calculations with methods which include triple excitations (MBPT[4]/MP4, CCSD+T[CCSD], CCSD[T], QCISD[T] and all iterative schemes like CCSDT-n and CC3) apart from CCSDT. IJ_CANONICAL requests a canonical perturbed-orbital treatment only for the occupied-occupied block of the unperturbed density matrix in analytic derivative calculations. For testing purposes, it is possible to force the use standard perturbed orbitals even in case of iterative triple excitations via the option FORCE_STANDA (dne?). Note also that in case of unrelaxed derivatives standard orbitals must be used. Default : STANDARD for all methods without triples (except CCSDT), CANONICAL for all methods with triples in case of relaxed derivatives.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: STANDARD, CANONICAL, IJ_CANONICAL</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cfour-points-cfour">CFOUR_POINTS (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies either single (=1, or SINGLE) or double (=2, DOUBLE) sided numerical differentiation in the finite difference evaluation of the Hessian. Two-sided numerical differentiation is considerably more accurate than the single-sided method, and its use is strongly recommended for production work.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: SINGLE, DOUBLE</li>
<li><strong>Default</strong>: DOUBLE</li>
</ul>
</dd>
<dt id="term-cfour-print-cfour">CFOUR_PRINT (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Controls the amount of printing in the energy and energy derivative calculation programs. Using a value of 1 will produce a modest amount of additional output over the default value of 0, which includes some useful information such as SCF eigenvectors, Fock matrix elements, etc.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-cfour-prop-integral-cfour">CFOUR_PROP_INTEGRAL (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Allows storage of property integrals computed in <code class="docutils literal"><span class="pre">xvdint</span></code> on internal files (e.g., <code class="docutils literal"><span class="pre">MOINTS</span></code> and <code class="docutils literal"><span class="pre">GAMLAM</span></code>, default choice INTERNAL, =0) or on external files (EXTERNAL, =1).</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: INTERNAL, EXTERNAL</li>
<li><strong>Default</strong>: INTERNAL</li>
</ul>
</dd>
<dt id="term-cfour-props-cfour">CFOUR_PROPS (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether and which molecular property is calculated. OFF (=0) means that no property is calculated, FIRST_ORDER (=1) requests computation of various one-electron first-order properties (e.g., dipole moment, quadrupole moment, electric field gradient, spin densities,etc.), SECOND_ORDER (=2, in the next release replaced by STAT_POL) computes static electric polarizabilities, DYNAMICAL (=7, in the next release replaced by DYN_POL) requests the calculation of frequency-dependent polarizabilities (note that here an additional input of the frequency is required), NMR (=5) requests the calculation of NMR chemical shifts/chemical shielding tensors (by default using GIAOs), J_FC requests the calculation of the Fermi-Contact contribution to indirect spin-spin coupling constants, J_SD the calculation of the corresponding spin-dipole contribution, and J_SO the calculation of the corresponding spin-orbit contribution to J; HYPERPOL (=22) invokes a calculation of static hyperpolarizabilities, DYN_HYP (=23) requests the calculation of frequency-dependent hyperpolarizabilities, SHG (=24) the calculation of hyperpolarizabilities related to the second-harmonic generation, OPT_REC (=25) the computation of hyperpolarizabilities related to optical rectification, VERDET (=26) the calculation of Verdet constants.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: OFF, FIRST_ORDER, SECOND_ORDER, NMR, HYPERPOL, DYN_HYP, SHG, OPT_REC, VERDET</li>
<li><strong>Default</strong>: OFF</li>
</ul>
</dd>
<dt id="term-cfour-qrhf-general-cfour">CFOUR_QRHF_GENERAL (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — The presence of this keyword specifies that a QRHF based CC calculation, or alternatively, an SCF calculation that uses the <a class="reference internal" href="#term-cfour-qrhfgues-cfour"><span class="xref std std-term">CFOUR_QRHFGUES</span></a> option, is to be performed.</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cfour-qrhf-orbital-cfour">CFOUR_QRHF_ORBITAL (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — By default, in QRHF calculations, electrons are removed from the highest occupied orbital in a symmetry block (symmetry block HOMO), while electrons are added to the lowest unoccupied orbital within a symmetry block (symmetry block LUMO). The purpose of the QRHF_ORBITAL keyword is to allow additional flexibility in choosing which orbitals will have their occupation numbers altered. The value of this keyword gives the offset with respect to the default orbital for the orbital which will be depopulated (or populated) in QRHF-CC calculations. For calculations involving more than one removal or addition of electrons, values are separated by commas and correspond to the <a class="reference internal" href="#term-cfour-qrhf-general-cfour"><span class="xref std std-term">CFOUR_QRHF_GENERAL</span></a> input on a one-to-one basis. For example, specifying <a class="reference internal" href="#term-cfour-qrhf-general-cfour"><span class="xref std std-term">CFOUR_QRHF_GENERAL</span></a> =2/-4, QRHF_ORBITAL=3/2 means that an electron will be added to the third lowest virtual in symmetry block 2 and another will be removed from the second highest occupied orbital in symmetry block 4. Examples given later in this manual further illustrate the QRHF input options and may help to clarify any confusion resulting from this documentation. (Default : 1)</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cfour-qrhfgues-cfour">CFOUR_QRHFGUES (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — If this keyword is set to ON (=1), then the QRHF orbitals specified by the <a class="reference internal" href="#term-cfour-qrhf-general-cfour"><span class="xref std std-term">CFOUR_QRHF_GENERAL</span></a>, <a class="reference internal" href="#term-cfour-qrhf-orbital-cfour"><span class="xref std std-term">CFOUR_QRHF_ORBITAL</span></a> and CFOUR_QRHF_SPIN (nyi?) keywords are used as a starting guess for a restarted SCF procedure. This can be an extremely useful way to converge &#8220;difficult&#8221; SCF solutions, such as those that correspond to states that are not the lowest states of a given symmetry. Note that when this option is used, the calculation that is performed is not a QRHF-CC calculation; it is instead a UHF-based or ROHF-based calculation, depending on what type of reference is specified by the <a class="reference internal" href="#term-cfour-reference-cfour"><span class="xref std std-term">CFOUR_REFERENCE</span></a> keyword. The QRHF aspect of the calculation is used simply as a device to converge the orbitals.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cfour-raman-int-cfour">CFOUR_RAMAN_INT (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — ON (=1) requests a calculation of Raman intensities based on the geometrical derivatives of the static polarizability tensor, while DYN (=2) requests a calculation of Raman intensities based on the derivatives of the dynamical polarizability tensor.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: ON, DYN, OFF</li>
<li><strong>Default</strong>: OFF</li>
</ul>
</dd>
<dt id="term-cfour-raman-orb-cfour">CFOUR_RAMAN_ORB (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether Raman intensities are calculated with orbital relaxation with respect to the electric field perturbation (RELAXED, = 1) or without orbital relaxation (UNRELAXED, = 0).</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: RELAXED, UNRELAXED</li>
<li><strong>Default</strong>: UNRELAXED</li>
</ul>
</dd>
<dt id="term-cfour-rdo-cfour">CFOUR_RDO (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether or not relaxed density natural orbitals are to be computed. This option only has meaning for a correlated calculation. For =0, Do not compute. For =1, compute.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-cfour-reference-cfour">CFOUR_REFERENCE (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the type of SCF calculation to be performed. RHF (= 0) requests a restricted Hartree-Fock reference; UHF (= 1) an unrestricted Hartree-Fock reference; ROHF (= 2) a restricted open-shell Hartree-Fock calculation; TCSCF (=3) a two-configurational SCF calculation, and CASSCF (=4) a complete-active space SCF calculations (currently not implemented). <strong>Psi4 Interface:</strong> Keyword subject to translation from value of <a class="reference internal" href="#term-reference-scf"><span class="xref std std-term">REFERENCE</span></a> unless set explicitly.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: RHF, UHF, ROHF, TCSCF, CASSCF</li>
<li><strong>Default</strong>: RHF</li>
</ul>
</dd>
<dt id="term-cfour-relativistic-cfour">CFOUR_RELATIVISTIC (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the treatment of relativistic effects. The default is a non-relativistic treatment (OFF), while perturbational treatments are invoked via MVD1 (mass-velocity and 1-electron Darwin contribution), MVD2 (mass-velocity and 1- and 2-electron Darwin contribution), DPT2 (second-order direct perturbation theory approach), SF-DPT4 (scalar-relativistic part of fourth-order direct perturbation theory, DPT4 (full fourth-order DPT including spin-orbit corrections), SF-DPT6 (scalar-relativistic part of sixth-order direct perturbation theory), SFREE (spin-free treatment), X2C1E (spin-free X2C-1e treatment), or DPT (synonym with DPT2).</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: OFF, MVD1, MVd2, DPT2, SF-DPT4, DPT4, SF-DPT6, SFREE, X2C1E, DPT</li>
<li><strong>Default</strong>: OFF</li>
</ul>
</dd>
<dt id="term-cfour-relax-dens-cfour">CFOUR_RELAX_DENS (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether the relaxed density matrix is computed for correlated wave functions. OFF (= 0) The relaxed density will not be computed, ON (= 1) it will be computed.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cfour-res-raman-cfour">CFOUR_RES_RAMAN (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — This option can be used to convert an analytically calculated gradient vector to a particular normal coordinate representation. A useful application is to calculate the gradient of an electronically excited state in the normal coordinate representation of the ground electronic state, as this provides a first approximation to resonance Raman intensities (hence the name of the keyword). Calculations that use the this option require the externally supplied force constant matrix <code class="docutils literal"><span class="pre">FCMFINAL</span></code>, which is written to disk during the course of both analytic and finite-difference vibrational frequency calculations. No such transformation is performed if OFF (=0); while ON (=1) directs the program to evaluate the gradient and transform it to the chosen set of normal coordinates. A warning message is printed if the force constant matrix is unavailable.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cfour-restart-cc-cfour">CFOUR_RESTART_CC (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Offers the possibility to restart a CC calculation which stopped for various reasons, e.g. time limit, in the correlation part. However, note that a restart which is specified by ON (= 1) needs the following files of the previous unfinished calculation: <code class="docutils literal"><span class="pre">JOBARC</span></code>, <code class="docutils literal"><span class="pre">JAINDX</span></code>, <code class="docutils literal"><span class="pre">MOINTS</span></code>, and <code class="docutils literal"><span class="pre">MOABCD</span></code>.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cfour-rot-evec-cfour">CFOUR_ROT_EVEC (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies which eigenvector of the orbital rotation Hessian is to be used to rotate the original SCF orbitals. By default, it will use that associated with the lowest eigenvalue of the totally symmetric part of the block-factored Hessian, as this choice often leads to the lowest energy SCF solution. For RHF stability checks, only those instabilities which correspond to RHF solutions will be considered. It is important to understand that following non-symmetric eigenvectors lowers the symmetry of the wavefunction and that following RHF &#8211;&gt; UHF stabilities leads to a UHF solution. To converge the SCF roots associated with such instabilities, one must run the calculation in reduced symmetry and as a closed-shell UHF case, respectively. Value <em>n</em> directs the program to follow the vector associated with the <em>n</em>th lowest eigenvalue having the proper symmetry (totally symmetric) and spin (RHF&#8211;&gt;RHF or UHF&#8211;&gt;UHF) properties. 0 means use the lowest eigenvalue.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-cfour-save-ints-cfour">CFOUR_SAVE_INTS (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Tells CFOUR whether to delete large files (AO integrals and <code class="docutils literal"><span class="pre">MOINTS</span></code> file for now) when they are no longer needed. OFF (=0) They will not be saved, ON (=1) they will be saved.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cfour-scale-on-cfour">CFOUR_SCALE_ON (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Controls whether step scaling is based on the absolute step length (1-norm) (=0 or MAG(S)) or the largest individual step in the internal coordinate space (=1 or MAX(S)).</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: MAG(S), MAX(S)</li>
<li><strong>Default</strong>: MAG(S)</li>
</ul>
</dd>
<dt id="term-cfour-scf-conv-cfour">CFOUR_SCF_CONV (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the convergence criterion for the HF-SCF equations. Equations are considered converged when the maximum change in density matrix elements is less than <span class="math">\(10^{-N}\)</span>. <strong>Psi4 Interface:</strong> Keyword subject to translation from value of <a class="reference internal" href="#term-d-convergence-scf"><span class="xref std std-term">D_CONVERGENCE</span></a> unless set explicitly.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 7</li>
</ul>
</dd>
<dt id="term-cfour-scf-damping-cfour">CFOUR_SCF_DAMPING (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Controls the damping (in the first iterations (specified by <a class="reference internal" href="#term-cfour-scf-expstart-cfour"><span class="xref std std-term">CFOUR_SCF_EXPSTART</span></a> via <span class="math">\(D_{new} = D_{old} + X/1000 * (D_{new} - D_{old})\)</span> with <span class="math">\(X\)</span> as the value specified by the keyword. The default value is currently 1000 (no damping), but a value of 500 is recommended in particular for transition metal compounds where the SCF convergence is often troublesome. <strong>Psi4 Interface:</strong> Keyword subject to translation from value of <a class="reference internal" href="#term-damping-percentage-scf"><span class="xref std std-term">DAMPING_PERCENTAGE</span></a> unless set explicitly.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1000</li>
</ul>
</dd>
<dt id="term-cfour-scf-exporder-cfour">CFOUR_SCF_EXPORDER (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the number of density matrices to be used in the DIIS convergence acceleration procedure.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 6</li>
</ul>
</dd>
<dt id="term-cfour-scf-expstart-cfour">CFOUR_SCF_EXPSTART (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the first iteration in which the DIIS convergence acceleration procedure is applied.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 8</li>
</ul>
</dd>
<dt id="term-cfour-scf-extrapolation-cfour">CFOUR_SCF_EXTRAPOLATION (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether or not the DIIS extrapolation is used to accelerate convergence of the SCF procedure. OFF (=0) means do not use DIIS, ON (=1) means use DIIS.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-cfour-scf-maxcyc-cfour">CFOUR_SCF_MAXCYC (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the maximum number of SCF iterations. <strong>Psi4 Interface:</strong> Keyword subject to translation from value of <a class="reference internal" href="#term-maxiter-scf"><span class="xref std std-term">MAXITER</span></a> unless set explicitly.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 150</li>
</ul>
</dd>
<dt id="term-cfour-sd-field-cfour">CFOUR_SD_FIELD (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the strength of a spin-dipole perturbation as required for finite-field calculations of the SD contributions to indirect spin-spin coupling constants. The value must be specified as an integer and the SD strength used by the program will be the value of the keyword <span class="math">\(\times 10^{-6}\)</span>. (Default : 0, currently not implemented)</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-cfour-spherical-cfour">CFOUR_SPHERICAL (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether spherical harmonic (5d, 7f, 9g, etc.) or Cartesian (6d, 10f, 15g, etc.) basis functions are to be used. ON (= 1) uses spherical harmonics, OFF (= 0) uses Cartesians. <strong>Psi4 Interface:</strong> Keyword set according to basis design when <a class="reference internal" href="#term-basis-mints"><span class="xref std std-term">BASIS</span></a> is used instead of <a class="reference internal" href="#term-cfour-basis-cfour"><span class="xref std std-term">CFOUR_BASIS</span></a>. Keyword subject to translation from value of <a class="reference internal" href="#term-puream-globals"><span class="xref std std-term">PUREAM</span></a> unless set explicitly.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-cfour-spin-flip-cfour">CFOUR_SPIN_FLIP (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Controls whether excitation energy calculations allow for a &#8220;spin flip&#8221; which changes the <span class="math">\(M_s\)</span> quantum number. Such calculations have some advantages for biradicals and are currently implemented (together with gradients) for CIS and CIS(D) calculations. Options are OFF and ON.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cfour-spin-orbit-cfour">CFOUR_SPIN_ORBIT (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Experimental Use! ON (=1) requests calculation of one-electron spin-orbit integrals. MEANSO additionally gives a mean-field treatment of the two-electron terms (spin-orbit mean field treatment as described Mol. Phys. 98, 1823-1833 (2000)).</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: ON, MEANSO, OFF</li>
<li><strong>Default</strong>: OFF</li>
</ul>
</dd>
<dt id="term-cfour-spin-scal-cfour">CFOUR_SPIN_SCAL (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — ON (=1) requests the spin-component scaled variant of the MP2 approach. This keyword has only an effect when <a class="reference internal" href="#term-cfour-calc-level-cfour"><span class="xref std std-term">CFOUR_CALC_LEVEL</span></a> =MP2 is specified and must be used together with <a class="reference internal" href="#term-cfour-reference-cfour"><span class="xref std std-term">CFOUR_REFERENCE</span></a> =UHF.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cfour-spinrotation-cfour">CFOUR_SPINROTATION (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether nuclear spin-rotation tensors are computed within a NMR chemical shift calculation (ON, =1) or not (OFF, =9). In the case of electronic g-tensor calculations for open-shell molecules this keyword controls the calculation of the electronic spin-rotation tensor.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cfour-subgroup-cfour">CFOUR_SUBGROUP (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies an Abelian subgroup to be used in a calculation. Acceptable arguments are DEFAULT (=0); C1 (= 1); C2 (= 2); CS (= 3); CI (= 4); C2V (= 5); C2H (= 6); D2 (= 7) and D2H (= 8). Use of C1 is of course equivalent to setting <a class="reference internal" href="#term-cfour-symmetry-cfour"><span class="xref std std-term">CFOUR_SYMMETRY</span></a> =OFF in the input. The DEFAULT option (which is the default) uses the highest order Abelian subgroup.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: DEFAULT, C1, C2, CS, CI, C2V, C2H, D2, D2H, OFF</li>
<li><strong>Default</strong>: DEFAULT</li>
</ul>
</dd>
<dt id="term-cfour-sym-check-cfour">CFOUR_SYM_CHECK (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — In principle can be used to force the SCF to converge a solution for which the density matrix transforms as the totally symmetric representation of the point group (i.e. no broken symmetry solutions). The code seems to work in most cases, but has currently been implemented for point groups with E type representation and not for those with triply-, quadruply- or pentuply-degenerate representations. Extending the code to those cases is probably straightforward, and the reader is encouraged to do so if (s)he is so inclined. SYM_CHECK=0 &#8220;forces&#8221; the high-symmetry solution. SYM_CHECK=OVERRIDE (=1) doesn&#8217;t. The latter is the default.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-cfour-symmetry-cfour">CFOUR_SYMMETRY (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies what subgroup of the full point group is to be used in the energy and/or gradient calculation (the computational point group). OFF (=1) forces a no symmetry run (in <span class="math">\(C_1\)</span> ) and ON (=0) runs the calculation in the largest self-adjoint subgroup ( <span class="math">\(D_{2h}\)</span> and its subgroups).</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-cfour-t3-extrapol-cfour">CFOUR_T3_EXTRAPOL (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether the T3 amplitudes are included ON (=1) or not included OFF (=0) in the DIIS convergence acceleration during CCSDT calculations. Inclusion of T3 speeds up convergence and allows tight convergence, but on the other hand it increases disk space requirements. Note that this keyword is only available with module <code class="docutils literal"><span class="pre">xecc</span></code>.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cfour-tamp-sum-cfour">CFOUR_TAMP_SUM (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies how often the largest <span class="math">\(t\)</span> amplitudes are to be printed. For =0, amplitudes are printed at the beginning and end of the run. For =1, amplitudes are printed every iteration. For =2, amplitudes are printed every other iteration, etc.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 5</li>
</ul>
</dd>
<dt id="term-cfour-thermochemistry-cfour">CFOUR_THERMOCHEMISTRY (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether to calculate finite-temperature thermodynamic corrections after a frequency calculation. OFF (=0) skips this; ON (=1) gives abbreviated output; and VERBOSE (=2) gives elaborate output that is separated by translation, rotation and vibration. Default: ON (currently not available in public version)</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: OFF, ON, VERBOSE</li>
<li><strong>Default</strong>: ON</li>
</ul>
</dd>
<dt id="term-cfour-trans-inv-cfour">CFOUR_TRANS_INV (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether or not translational invariance is exploited in geometrical derivative calculations. USE(=0) specifies that translational invariance is exploited, while IGNORE (=1) turns it off.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: USE, IGNORE</li>
<li><strong>Default</strong>: USE</li>
</ul>
</dd>
<dt id="term-cfour-treat-pert-cfour">CFOUR_TREAT_PERT (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether in a correlated NMR chemical shift calculations all perturbations are treated at once or sequentially. Available option are SIMULTANEOUS (=0) and SEQUENTIAL (=1). The latter is at least preferred for large-scale calculations, as it has less demands on the available disk space.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: SIMULTANEOUS, SEQUENTIAL</li>
<li><strong>Default</strong>: SIMULTANEOUS</li>
</ul>
</dd>
<dt id="term-cfour-uij-threshold-cfour">CFOUR_UIJ_THRESHOLD (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the threshold value (given as an integer) for the treatment of CPHF coefficients in second derivative calculations using perturbed canonical orbitals. If a CPHF coefficient is above the threshold, the corresponding orbital rotation is treated (at the expense of additional CPU cost) using the standard non-canonical procedures, while orbital pairs corresponding to CPHF coefficients below the threshold are treated using perturbed canonical representation. Default: 25 (Default: 1 in the developer version)</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 25</li>
</ul>
</dd>
<dt id="term-cfour-units-cfour">CFOUR_UNITS (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the units used for molecular geometry input. ANGSTROM (= 0) uses Angstrom units, BOHR (= 1) specifies atomic units. <strong>Psi4 Interface:</strong> Keyword set from active molecule, always ANGSTROM.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: ANGSTROM, BOHR</li>
<li><strong>Default</strong>: ANGSTROM</li>
</ul>
</dd>
<dt id="term-cfour-update-hessian-cfour">CFOUR_UPDATE_HESSIAN (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether or not the Hessian update is carried out. OFF (= 0) uses the initial Hessian (however supplied, either the default guess or a <code class="docutils literal"><span class="pre">FCMINT</span></code> file), ON (= 1) updates it during subsequent optimization cycles. (not in current public version).</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-cfour-vibration-cfour">CFOUR_VIBRATION (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies whether (harmonic) vibrational frequencies are calculated or not. If the default NO (=0) is specified then no frequencies are calculated. For ANALYTIC, vibrational frequencies are determined from analytically computed second derivatives, and for FINDIF (=2) vibrational frequencies are calculated from a force field obtained by numerical differentiation of analytically evaluated gradients (or even single-point energies) using symmetry-adapted mass-weighted Cartesian coordinates. If vibrational frequencies are calculated, a normal mode analysis using the computed force-constant matrix is performed, rotationally projected frequencies are computed, infrared intensities are determined, and zero-point energies (ZPE) are evaluated.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NO, ANALYTIC, FINDIF</li>
<li><strong>Default</strong>: NO</li>
</ul>
</dd>
<dt id="term-cfour-vtran-cfour">CFOUR_VTRAN (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — This keyword defines what type of integral transformation is to be performed in the program <code class="docutils literal"><span class="pre">xvtran</span></code>. FULL/PARTIAL (=0) allows the transformation program to choose the appropriate type of transformation, while FULL (=1) requires a full integral transformation and PARTIAL (=2) means a MBPT(2)-specific transformation where the <span class="math">\((ab \vert cd)\)</span> integrals are not formed.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: FULL/PARTIAL, FULL, PARTIAL</li>
<li><strong>Default</strong>: FULL/PARTIAL</li>
</ul>
</dd>
<dt id="term-cfour-xfield-cfour">CFOUR_XFIELD (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the X-component of an external electric field. The value must be specified as an integer and the field used by the program will be the value of the keyword <span class="math">\(\times 10^{-6}\)</span>. This allows field strengths <span class="math">\(|\varepsilon| &gt; 10^{-6}\)</span> to be used.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-cfour-xform-tol-cfour">CFOUR_XFORM_TOL (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — The tolerance for storing transformed integrals. Integrals less than <span class="math">\(10^{-N}\)</span> are neglected and not stored on disk.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 11</li>
</ul>
</dd>
<dt id="term-cfour-yfield-cfour">CFOUR_YFIELD (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the Y-component of an external electric field. The value must be specified as an integer and the field used by the program will be the value of the keyword <span class="math">\(\times 10^{-6}\)</span>. This allows field strengths <span class="math">\(|\varepsilon| &gt; 10^{-6}\)</span> to be used.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-cfour-zfield-cfour">CFOUR_ZFIELD (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Specifies the Z-component of an external electric field. The value must be specified as an integer and the field used by the program will be the value of the keyword <span class="math">\(\times 10^{-6}\)</span>. This allows field strengths <span class="math">\(|\varepsilon| &gt; 10^{-6}\)</span> to be used.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-cholesky-dfocc">CHOLESKY (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Do Cholesky decomposition of the ERI tensor</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cholesky-tolerance-dfocc">CHOLESKY_TOLERANCE (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — tolerance for Cholesky decomposition of the ERI tensor</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1.0e-4</li>
</ul>
</dd>
<dt id="term-cholesky-tolerance-fnocc">CHOLESKY_TOLERANCE (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> — tolerance for Cholesky decomposition of the ERI tensor</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1.0e-4</li>
</ul>
</dd>
<dt id="term-cholesky-tolerance-scf">CHOLESKY_TOLERANCE (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Tolerance for Cholesky decomposition of the ERI tensor</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-4</li>
</ul>
</dd>
<dt id="term-ci-diis-mcscf">CI_DIIS (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> — Do use DIIS extrapolation to accelerate convergence of the CI coefficients?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-ci-file-start-detci">CI_FILE_START (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — What file do we start at for hd/c/s/d CIvects? Should be 50 for normal CI calculations and 54 if we are going to do a second monomer.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 50</li>
</ul>
</dd>
<dt id="term-ci-maxiter-detci">CI_MAXITER (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Maximum number of iterations to diagonalize the Hamiltonian</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 24</li>
</ul>
</dd>
<dt id="term-ci-num-threads-detci">CI_NUM_THREADS (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Number of threads for DETCI.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-ci-type-globals">CI_TYPE (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — Algorithm to use for CI computation (e.g., CID or CISD). See <a class="reference internal" href="notes_c.html#table-managedmethods"><span class="std std-ref">Cross-module Redundancies</span></a> for details.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: CONV</li>
<li><strong>Default</strong>: CONV</li>
</ul>
</dd>
<dt id="term-ciblks-print-detci">CIBLKS_PRINT (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Do print a summary of the CI blocks?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-cis-ad-states-cphf">CIS_AD_STATES (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Which states to save AD Matrices for? * Positive - Singlets * Negative - Triplets *</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cis-amplitude-cutoff-cphf">CIS_AMPLITUDE_CUTOFF (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Minimum singles amplitude to print in CIS analysis</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.15</li>
</ul>
</dd>
<dt id="term-cis-dopdm-states-cphf">CIS_DOPDM_STATES (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Which states to save AO difference OPDMs for? * Positive - Singlets * Negative - Triplets *</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cis-mem-safety-factor-cphf">CIS_MEM_SAFETY_FACTOR (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Memory safety factor for allocating JK</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.75</li>
</ul>
</dd>
<dt id="term-cis-no-states-cphf">CIS_NO_STATES (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Which states to save AO Natural Orbitals for? * Positive - Singlets * Negative - Triplets *</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cis-opdm-states-cphf">CIS_OPDM_STATES (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Which states to save AO OPDMs for? * Positive - Singlets * Negative - Triplets *</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cis-topdm-states-cphf">CIS_TOPDM_STATES (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Which states to save AO transition OPDMs for? * Positive - Singlets * Negative - Triplets *</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-collapse-size-detci">COLLAPSE_SIZE (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Gives the number of vectors to retain when the Davidson subspace is collapsed (see <a class="reference internal" href="#term-max-num-vecs-detci"><span class="xref std std-term">MAX_NUM_VECS</span></a>). If greater than one, the collapsed subspace retains the best estimate of the CI vector for the previous n iterations. Defaults to 1.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-collapse-with-last-cceom">COLLAPSE_WITH_LAST (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Do collapse with last vector?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-complex-tolerance-cceom">COMPLEX_TOLERANCE (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Complex tolerance applied in CCEOM computations</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-12</li>
</ul>
</dd>
<dt id="term-comput-s2-dfocc">COMPUT_S2 (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Do compute <span class="math">\(\langle \hat{S}^2 \rangle\)</span> for DF-OMP2/DF-MP2?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-compute-mp4-triples-fnocc">COMPUTE_MP4_TRIPLES (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> <strong>(Expert)</strong> — Do compute MP4 triples contribution?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-compute-triples-fnocc">COMPUTE_TRIPLES (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> <strong>(Expert)</strong> — Do compute triples contribution?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-consecutive-backsteps-optking">CONSECUTIVE_BACKSTEPS (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Set number of consecutive backward steps allowed in optimization</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-corr-ansatz-psimrcc">CORR_ANSATZ (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — The ansatz to use for MRCC computations</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: SR, MK, BW, APBW</li>
<li><strong>Default</strong>: MK</li>
</ul>
</dd>
<dt id="term-corr-ccsd-t-psimrcc">CORR_CCSD_T (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — The type of CCSD(T) computation to perform</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: STANDARD, PITTNER</li>
<li><strong>Default</strong>: STANDARD</li>
</ul>
</dd>
<dt id="term-corr-charge-psimrcc">CORR_CHARGE (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — The molecular charge of the target state</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-corr-multp-psimrcc">CORR_MULTP (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — The multiplicity, <span class="math">\(M_S(M_S+1)\)</span>, of the target state. Must be specified if different from the reference <span class="math">\(M_s\)</span>.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-corr-wfn-psimrcc">CORR_WFN (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — The type of correlated wavefunction</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: PT2, CCSD, MP2-CCSD, CCSD_T</li>
<li><strong>Default</strong>: CCSD</li>
</ul>
</dd>
<dt id="term-coupled-induction-sapt">COUPLED_INDUCTION (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> <strong>(Expert)</strong> — Whether or not to compute coupled induction, applies only to the open-shell SAPT0 code. Coupled induction is not available for ROHF, and the option is automatically false in this case. Note that when coupled induction is turned off, the Psi variables SAPT IND20,R ENERGY and SAPT EXCH-IND20,R ENERGY actually contain the <strong>uncoupled</strong> induction! A corresponding warning is issued in the output file.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-coupling-psimrcc">COUPLING (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — The order of coupling terms to include in MRCCSDT computations</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NONE, LINEAR, QUADRATIC, CUBIC</li>
<li><strong>Default</strong>: CUBIC</li>
</ul>
</dd>
<dt id="term-coupling-terms-psimrcc">COUPLING_TERMS (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — Do include the terms that couple the reference determinants?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-covalent-connect-optking">COVALENT_CONNECT (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — When determining connectivity, a bond is assigned if interatomic distance is less than (this number) * sum of covalent radii.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.3</li>
</ul>
</dd>
<dt id="term-cphf-mem-safety-factor-cphf">CPHF_MEM_SAFETY_FACTOR (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Memory safety factor for allocating JK</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.75</li>
</ul>
</dd>
<dt id="term-cphf-tasks-cphf">CPHF_TASKS (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Which tasks to run CPHF For * Valid choices: * -Polarizability *</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cubeprop-basis-functions-globals">CUBEPROP_BASIS_FUNCTIONS (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — List of basis function indices for which cube files are generated (1-based). All basis functions computed if empty.</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cubeprop-filepath-globals">CUBEPROP_FILEPATH (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — Directory to which to write cube files. Default is the input file directory.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cubeprop-orbitals-globals">CUBEPROP_ORBITALS (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — List of orbital indices for which cube files are generated (1-based, <span class="math">\(+\)</span> for alpha, <span class="math">\(-\)</span> for beta). All orbitals computed if empty.</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cubeprop-tasks-globals">CUBEPROP_TASKS (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — Properties to compute. Valid tasks include: <code class="docutils literal"><span class="pre">DENSITY</span></code> - Da, Db, Dt, Ds <code class="docutils literal"><span class="pre">ESP</span></code> - Dt, ESP <code class="docutils literal"><span class="pre">ORBITALS</span></code> - Psi_a_N, Psi_b_N <code class="docutils literal"><span class="pre">BASIS_FUNCTIONS</span></code> - Phi_N <code class="docutils literal"><span class="pre">LOL</span></code> - LOLa, LOLb <code class="docutils literal"><span class="pre">ELF</span></code> - ELFa, ELFb</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cubic-basis-tolerance-fisapt">CUBIC_BASIS_TOLERANCE (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> <strong>(Expert)</strong> — CubicScalarGrid basis cutoff.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1.0e-12</li>
</ul>
</dd>
<dt id="term-cubic-basis-tolerance-globals">CUBIC_BASIS_TOLERANCE (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> <strong>(Expert)</strong> — CubicScalarGrid basis cutoff.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1.0e-12</li>
</ul>
</dd>
<dt id="term-cubic-block-max-points-fisapt">CUBIC_BLOCK_MAX_POINTS (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> <strong>(Expert)</strong> — CubicScalarGrid maximum number of grid points per evaluation block.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1000</li>
</ul>
</dd>
<dt id="term-cubic-block-max-points-globals">CUBIC_BLOCK_MAX_POINTS (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> <strong>(Expert)</strong> — CubicScalarGrid maximum number of grid points per evaluation block.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1000</li>
</ul>
</dd>
<dt id="term-cubic-grid-overage-fisapt">CUBIC_GRID_OVERAGE (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — CubicScalarGrid spatial extent in bohr [O_X, O_Y, O_Z]. Defaults to 4.0 bohr each.</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cubic-grid-overage-globals">CUBIC_GRID_OVERAGE (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — CubicScalarGrid spatial extent in bohr [O_X, O_Y, O_Z]. Defaults to 4.0 bohr each.</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cubic-grid-spacing-fisapt">CUBIC_GRID_SPACING (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — CubicScalarGrid grid spacing in bohr [D_X, D_Y, D_Z]. Defaults to 0.2 bohr each.</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cubic-grid-spacing-globals">CUBIC_GRID_SPACING (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — CubicScalarGrid grid spacing in bohr [D_X, D_Y, D_Z]. Defaults to 0.2 bohr each.</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-cutoff-dfocc">CUTOFF (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Cutoff value for numerical procedures</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 8</li>
</ul>
</dd>
<dt id="term-cutoff-occ">CUTOFF (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Cutoff value for numerical procedures</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 14</li>
</ul>
</dd>
<dt id="term-d-convergence-fisapt">D_CONVERGENCE (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — Convergence criterion for residual of the CPHF coefficients in the SAPT <span class="math">\(E_{ind,resp}^{(20)}\)</span> term.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-8</li>
</ul>
</dd>
<dt id="term-d-convergence-mcscf">D_CONVERGENCE (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> — Convergence criterion for density.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-6</li>
</ul>
</dd>
<dt id="term-d-convergence-sapt">D_CONVERGENCE (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — Convergence criterion for residual of the CPHF coefficients in the SAPT <span class="math">\(E_{ind,resp}^{(20)}\)</span> term.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-8</li>
</ul>
</dd>
<dt id="term-d-convergence-scf">D_CONVERGENCE (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Convergence criterion for SCF density, which is defined as the RMS value of the orbital gradient. See Table <a class="reference internal" href="scf.html#table-conv-scf"><span class="std std-ref">SCF Convergence &amp; Algorithm</span></a> for default convergence criteria for different calculation types. <strong>Cfour Interface:</strong> Keyword translates into <a class="reference internal" href="#term-cfour-scf-conv-cfour"><span class="xref std std-term">CFOUR_SCF_CONV</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-6</li>
</ul>
</dd>
<dt id="term-damping-convergence-scf">DAMPING_CONVERGENCE (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — The density convergence threshold after which damping is no longer performed, if it is enabled. It is recommended to leave damping on until convergence, which is the default. <strong>Cfour Interface:</strong> Keyword translates into <a class="reference internal" href="#term-cfour-scf-damping-cfour"><span class="xref std std-term">CFOUR_SCF_DAMPING</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1.0e-18</li>
</ul>
</dd>
<dt id="term-damping-percentage-dcft">DAMPING_PERCENTAGE (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> <strong>(Expert)</strong> — The amount (percentage) of damping to apply to the orbital update procedure: 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration&#8217;s density being mixed into the current iteration) can help in cases where oscillatory convergence is observed.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-damping-percentage-psimrcc">DAMPING_PERCENTAGE (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — The amount (percentage) of damping to apply to the amplitude updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the amplitudes from the previous iteration being mixed into the current iteration) can help in cases where oscillatory convergence is observed.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-damping-percentage-scf">DAMPING_PERCENTAGE (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — The amount (percentage) of damping to apply to the early density updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration&#8217;s density being mixed into the current density) could help to solve problems with oscillatory convergence.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-dcft-functional-dcft">DCFT_FUNCTIONAL (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> — Chooses appropriate DCFT method</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: DC-06, DC-12, ODC-06, ODC-12, ODC-13, CEPA0</li>
<li><strong>Default</strong>: ODC-12</li>
</ul>
</dd>
<dt id="term-dcft-guess-dcft">DCFT_GUESS (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> <strong>(Expert)</strong> — Whether to read the orbitals from a previous computation, or to compute an MP2 guess</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: CC, BCC, MP2, DCFT</li>
<li><strong>Default</strong>: MP2</li>
</ul>
</dd>
<dt id="term-dcft-type-dcft">DCFT_TYPE (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> — What algorithm to use for the DCFT computation</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: CONV, DF</li>
<li><strong>Default</strong>: CONV</li>
</ul>
</dd>
<dt id="term-debug-cphf">DEBUG (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — The amount of debug information printed to the output file</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-debug-globals">DEBUG (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> <strong>(Expert)</strong> — The amount of information to print to the output file</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-delete-tei-cctransort">DELETE_TEI (CCTRANSORT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cctransort.html#apdx-cctransort"><span class="std std-ref">CCTRANSORT</span></a> — Delete the SO two-electron integrals after the transformation?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-denominator-algorithm-sapt">DENOMINATOR_ALGORITHM (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — Denominator algorithm for PT methods. Laplace transformations are slightly more efficient.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: LAPLACE, CHOLESKY</li>
<li><strong>Default</strong>: LAPLACE</li>
</ul>
</dd>
<dt id="term-denominator-delta-sapt">DENOMINATOR_DELTA (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the <span class="math">\(E_{disp}^{(20)}\)</span> and <span class="math">\(E_{exch-disp}^{(20)}\)</span> evaluation.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.0e-6</li>
</ul>
</dd>
<dt id="term-dertype-efp">DERTYPE (EFP)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__efp.html#apdx-efp"><span class="std std-ref">EFP</span></a> <strong>(Expert)</strong> — Do EFP gradient?</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NONE, FIRST</li>
<li><strong>Default</strong>: NONE</li>
</ul>
</dd>
<dt id="term-dertype-globals">DERTYPE (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> <strong>(Expert)</strong> — Derivative level</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NONE, FIRST, SECOND, RESPONSE</li>
<li><strong>Default</strong>: NONE</li>
</ul>
</dd>
<dt id="term-detci-freeze-core-detci">DETCI_FREEZE_CORE (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Do freeze core orbitals?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-df-basis-cc-fnocc">DF_BASIS_CC (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> — Auxilliary basis for df-ccsd(t).</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: <a class="reference internal" href="basissets_byelement.html#apdx-basiselement"><span class="std std-ref">basis string</span></a></li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-df-basis-cc-globals">DF_BASIS_CC (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — The density fitting basis to use in coupled cluster computations.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: <a class="reference internal" href="basissets_byelement.html#apdx-basiselement"><span class="std std-ref">basis string</span></a></li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-df-basis-dcft-dcft">DF_BASIS_DCFT (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> — Auxiliary basis set for DCFT density fitting computations. <a class="reference internal" href="basissets_byfamily.html#apdx-basisfamily"><span class="std std-ref">Defaults</span></a> to a RI basis.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: <a class="reference internal" href="basissets_byelement.html#apdx-basiselement"><span class="std std-ref">basis string</span></a></li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-df-basis-elst-sapt">DF_BASIS_ELST (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to <a class="reference internal" href="#term-df-basis-sapt-sapt"><span class="xref std std-term">DF_BASIS_SAPT</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: <a class="reference internal" href="basissets_byelement.html#apdx-basiselement"><span class="std std-ref">basis string</span></a></li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-df-basis-guess-scf">DF_BASIS_GUESS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — When <a class="reference internal" href="#term-basis-guess-scf"><span class="xref std std-term">BASIS_GUESS</span></a> is active, run the preliminary scf in density-fitted mode with this as fitting basis for the small basis set. A value of <code class="docutils literal"><span class="pre">TRUE</span></code> turns on density fitting with the default basis, otherwise the specified basis is used.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: <a class="reference internal" href="basissets_byelement.html#apdx-basiselement"><span class="std std-ref">basis string</span></a></li>
<li><strong>Default</strong>: FALSE</li>
</ul>
</dd>
<dt id="term-df-basis-mcscf-detci">DF_BASIS_MCSCF (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Auxiliary basis set for MCSCF density fitted ERI computations. This only effects the &#8220;Q&#8221; matrix in Helgaker&#8217;s language. <a class="reference internal" href="basissets_byfamily.html#apdx-basisfamily"><span class="std std-ref">Defaults</span></a> to a JKFIT basis.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: <a class="reference internal" href="basissets_byelement.html#apdx-basiselement"><span class="std std-ref">basis string</span></a></li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-df-basis-mp2-dfmp2">DF_BASIS_MP2 (DFMP2)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfmp2.html#apdx-dfmp2"><span class="std std-ref">DFMP2</span></a> — Auxiliary basis set for MP2 density fitting computations. <a class="reference internal" href="basissets_byfamily.html#apdx-basisfamily"><span class="std std-ref">Defaults</span></a> to a RI basis.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: <a class="reference internal" href="basissets_byelement.html#apdx-basiselement"><span class="std std-ref">basis string</span></a></li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-df-basis-sad-scf">DF_BASIS_SAD (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — Fitting SAD basis</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: <a class="reference internal" href="basissets_byelement.html#apdx-basiselement"><span class="std std-ref">basis string</span></a></li>
<li><strong>Default</strong>: SAD-FIT</li>
</ul>
</dd>
<dt id="term-df-basis-sapt-sapt">DF_BASIS_SAPT (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — Auxiliary basis set for SAPT density fitting computations. <a class="reference internal" href="basissets_byfamily.html#apdx-basisfamily"><span class="std std-ref">Defaults</span></a> to a RI basis.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: <a class="reference internal" href="basissets_byelement.html#apdx-basiselement"><span class="std std-ref">basis string</span></a></li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-df-basis-scf-cphf">DF_BASIS_SCF (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Auxiliary basis for SCF</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: <a class="reference internal" href="basissets_byelement.html#apdx-basiselement"><span class="std std-ref">basis string</span></a></li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-df-basis-scf-scf">DF_BASIS_SCF (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Auxiliary basis set for SCF density fitting computations. <a class="reference internal" href="basissets_byfamily.html#apdx-basisfamily"><span class="std std-ref">Defaults</span></a> to a JKFIT basis.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: <a class="reference internal" href="basissets_byelement.html#apdx-basiselement"><span class="std std-ref">basis string</span></a></li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-df-bump-r0-scf">DF_BUMP_R0 (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Bump function min radius</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-df-bump-r1-scf">DF_BUMP_R1 (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Bump function max radius</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-df-domains-scf">DF_DOMAINS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — FastDF geometric fitting domain selection algorithm</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: DIATOMIC, SPHERES</li>
<li><strong>Default</strong>: DIATOMIC</li>
</ul>
</dd>
<dt id="term-df-fitting-condition-scf">DF_FITTING_CONDITION (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — Fitting Condition</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.0e-12</li>
</ul>
</dd>
<dt id="term-df-ints-io-dfmp2">DF_INTS_IO (DFMP2)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfmp2.html#apdx-dfmp2"><span class="std std-ref">DFMP2</span></a> <strong>(Expert)</strong> — IO caching for CP corrections, etc</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NONE, SAVE, LOAD</li>
<li><strong>Default</strong>: NONE</li>
</ul>
</dd>
<dt id="term-df-ints-io-scf">DF_INTS_IO (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — IO caching for CP corrections, etc</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NONE, SAVE, LOAD</li>
<li><strong>Default</strong>: NONE</li>
</ul>
</dd>
<dt id="term-df-ints-num-threads-dfmp2">DF_INTS_NUM_THREADS (DFMP2)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfmp2.html#apdx-dfmp2"><span class="std std-ref">DFMP2</span></a> — Number of threads to compute integrals with. 0 is wild card</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-df-ints-num-threads-scf">DF_INTS_NUM_THREADS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Number of threads for integrals (may be turned down if memory is an issue). 0 is blank</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-df-metric-scf">DF_METRIC (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — FastDF Fitting Metric</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: COULOMB, EWALD, OVERLAP</li>
<li><strong>Default</strong>: COULOMB</li>
</ul>
</dd>
<dt id="term-df-scf-guess-scf">DF_SCF_GUESS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Use DF integrals tech to converge the SCF before switching to a conventional tech in a <a class="reference internal" href="#term-scf-type-scf"><span class="xref std std-term">SCF_TYPE</span></a> <code class="docutils literal"><span class="pre">DIRECT</span></code> calculation</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-df-theta-scf">DF_THETA (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — FastDF SR Ewald metric range separation parameter</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.0</li>
</ul>
</dd>
<dt id="term-dfcc-fnocc">DFCC (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> — Do use density fitting or cholesky decomposition in CC? This keyword is used internally by the driver. Changing its value will have no effect on the computation.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-dfmp2-mem-factor-dfmp2">DFMP2_MEM_FACTOR (DFMP2)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfmp2.html#apdx-dfmp2"><span class="std std-ref">DFMP2</span></a> — % of memory for DF-MP2 three-index buffers</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.9</li>
</ul>
</dd>
<dt id="term-dfmp2-p2-tolerance-dfmp2">DFMP2_P2_TOLERANCE (DFMP2)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfmp2.html#apdx-dfmp2"><span class="std std-ref">DFMP2</span></a> — Minimum error in the 2-norm of the P(2) matrix for corrections to Lia and P.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-dfmp2-p-tolerance-dfmp2">DFMP2_P_TOLERANCE (DFMP2)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfmp2.html#apdx-dfmp2"><span class="std std-ref">DFMP2</span></a> — Minimum error in the 2-norm of the P matrix for skeleton-core Fock matrix derivatives.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-dft-alpha-scf">DFT_ALPHA (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — The DFT Exact-exchange parameter</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-dft-alpha-c-scf">DFT_ALPHA_C (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — The DFT Correlation hybrid parameter</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-dft-basis-tolerance-scf">DFT_BASIS_TOLERANCE (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — DFT basis cutoff.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1.0e-12</li>
</ul>
</dd>
<dt id="term-dft-block-max-points-scf">DFT_BLOCK_MAX_POINTS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — The maximum number of grid points per evaluation block.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 5000</li>
</ul>
</dd>
<dt id="term-dft-block-max-radius-scf">DFT_BLOCK_MAX_RADIUS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — The maximum radius to terminate subdivision of an octree block [au].</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 3.0</li>
</ul>
</dd>
<dt id="term-dft-block-min-points-scf">DFT_BLOCK_MIN_POINTS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — The minimum number of grid points per evaluation block.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1000</li>
</ul>
</dd>
<dt id="term-dft-block-scheme-scf">DFT_BLOCK_SCHEME (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — The blocking scheme for DFT.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NAIVE, OCTREE</li>
<li><strong>Default</strong>: OCTREE</li>
</ul>
</dd>
<dt id="term-dft-bs-radius-alpha-scf">DFT_BS_RADIUS_ALPHA (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Factor for effective BS radius in radial grid.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.0</li>
</ul>
</dd>
<dt id="term-dft-custom-functional-scf">DFT_CUSTOM_FUNCTIONAL (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — A custom DFT functional object (built by Python or NULL/None)</p>
<ul class="last simple">
<li><strong>Type</strong>: python</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-dft-dispersion-parameters-scf">DFT_DISPERSION_PARAMETERS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Parameters defining the dispersion correction. See Table <a class="reference internal" href="dft_byfunctional.html#table-dft-disp"><span class="std std-ref">-D Functionals</span></a> for default values and Table <a class="reference internal" href="dftd3.html#table-dashd"><span class="std std-ref">Dispersion Corrections</span></a> for the order in which parameters are to be specified in this array option.</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-dft-functional-scf">DFT_FUNCTIONAL (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — The DFT combined functional name, e.g. B3LYP, or GEN to use a python reference to a custom functional specified by DFT_CUSTOM_FUNCTIONAL.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: HF</li>
</ul>
</dd>
<dt id="term-dft-grid-name-scf">DFT_GRID_NAME (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — The DFT grid specification, such as SG1.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: SG0, SG1</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-dft-nuclear-scheme-scf">DFT_NUCLEAR_SCHEME (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Nuclear Scheme.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: TREUTLER, BECKE, NAIVE, STRATMANN</li>
<li><strong>Default</strong>: TREUTLER</li>
</ul>
</dd>
<dt id="term-dft-omega-scf">DFT_OMEGA (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — The DFT Range-separation parameter</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-dft-omega-c-scf">DFT_OMEGA_C (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — The DFT Correlation Range-separation parameter</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-dft-pruning-alpha-scf">DFT_PRUNING_ALPHA (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — Spread alpha for logarithmic pruning.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.0</li>
</ul>
</dd>
<dt id="term-dft-pruning-scheme-scf">DFT_PRUNING_SCHEME (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — Pruning Scheme.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: FLAT, P_GAUSSIAN, D_GAUSSIAN, P_SLATER, D_SLATER, LOG_GAUSSIAN, LOG_SLATER</li>
<li><strong>Default</strong>: FLAT</li>
</ul>
</dd>
<dt id="term-dft-radial-points-scf">DFT_RADIAL_POINTS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Number of radial points.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 75</li>
</ul>
</dd>
<dt id="term-dft-radial-scheme-scf">DFT_RADIAL_SCHEME (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Radial Scheme.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: TREUTLER, BECKE, MULTIEXP, EM, MURA</li>
<li><strong>Default</strong>: TREUTLER</li>
</ul>
</dd>
<dt id="term-dft-spherical-points-scf">DFT_SPHERICAL_POINTS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Number of spherical points (A <a class="reference internal" href="dft.html#table-lebedevorder"><span class="std std-ref">Lebedev Points</span></a> number).</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 302</li>
</ul>
</dd>
<dt id="term-dft-spherical-scheme-scf">DFT_SPHERICAL_SCHEME (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Spherical Scheme.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: LEBEDEV</li>
<li><strong>Default</strong>: LEBEDEV</li>
</ul>
</dd>
<dt id="term-diag-method-detci">DIAG_METHOD (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — This specifies which method is to be used in diagonalizing the Hamiltonian. The valid options are: <code class="docutils literal"><span class="pre">RSP</span></code>, to form the entire H matrix and diagonalize using libciomr to obtain all eigenvalues (n.b. requires HUGE memory); <code class="docutils literal"><span class="pre">OLSEN</span></code>, to use Olsen&#8217;s preconditioned inverse subspace method (1990); <code class="docutils literal"><span class="pre">MITRUSHENKOV</span></code>, to use a 2x2 Olsen/Davidson method; and <code class="docutils literal"><span class="pre">DAVIDSON</span></code> (or <code class="docutils literal"><span class="pre">SEM</span></code>) to use Liu&#8217;s Simultaneous Expansion Method, which is identical to the Davidson method if only one root is to be found. There also exists a SEM debugging mode, <code class="docutils literal"><span class="pre">SEMTEST</span></code>. The <code class="docutils literal"><span class="pre">SEM</span></code> method is the most robust, but it also requires <span class="math">\(2NM+1\)</span> CI vectors on disk, where <span class="math">\(N\)</span> is the maximum number of iterations and <span class="math">\(M\)</span> is the number of roots.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: RSP, DAVIDSON, SEM</li>
<li><strong>Default</strong>: SEM</li>
</ul>
</dd>
<dt id="term-diagonal-ccsd-t-psimrcc">DIAGONAL_CCSD_T (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — Do include the diagonal corrections in (T) computations?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-diagonalize-heff-psimrcc">DIAGONALIZE_HEFF (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — Do diagonalize the effective Hamiltonian?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-die-if-not-converged-globals">DIE_IF_NOT_CONVERGED (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> <strong>(Expert)</strong> — Psi4 dies if energy does not converge.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-diis-ccenergy">DIIS (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Do use DIIS extrapolation to accelerate convergence?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-diis-cclambda">DIIS (CCLAMBDA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cclambda.html#apdx-cclambda"><span class="std std-ref">CCLAMBDA</span></a> — Do use DIIS extrapolation to accelerate convergence?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-diis-ccresponse">DIIS (CCRESPONSE)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccresponse.html#apdx-ccresponse"><span class="std std-ref">CCRESPONSE</span></a> — Do use DIIS extrapolation to accelerate convergence?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-diis-detci">DIIS (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Do use DIIS extrapolation to accelerate CC convergence?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-diis-mcscf">DIIS (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> — Do use DIIS extrapolation to accelerate convergence of the SCF energy (MO coefficients only)?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-diis-scf">DIIS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Do use DIIS extrapolation to accelerate convergence?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-diis-freq-detci">DIIS_FREQ (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — How often to do a DIIS extrapolation. 1 means do DIIS every iteration, 2 is every other iteration, etc.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-diis-max-vecs-dcft">DIIS_MAX_VECS (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> <strong>(Expert)</strong> — Maximum number of error vectors stored for DIIS extrapolation</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 6</li>
</ul>
</dd>
<dt id="term-diis-max-vecs-detci">DIIS_MAX_VECS (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Maximum number of error vectors stored for DIIS extrapolation</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 5</li>
</ul>
</dd>
<dt id="term-diis-max-vecs-fnocc">DIIS_MAX_VECS (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> — Desired number of DIIS vectors</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 8</li>
</ul>
</dd>
<dt id="term-diis-max-vecs-mcscf">DIIS_MAX_VECS (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> — Maximum number of error vectors stored for DIIS extrapolation</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 7</li>
</ul>
</dd>
<dt id="term-diis-max-vecs-psimrcc">DIIS_MAX_VECS (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — Maximum number of error vectors stored for DIIS extrapolation</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 7</li>
</ul>
</dd>
<dt id="term-diis-max-vecs-scf">DIIS_MAX_VECS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Maximum number of error vectors stored for DIIS extrapolation</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 10</li>
</ul>
</dd>
<dt id="term-diis-min-vecs-dcft">DIIS_MIN_VECS (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> <strong>(Expert)</strong> — Minimum number of error vectors stored for DIIS extrapolation</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 3</li>
</ul>
</dd>
<dt id="term-diis-min-vecs-detci">DIIS_MIN_VECS (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Minimum number of error vectors stored for DIIS extrapolation</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-diis-min-vecs-scf">DIIS_MIN_VECS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Minimum number of error vectors stored for DIIS extrapolation</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-diis-start-psimrcc">DIIS_START (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — The number of DIIS vectors needed before extrapolation is performed</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-diis-start-scf">DIIS_START (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — The minimum iteration to start storing DIIS vectors</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-diis-start-convergence-dcft">DIIS_START_CONVERGENCE (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> — Value of RMS of the density cumulant residual and SCF error vector below which DIIS extrapolation starts. Same keyword controls the DIIS extrapolation for the solution of the response equations.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-3</li>
</ul>
</dd>
<dt id="term-diis-start-iter-detci">DIIS_START_ITER (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Iteration at which to start using DIIS</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-dipmom-detci">DIPMOM (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Do compute the dipole moment?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-dipmom-fnocc">DIPMOM (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> — Compute the dipole moment? Note that dipole moments are only available in the FNOCC module for the ACPF, AQCC, CISD, and CEPA(0) methods.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-disp-size-findif">DISP_SIZE (FINDIF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__findif.html#apdx-findif"><span class="std std-ref">FINDIF</span></a> — Displacement size in au for finite-differences.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.005</li>
</ul>
</dd>
<dt id="term-distributed-matrix-scf">DISTRIBUTED_MATRIX (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — The dimension sizes of the distributed matrix</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-dkh-order-globals">DKH_ORDER (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> <strong>(Expert)</strong> — Order of Douglas-Kroll-Hess</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-dmrg-caspt2-calc-dmrg">DMRG_CASPT2_CALC (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — Do calculate the DMRG-CASPT2 energy after the DMRGSCF calculations are done?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-dmrg-caspt2-imag-dmrg">DMRG_CASPT2_IMAG (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — CASPT2 Imaginary shift</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-dmrg-caspt2-ipea-dmrg">DMRG_CASPT2_IPEA (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — CASPT2 IPEA shift</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-dmrg-caspt2-orbs-dmrg">DMRG_CASPT2_ORBS (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — Whether to calculate the DMRG-CASPT2 energy after the DMRGSCF calculations are done.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: PSEUDOCANONICAL, ACTIVE</li>
<li><strong>Default</strong>: PSEUDOCANONICAL</li>
</ul>
</dd>
<dt id="term-dmrg-diis-dmrg">DMRG_DIIS (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — Whether or not to use DIIS for DMRG.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-dmrg-diis-write-dmrg">DMRG_DIIS_WRITE (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — Whether or not to store the DIIS checkpoint on disk (convenient for restarting).</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-dmrg-excitation-dmrg">DMRG_EXCITATION (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — Which root is targeted: 0 means ground state, 1 first excited state, etc.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-dmrg-irrep-dmrg">DMRG_IRREP (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — The DMRG wavefunction irrep uses the same conventions as PSI4. How convenient :-). Just to avoid confusion, it&#8217;s copied here. It can also be found on <a class="reference external" href="http://sebwouters.github.io/CheMPS2/doxygen/classCheMPS2_1_1Irreps.html">http://sebwouters.github.io/CheMPS2/doxygen/classCheMPS2_1_1Irreps.html</a> . Symmetry Conventions Irrep Number &amp; Name Group Number &amp; Name 0 1 2 3 4 5 6 7 0: c1 A 1: ci Ag Au 2: c2 A B 3: cs A&#8217; A&#8217;&#8217; 4: d2 A B1 B2 B3 5: c2v A1 A2 B1 B2 6: c2h Ag Bg Au Bu 7: d2h Ag B1g B2g B3g Au B1u B2u B3u</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: -1</li>
</ul>
</dd>
<dt id="term-dmrg-local-init-dmrg">DMRG_LOCAL_INIT (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — Whether to start the active space localization process from a random unitary or the unit matrix.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-dmrg-molden-write-dmrg">DMRG_MOLDEN_WRITE (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — DMRG-CI or converged DMRG-SCF orbitals in molden format</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-dmrg-mps-write-dmrg">DMRG_MPS_WRITE (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — Whether or not to create intermediary MPS checkpoints</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-dmrg-multiplicity-dmrg">DMRG_MULTIPLICITY (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — The DMRG wavefunction multiplicity in the form (2S+1)</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: -1</li>
</ul>
</dd>
<dt id="term-dmrg-opdm-ao-print-dmrg">DMRG_OPDM_AO_PRINT (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — Print out the density matrix in the AO basis</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-dmrg-print-corr-dmrg">DMRG_PRINT_CORR (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — Whether or not to print the correlation functions after the DMRG calculation</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-dmrg-scf-active-space-dmrg">DMRG_SCF_ACTIVE_SPACE (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — Which active space to use for DMRG calculations: &#8211;&gt; input with SCF rotations (INPUT); &#8211;&gt; natural orbitals (NO); &#8211;&gt; localized and ordered orbitals (LOC)</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: INPUT, NO, LOC</li>
<li><strong>Default</strong>: INPUT</li>
</ul>
</dd>
<dt id="term-dmrg-scf-diis-thr-dmrg">DMRG_SCF_DIIS_THR (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — When the update norm is smaller than this value DIIS starts.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1e-2</li>
</ul>
</dd>
<dt id="term-dmrg-scf-grad-thr-dmrg">DMRG_SCF_GRAD_THR (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — The density RMS convergence to stop an instruction during successive DMRG instructions</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.e-6</li>
</ul>
</dd>
<dt id="term-dmrg-scf-max-iter-dmrg">DMRG_SCF_MAX_ITER (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — Maximum number of DMRG iterations</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 100</li>
</ul>
</dd>
<dt id="term-dmrg-scf-state-avg-dmrg">DMRG_SCF_STATE_AVG (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — Whether or not to use state-averaging for roots &gt;=2 with DMRG-SCF.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-dmrg-sweep-dvdson-rtol-dmrg">DMRG_SWEEP_DVDSON_RTOL (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — The residual tolerances for the Davidson diagonalization during DMRG instructions</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-dmrg-sweep-energy-conv-dmrg">DMRG_SWEEP_ENERGY_CONV (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — The energy convergence to stop an instruction during successive DMRG instructions</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-dmrg-sweep-max-sweeps-dmrg">DMRG_SWEEP_MAX_SWEEPS (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — The maximum number of sweeps to stop an instruction during successive DMRG instructions</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-dmrg-sweep-noise-prefac-dmrg">DMRG_SWEEP_NOISE_PREFAC (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — The noise prefactors for successive DMRG instructions</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-dmrg-sweep-states-dmrg">DMRG_SWEEP_STATES (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — The number of reduced renormalized basis states to be retained during successive DMRG instructions</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-dmrg-unitary-write-dmrg">DMRG_UNITARY_WRITE (DMRG)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dmrg.html#apdx-dmrg"><span class="std std-ref">DMRG</span></a> — Whether or not to store the unitary on disk (convenient for restarting).</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-do-ccd-disp-sapt">DO_CCD_DISP (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> <strong>(Expert)</strong> — Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-do-diis-dfocc">DO_DIIS (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Do apply DIIS extrapolation?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-do-diis-occ">DO_DIIS (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Do apply DIIS extrapolation?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-do-level-shift-dfocc">DO_LEVEL_SHIFT (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Do apply level shifting?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-do-level-shift-occ">DO_LEVEL_SHIFT (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Do apply level shifting?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-do-mbpt-disp-sapt">DO_MBPT_DISP (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> <strong>(Expert)</strong> — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-do-qqr-sieve-cphf">DO_QQR_SIEVE (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Do we do the QQR integral sieve of Maurer et al. When false, just uses * the Schwarz sieve.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-do-scs-dfocc">DO_SCS (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set &#8216;DO_SCS&#8217; to true</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-do-scs-occ">DO_SCS (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set &#8216;DO_SCS&#8217; to true</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-do-singlets-cphf">DO_SINGLETS (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Do singlet states? Default true</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-do-sos-dfocc">DO_SOS (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set &#8216;DO_SOS&#8217; to true</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-do-sos-occ">DO_SOS (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set &#8216;DO_SOS&#8217; to true</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-do-third-order-sapt">DO_THIRD_ORDER (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> <strong>(Expert)</strong> — Do compute third-order corrections?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-do-triplets-cphf">DO_TRIPLETS (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Do triplet states? Default true</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-docc-globals">DOCC (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order)</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-docc-mcscf">DOCC (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> — The number of doubly occupied orbitals, per irrep</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-dynamic-level-optking">DYNAMIC_LEVEL (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Starting level for dynamic optimization (0=nondynamic, higher=&gt;more conservative)</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-e3-scale-dfocc">E3_SCALE (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — CEPA opposite-spin scaling value from SCS-CCSD</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.25</li>
</ul>
</dd>
<dt id="term-e3-scale-occ">E3_SCALE (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.)</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.25</li>
</ul>
</dd>
<dt id="term-e-convergence-ccenergy">E_CONVERGENCE (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Convergence criterion for energy. See Table <a class="reference internal" href="scf.html#table-conv-corl"><span class="std std-ref">Post-SCF Convergence</span></a> for default convergence criteria for different calculation types.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-6</li>
</ul>
</dd>
<dt id="term-e-convergence-cceom">E_CONVERGENCE (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table <a class="reference internal" href="scf.html#table-conv-corl"><span class="std std-ref">Post-SCF Convergence</span></a> for default convergence criteria for different calculation types.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-6</li>
</ul>
</dd>
<dt id="term-e-convergence-dcft">E_CONVERGENCE (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> — Convergence criterion for energy. See Table <a class="reference internal" href="scf.html#table-conv-corl"><span class="std std-ref">Post-SCF Convergence</span></a> for default convergence criteria for different calculation types.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-10</li>
</ul>
</dd>
<dt id="term-e-convergence-detci">E_CONVERGENCE (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Convergence criterion for energy. See Table <a class="reference internal" href="scf.html#table-conv-corl"><span class="std std-ref">Post-SCF Convergence</span></a> for default convergence criteria for different calculation types.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-6</li>
</ul>
</dd>
<dt id="term-e-convergence-dfocc">E_CONVERGENCE (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Convergence criterion for energy. See Table <a class="reference internal" href="scf.html#table-conv-corl"><span class="std std-ref">Post-SCF Convergence</span></a> for default convergence criteria for different calculation types.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-6</li>
</ul>
</dd>
<dt id="term-e-convergence-fnocc">E_CONVERGENCE (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> — Convergence criterion for CC energy. See Table <a class="reference internal" href="scf.html#table-conv-corl"><span class="std std-ref">Post-SCF Convergence</span></a> for default convergence criteria for different calculation types. Note that convergence is met only when <a class="reference internal" href="#term-e-convergence-fnocc"><span class="xref std std-term">E_CONVERGENCE</span></a> and <a class="reference internal" href="#term-r-convergence-fnocc"><span class="xref std std-term">R_CONVERGENCE</span></a> are satisfied.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1.0e-6</li>
</ul>
</dd>
<dt id="term-e-convergence-mcscf">E_CONVERGENCE (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> — Convergence criterion for energy.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-6</li>
</ul>
</dd>
<dt id="term-e-convergence-mrcc">E_CONVERGENCE (MRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mrcc.html#apdx-mrcc"><span class="std std-ref">MRCC</span></a> — Convergence criterion for energy. See Table <a class="reference internal" href="scf.html#table-conv-corl"><span class="std std-ref">Post-SCF Convergence</span></a> for default convergence criteria for different calculation types. This becomes <code class="docutils literal"><span class="pre">tol</span></code> (option #16) in fort.56.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-6</li>
</ul>
</dd>
<dt id="term-e-convergence-occ">E_CONVERGENCE (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Convergence criterion for energy. See Table <a class="reference internal" href="scf.html#table-conv-corl"><span class="std std-ref">Post-SCF Convergence</span></a> for default convergence criteria for different calculation types.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-6</li>
</ul>
</dd>
<dt id="term-e-convergence-psimrcc">E_CONVERGENCE (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — Convergence criterion for energy. See Table <a class="reference internal" href="scf.html#table-conv-corl"><span class="std std-ref">Post-SCF Convergence</span></a> for default convergence criteria for different calculation types.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-6</li>
</ul>
</dd>
<dt id="term-e-convergence-sapt">E_CONVERGENCE (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — Convergence criterion for energy (change) in the SAPT <span class="math">\(E_{ind,resp}^{(20)}\)</span> term during solution of the CPHF equations.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-10</li>
</ul>
</dd>
<dt id="term-e-convergence-scf">E_CONVERGENCE (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Convergence criterion for SCF energy. See Table <a class="reference internal" href="scf.html#table-conv-scf"><span class="std std-ref">SCF Convergence &amp; Algorithm</span></a> for default convergence criteria for different calculation types.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-6</li>
</ul>
</dd>
<dt id="term-ea-poles-occ">EA_POLES (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Do compute OCC poles for electron affinities? Only valid for OMP2.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-efp-disp-efp">EFP_DISP (EFP)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__efp.html#apdx-efp"><span class="std std-ref">EFP</span></a> — Do include dispersion energy term in EFP computation?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-efp-disp-damping-efp">EFP_DISP_DAMPING (EFP)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__efp.html#apdx-efp"><span class="std std-ref">EFP</span></a> — Fragment-fragment dispersion damping type. <code class="docutils literal"><span class="pre">TT</span></code> is a damping formula by Tang and Toennies. <code class="docutils literal"><span class="pre">OVERLAP</span></code> is overlap-based dispersion damping.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: TT, OVERLAP, OFF</li>
<li><strong>Default</strong>: OVERLAP</li>
</ul>
</dd>
<dt id="term-efp-elst-efp">EFP_ELST (EFP)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__efp.html#apdx-efp"><span class="std std-ref">EFP</span></a> — Do include electrostatics energy term in EFP computation?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-efp-elst-damping-efp">EFP_ELST_DAMPING (EFP)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__efp.html#apdx-efp"><span class="std std-ref">EFP</span></a> — Fragment-fragment electrostatic damping type. <code class="docutils literal"><span class="pre">SCREEN</span></code> is a damping formula based on screen group in the EFP potential. <code class="docutils literal"><span class="pre">OVERLAP</span></code> is damping that computes charge penetration energy.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: SCREEN, OVERLAP, OFF</li>
<li><strong>Default</strong>: SCREEN</li>
</ul>
</dd>
<dt id="term-efp-exch-efp">EFP_EXCH (EFP)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__efp.html#apdx-efp"><span class="std std-ref">EFP</span></a> — Do include exchange repulsion energy term in EFP computation?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-efp-pol-efp">EFP_POL (EFP)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__efp.html#apdx-efp"><span class="std std-ref">EFP</span></a> — Do include polarization energy term in EFP computation?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-efp-pol-damping-efp">EFP_POL_DAMPING (EFP)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__efp.html#apdx-efp"><span class="std std-ref">EFP</span></a> — Fragment-fragment polarization damping type. <code class="docutils literal"><span class="pre">TT</span></code> is a damping formula like Tang and Toennies.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: TT, OFF</li>
<li><strong>Default</strong>: TT</li>
</ul>
</dd>
<dt id="term-ekt-ea-occ">EKT_EA (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Do compute virtual orbital energies based on extended Koopmans&#8217; theorem?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-ekt-ip-dfocc">EKT_IP (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Do compute ionization potentials based on the extended Koopmans&#8217; theorem?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-ekt-ip-occ">EKT_IP (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Do compute occupied orbital energies based on extended Koopmans&#8217; theorem?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-energy-level-shift-dcft">ENERGY_LEVEL_SHIFT (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> <strong>(Expert)</strong> — Level shift applied to the diagonal of the density-weighted Fock operator. While this shift can improve convergence, it does change the DCFT energy.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-ensure-bt-convergence-optking">ENSURE_BT_CONVERGENCE (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Reduce step size as necessary to ensure back-transformation of internal coordinate step to cartesian coordinates.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-eom-guess-cceom">EOM_GUESS (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = <code class="docutils literal"><span class="pre">SINGLES</span></code>, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = <code class="docutils literal"><span class="pre">DISK</span></code>, guess vectors from a previous computation will be read from disk. If EOM_GUESS = <code class="docutils literal"><span class="pre">INPUT</span></code>, guess vectors will be specified in user input. The latter method is not currently available.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: SINGLES, DISK, INPUT</li>
<li><strong>Default</strong>: SINGLES</li>
</ul>
</dd>
<dt id="term-eom-reference-cceom">EOM_REFERENCE (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Reference wavefunction type for EOM computations</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: RHF, ROHF, UHF</li>
<li><strong>Default</strong>: RHF</li>
</ul>
</dd>
<dt id="term-eom-reference-cchbar">EOM_REFERENCE (CCHBAR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cchbar.html#apdx-cchbar"><span class="std std-ref">CCHBAR</span></a> — Reference wavefunction type for EOM computations</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: RHF</li>
</ul>
</dd>
<dt id="term-ep-ea-poles-occ">EP_EA_POLES (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Do compute EP-OCC poles for electron affinities? Only valid for OMP2.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-ep-ip-poles-occ">EP_IP_POLES (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Do compute EP-OCC poles for ionization potentials? Only valid OMP2.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-ep-maxiter-occ">EP_MAXITER (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Maximum number of electron propagator iterations.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 30</li>
</ul>
</dd>
<dt id="term-ex-allow-detci">EX_ALLOW (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — An array of length <a class="reference internal" href="#term-ex-level-detci"><span class="xref std std-term">EX_LEVEL</span></a> specifying whether each excitation type (S,D,T, etc.) is allowed (1 is allowed, 0 is disallowed). Used to specify non-standard CI spaces such as CIST.</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-ex-level-detci">EX_LEVEL (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — The CI excitation level</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-exch-scale-alpha-sapt">EXCH_SCALE_ALPHA (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with <span class="math">\(Exch10 / Exch10(S^2)\)</span>. If set to a value <span class="math">\(\alpha\)</span>, performs scaling with <span class="math">\((Exch10 / Exch10(S^2))^{\alpha}\)</span>.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: FALSE</li>
</ul>
</dd>
<dt id="term-excitation-range-cceom">EXCITATION_RANGE (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> <strong>(Expert)</strong> — The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-explicit-hamiltonian-cphf">EXPLICIT_HAMILTONIAN (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Do explicit hamiltonian only?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-extern-scf">EXTERN (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — An ExternalPotential (built by Python or NULL/None)</p>
<ul class="last simple">
<li><strong>Type</strong>: python</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-external-potential-symmetry-globals">EXTERNAL_POTENTIAL_SYMMETRY (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> <strong>(Expert)</strong> — Assume external fields are arranged so that they have symmetry. It is up to the user to know what to do here. The code does NOT help you out in any way!</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-fail-on-maxiter-scf">FAIL_ON_MAXITER (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Fail if we reach maxiter without converging?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-favg-mcscf">FAVG (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> — Do use the average Fock matrix during the SCF optimization?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-favg-ccsd-t-psimrcc">FAVG_CCSD_T (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — Do use the averaged Fock matrix over all references in (T) computations?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-favg-start-mcscf">FAVG_START (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> — Iteration at which to begin using the averaged Fock matrix</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 5</li>
</ul>
</dd>
<dt id="term-fci-detci">FCI (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Do a full CI (FCI)? If TRUE, overrides the value of <a class="reference internal" href="#term-ex-level-detci"><span class="xref std std-term">EX_LEVEL</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-fci-strings-detci">FCI_STRINGS (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Do store strings specifically for FCI? (Defaults to TRUE for FCI.)</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-filter-guess-detci">FILTER_GUESS (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Do invoke the FILTER_GUESS options that are used to filter out some trial vectors which may not have the appropriate phase convention between two determinants? This is useful to remove, e.g., delta states when a sigma state is desired. The user inputs two determinants (by giving the absolute alpha string number and beta string number for each), and also the desired phase between these two determinants for guesses which are to be kept. FILTER_GUESS = TRUE turns on the filtering routine. Requires additional keywords <a class="reference internal" href="#term-filter-guess-det1-detci"><span class="xref std std-term">FILTER_GUESS_DET1</span></a>, <a class="reference internal" href="#term-filter-guess-det2-detci"><span class="xref std std-term">FILTER_GUESS_DET2</span></a>, and <a class="reference internal" href="#term-filter-guess-sign-detci"><span class="xref std std-term">FILTER_GUESS_SIGN</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-filter-guess-det1-detci">FILTER_GUESS_DET1 (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Array specifying the absolute alpha string number and beta string number for the first determinant in the filter procedure. (See <a class="reference internal" href="#term-filter-guess-detci"><span class="xref std std-term">FILTER_GUESS</span></a>).</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-filter-guess-det2-detci">FILTER_GUESS_DET2 (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Array specifying the absolute alpha string number and beta string number for the second determinant in the filter procedure. (See <a class="reference internal" href="#term-filter-guess-detci"><span class="xref std std-term">FILTER_GUESS</span></a>).</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-filter-guess-sign-detci">FILTER_GUESS_SIGN (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — The required phase (1 or -1) between the two determinants specified by <a class="reference internal" href="#term-filter-guess-det1-detci"><span class="xref std std-term">FILTER_GUESS_DET1</span></a> and <a class="reference internal" href="#term-filter-guess-det2-detci"><span class="xref std std-term">FILTER_GUESS_DET2</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-filter-zero-det-detci">FILTER_ZERO_DET (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — If present, the code will try to filter out a particular determinant by setting its CI coefficient to zero. FILTER_ZERO_DET = [alphastr, betastr] specifies the absolute alpha and beta string numbers of the target determinant. This could be useful for trying to exclude states that have a nonzero CI coefficient for the given determinant. However, this option was experimental and may not be effective.</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-final-geom-write-optking">FINAL_GEOM_WRITE (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Do save and print the geometry from the last projected step at the end of a geometry optimization? Otherwise (and by default), save and print the previous geometry at which was computed the gradient that satisfied the convergence criteria.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-fisapt-charge-completeness-fisapt">FISAPT_CHARGE_COMPLETENESS (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — Amount of fragment charge completeness to distinguish link bonds</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.8</li>
</ul>
</dd>
<dt id="term-fisapt-do-fsapt-fisapt">FISAPT_DO_FSAPT (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — Do an F-SAPT analysis?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-fisapt-do-plot-fisapt">FISAPT_DO_PLOT (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — Plot a scalar-field analysis</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-fisapt-fsapt-exch-scale-fisapt">FISAPT_FSAPT_EXCH_SCALE (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — Do F-SAPT exchange scaling? (ratio of S^infty to S^2)</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-fisapt-fsapt-filepath-fisapt">FISAPT_FSAPT_FILEPATH (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — Filepath to drop F-SAPT data</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: fsapt/</li>
</ul>
</dd>
<dt id="term-fisapt-fsapt-ind-response-fisapt">FISAPT_FSAPT_IND_RESPONSE (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — Do F-SAPT coupled response? (not recommended)</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-fisapt-fsapt-ind-scale-fisapt">FISAPT_FSAPT_IND_SCALE (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — Do F-SAPT induction scaling? (ratio of HF induction to F-SAPT induction)</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-fisapt-fssapt-filepath-fisapt">FISAPT_FSSAPT_FILEPATH (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — Filepath to drop sSAPT0 exchange-scaling F-SAPT data</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: s-fsapt/</li>
</ul>
</dd>
<dt id="term-fisapt-link-assignment-fisapt">FISAPT_LINK_ASSIGNMENT (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — Where do sigma links go (to C or to AB)?</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: C, AB</li>
<li><strong>Default</strong>: C</li>
</ul>
</dd>
<dt id="term-fisapt-link-selection-fisapt">FISAPT_LINK_SELECTION (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — Specification algorithm for link bonds in ISAPT</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: AUTOMATIC, MANUAL</li>
<li><strong>Default</strong>: AUTOMATIC</li>
</ul>
</dd>
<dt id="term-fisapt-manual-links-fisapt">FISAPT_MANUAL_LINKS (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — Manual link bond specification [[Atom1, Atom2], ...]</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-fisapt-mem-safety-factor-fisapt">FISAPT_MEM_SAFETY_FACTOR (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> <strong>(Expert)</strong> — Memory safety factor for heavy FISAPT operations</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.9</li>
</ul>
</dd>
<dt id="term-fisapt-plot-filepath-fisapt">FISAPT_PLOT_FILEPATH (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — Filepath to drop scalar data</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: plot/</li>
</ul>
</dd>
<dt id="term-fitting-algorithm-cphf">FITTING_ALGORITHM (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Fitting algorithm (0 for old, 1 for new)</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-fitting-condition-cphf">FITTING_CONDITION (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — The maximum reciprocal condition allowed in the fitting metric</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.0e-12</li>
</ul>
</dd>
<dt id="term-fixed-bend-optking">FIXED_BEND (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Specify angles between atoms to be fixed (eq. value specified)</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-fixed-coord-force-constant-optking">FIXED_COORD_FORCE_CONSTANT (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — In constrained optimizations, for coordinates with user-specified equilibrium values, this is the initial force constant (in au) used to apply an additional force to each coordinate.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.5</li>
</ul>
</dd>
<dt id="term-fixed-dihedral-optking">FIXED_DIHEDRAL (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Specify dihedral angles between atoms to be fixed (eq. value specified)</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-fixed-distance-optking">FIXED_DISTANCE (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Specify distances between atoms to be fixed (eq. value specified)</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-flexible-g-convergence-optking">FLEXIBLE_G_CONVERGENCE (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Even if a user-defined threshold is set, allow for normal, flexible convergence criteria</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-follow-root-detci">FOLLOW_ROOT (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — The root to write out the two-particle density matrix for (the one-particle density matrices are written for all roots). Useful for a state-specific CASSCF or CI optimization on an excited state.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-follow-root-mcscf">FOLLOW_ROOT (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> — Which solution of the SCF equations to find, where 1 is the SCF ground state</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-follow-root-psimrcc">FOLLOW_ROOT (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — Which root of the effective hamiltonian is the target state?</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-follow-step-increment-scf">FOLLOW_STEP_INCREMENT (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — When using STABILITY_ANALYSIS = FOLLOW, the increment to modify <a class="reference internal" href="#term-follow-step-scale-scf"><span class="xref std std-term">FOLLOW_STEP_SCALE</span></a> value if we end up in the same SCF solution.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.2</li>
</ul>
</dd>
<dt id="term-follow-step-scale-scf">FOLLOW_STEP_SCALE (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — When using <a class="reference internal" href="#term-stability-analysis-scf"><span class="xref std std-term">STABILITY_ANALYSIS</span></a> <code class="docutils literal"><span class="pre">FOLLOW</span></code>, how much to scale the step along the eigenvector by. A full step of <span class="math">\(pi/2\)</span> corresponds to a value of 1.0.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.5</li>
</ul>
</dd>
<dt id="term-follow-vector-detci">FOLLOW_VECTOR (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — In following a particular root (see <a class="reference internal" href="#term-follow-root-detci"><span class="xref std std-term">FOLLOW_ROOT</span></a>), sometimes the root number changes. To follow a root of a particular character, one can specify a list of determinants and their coefficients, and the code will follow the root with the closest overlap. The user specifies arrays containing the absolute alpha string indices (A_i below), absolute beta indices (B_i below), and CI coefficients (C_i below) to form the desired vector. The format is FOLLOW_VECTOR = [ [[A_1, B_1], C_1], [[A_2, B_2], C_2], ...].</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-force-restart-ccenergy">FORCE_RESTART (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> <strong>(Expert)</strong> — Do restart the coupled-cluster iterations even if MO phases are screwed up?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-force-twocon-mcscf">FORCE_TWOCON (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> — Do attempt to force a two configruation solution by starting with CI coefficents of <span class="math">\(\pm \sqrt{\frac{1}{2}}\)</span> ?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-frac-diis-scf">FRAC_DIIS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Do use DIIS extrapolation to accelerate convergence in frac?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-frac-load-scf">FRAC_LOAD (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Do recompute guess from stored orbitals?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-frac-occ-scf">FRAC_OCC (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta)</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-frac-renormalize-scf">FRAC_RENORMALIZE (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Do renormalize C matrices prior to writing to checkpoint?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-frac-start-scf">FRAC_START (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation)</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-frac-val-scf">FRAC_VAL (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — The occupations of the orbital indices specified above (<span class="math">\(0.0\ge occ \ge 1.0\)</span>)</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-frag-mode-optking">FRAG_MODE (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — For multi-fragment molecules, treat as single bonded molecule or via interfragment coordinates. A primary difference is that in <code class="docutils literal"><span class="pre">MULTI</span></code> mode, the interfragment coordinates are not redundant.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: SINGLE, MULTI</li>
<li><strong>Default</strong>: SINGLE</li>
</ul>
</dd>
<dt id="term-frag-ref-atoms-optking">FRAG_REF_ATOMS (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Which atoms define the reference points for interfragment coordinates?</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-freeze-core-globals">FREEZE_CORE (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — Specifies how many core orbitals to freeze in correlated computations. <code class="docutils literal"><span class="pre">TRUE</span></code> will default to freezing the standard default number of core orbitals. For PSI, the standard number of core orbitals is the number of orbitals in the nearest previous noble gas atom. More precise control over the number of frozen orbitals can be attained by using the keywords <a class="reference internal" href="#term-num-frozen-docc-globals"><span class="xref std std-term">NUM_FROZEN_DOCC</span></a> (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or <a class="reference internal" href="#term-frozen-docc-globals"><span class="xref std std-term">FROZEN_DOCC</span></a> (gives the number of orbitals to freeze per irreducible representation)</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: FALSE, TRUE</li>
<li><strong>Default</strong>: FALSE</li>
</ul>
</dd>
<dt id="term-freeze-core-sapt">FREEZE_CORE (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — The scope of core orbitals to freeze in evaluation of SAPT <span class="math">\(E_{disp}^{(20)}\)</span> and <span class="math">\(E_{exch-disp}^{(20)}\)</span> terms. Recommended true for all SAPT computations</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: FALSE, TRUE</li>
<li><strong>Default</strong>: FALSE</li>
</ul>
</dd>
<dt id="term-freeze-interfrag-optking">FREEZE_INTERFRAG (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Do freeze all interfragment modes?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-freeze-intrafrag-optking">FREEZE_INTRAFRAG (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Do freeze all fragments rigid?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-frozen-bend-optking">FROZEN_BEND (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Specify angles between atoms to be frozen (unchanged)</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-frozen-cartesian-optking">FROZEN_CARTESIAN (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Specify atom and X, XY, XYZ, ... to be frozen (unchanged)</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-frozen-dihedral-optking">FROZEN_DIHEDRAL (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Specify dihedral angles between atoms to be frozen (unchanged)</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-frozen-distance-optking">FROZEN_DISTANCE (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Specify distances between atoms to be frozen (unchanged)</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-frozen-docc-globals">FROZEN_DOCC (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps <a class="reference internal" href="#term-num-frozen-docc-globals"><span class="xref std std-term">NUM_FROZEN_DOCC</span></a> and <a class="reference internal" href="#term-freeze-core-globals"><span class="xref std std-term">FREEZE_CORE</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-frozen-uocc-globals">FROZEN_UOCC (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps <a class="reference internal" href="#term-num-frozen-uocc-globals"><span class="xref std std-term">NUM_FROZEN_UOCC</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-full-hess-every-optking">FULL_HESS_EVERY (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: -1</li>
</ul>
</dd>
<dt id="term-full-matrix-cceom">FULL_MATRIX (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Do use full effective Hamiltonian matrix?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-g-convergence-optking">G_CONVERGENCE (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless <a class="reference internal" href="#term-flexible-g-convergence-optking"><span class="xref std std-term">FLEXIBLE_G_CONVERGENCE</span></a> is also on. See Table <a class="reference internal" href="optking.html#table-optkingconv"><span class="std std-ref">Geometry Convergence</span></a> for details.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE</li>
<li><strong>Default</strong>: QCHEM</li>
</ul>
</dd>
<dt id="term-gauge-ccdensity">GAUGE (CCDENSITY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccdensity.html#apdx-ccdensity"><span class="std std-ref">CCDENSITY</span></a> — The type of gauge to use for properties</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: LENGTH</li>
</ul>
</dd>
<dt id="term-gauge-ccresponse">GAUGE (CCRESPONSE)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccresponse.html#apdx-ccresponse"><span class="std std-ref">CCRESPONSE</span></a> — Specifies the choice of representation of the electric dipole operator. Acceptable values are <code class="docutils literal"><span class="pre">LENGTH</span></code> for the usual length-gauge representation, <code class="docutils literal"><span class="pre">VELOCITY</span></code> for the modified velocity-gauge representation in which the static-limit optical rotation tensor is subtracted from the frequency- dependent tensor, or <code class="docutils literal"><span class="pre">BOTH</span></code>. Note that, for optical rotation calculations, only the choices of <code class="docutils literal"><span class="pre">VELOCITY</span></code> or <code class="docutils literal"><span class="pre">BOTH</span></code> will yield origin-independent results.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: LENGTH, VELOCITY, BOTH</li>
<li><strong>Default</strong>: LENGTH</li>
</ul>
</dd>
<dt id="term-gdma-limit-gdma">GDMA_LIMIT (GDMA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__gdma.html#apdx-gdma"><span class="std std-ref">GDMA</span></a> — The order of multipole expansion on each site. Currently limited to the same order for all sites; for more advanced usage a user-provided GDMA data file should be provided.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-gdma-multipole-units-gdma">GDMA_MULTIPOLE_UNITS (GDMA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__gdma.html#apdx-gdma"><span class="std std-ref">GDMA</span></a> — Whether to print DMA results in atomic units or SI.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: AU</li>
<li><strong>Default</strong>: AU SI</li>
</ul>
</dd>
<dt id="term-gdma-origin-gdma">GDMA_ORIGIN (GDMA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__gdma.html#apdx-gdma"><span class="std std-ref">GDMA</span></a> — The origin (in Angstrom, expressed as an [x, y, z] array) about which the total multipoles will be computed during DMA. Useful for determining single site expansions at an arbitrary point.</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-gdma-radius-gdma">GDMA_RADIUS (GDMA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__gdma.html#apdx-gdma"><span class="std std-ref">GDMA</span></a> — The radii to be used, overriding the defaults. Specified as an array [ n1, r1, n2, r2, ... ] where n1,n2,n3... are atom type strings and r1,r2,r3 are radii in Angstrom.</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-gdma-switch-gdma">GDMA_SWITCH (GDMA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__gdma.html#apdx-gdma"><span class="std std-ref">GDMA</span></a> — The value to switch between the older standard DMA and the new grid-based approach. Pairs of primitives whose exponents sum is above this value will be treated using standard DMA. Set to 0 to force all pairs to be treated with standard DMA.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 4.0</li>
</ul>
</dd>
<dt id="term-geom-maxiter-optking">GEOM_MAXITER (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Maximum number of geometry optimization steps</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 50</li>
</ul>
</dd>
<dt id="term-gradient-write-findif">GRADIENT_WRITE (FINDIF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__findif.html#apdx-findif"><span class="std std-ref">FINDIF</span></a> — Do write a gradient output file? If so, the filename will end in .grad, and the prefix is determined by <a class="reference internal" href="#term-writer-file-label-globals"><span class="xref std std-term">WRITER_FILE_LABEL</span></a> (if set), or else by the name of the output file plus the name of the current molecule.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-guess-scf">GUESS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — The type of guess orbitals. Defaults to SAD for RHF, GWH for ROHF and UHF, and READ for geometry optimizations after the first step.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: AUTO, CORE, GWH, SAD, READ</li>
<li><strong>Default</strong>: AUTO</li>
</ul>
</dd>
<dt id="term-guess-mix-scf">GUESS_MIX (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Mix the HOMO/LUMO in UHF or UKS to break alpha/beta spatial symmetry. Useful to produce broken-symmetry unrestricted solutions. Notice that this procedure is defined only for calculations in C1 symmetry.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-guess-persist-scf">GUESS_PERSIST (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-guess-r-convergence-dcft">GUESS_R_CONVERGENCE (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> — Convergence criterion for the density cumulant and orbital guess for the variationally orbital-optimized DCFT methods. Currently only available for ALGORITHM = SIMULTANEOUS.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-3</li>
</ul>
</dd>
<dt id="term-guess-vector-detci">GUESS_VECTOR (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Guess vector type. Accepted values are <code class="docutils literal"><span class="pre">UNIT</span></code> for a unit vector guess (<a class="reference internal" href="#term-num-roots-detci"><span class="xref std std-term">NUM_ROOTS</span></a> and <a class="reference internal" href="#term-num-init-vecs-detci"><span class="xref std std-term">NUM_INIT_VECS</span></a> must both be 1); <code class="docutils literal"><span class="pre">H0_BLOCK</span></code> to use eigenvectors from the H0 BLOCK submatrix (default); <code class="docutils literal"><span class="pre">DFILE</span></code> to use NUM_ROOTS previously converged vectors in the D file;</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: UNIT, H0_BLOCK, DFILE</li>
<li><strong>Default</strong>: H0_BLOCK</li>
</ul>
</dd>
<dt id="term-h0-block-coupling-detci">H0_BLOCK_COUPLING (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Do use coupling block in preconditioner?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-h0-block-coupling-size-detci">H0_BLOCK_COUPLING_SIZE (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Parameters which specifies the size of the coupling block within the generalized davidson preconditioner.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-h0-blocksize-detci">H0_BLOCKSIZE (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — This parameter specifies the size of the H0 block of the Hamiltonian which is solved exactly. The n determinants with the lowest SCF energy are selected, and a submatrix of the Hamiltonian is formed using these determinants. This submatrix is used to accelerate convergence of the CI iterations in the OLSEN and MITRUSHENKOV iteration schemes, and also to find a good starting guess for the SEM method if <a class="reference internal" href="#term-guess-vector-detci"><span class="xref std std-term">GUESS_VECTOR</span></a> is <code class="docutils literal"><span class="pre">H0_BLOCK</span></code>. Defaults to 1000. Note that the program may change the given size for Ms=0 cases (<a class="reference internal" href="#term-ms0-detci"><span class="xref std std-term">MS0</span></a> is TRUE) if it determines that the H0 block includes only one member of a pair of determinants related by time reversal symmetry. For very small block sizes, this could conceivably eliminate the entire H0 block; the program should print warnings if this occurs.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1000</li>
</ul>
</dd>
<dt id="term-h0-guess-size-detci">H0_GUESS_SIZE (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — size of H0 block for initial guess</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1000</li>
</ul>
</dd>
<dt id="term-h-bond-connect-optking">H_BOND_CONNECT (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — For now, this is a general maximum distance for the definition of H-bonds</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 4.3</li>
</ul>
</dd>
<dt id="term-h-guess-every-optking">H_GUESS_EVERY (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Re-estimate the Hessian at every step, i.e., ignore the currently stored Hessian.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-h-update-den-tol-optking">H_UPDATE_DEN_TOL (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Denominator check for hessian update.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-7</li>
</ul>
</dd>
<dt id="term-hd-avg-detci">HD_AVG (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — How to average H diag energies over spin coupling sets. <code class="docutils literal"><span class="pre">HD_EXACT</span></code> uses the exact diagonal energies which results in expansion vectors which break spin symmetry. <code class="docutils literal"><span class="pre">HD_KAVE</span></code> averages the diagonal energies over a spin-coupling set yielding spin pure expansion vectors. <code class="docutils literal"><span class="pre">ORB_ENER</span></code> employs the sum of orbital energy approximation giving spin pure expansion vectors but usually doubles the number of Davidson iterations. <code class="docutils literal"><span class="pre">EVANGELISTI</span></code> uses the sums and differences of orbital energies with the SCF reference energy to produce spin pure expansion vectors. <code class="docutils literal"><span class="pre">LEININGER</span></code> approximation which subtracts the one-electron contribution from the orbital energies, multiplies by 0.5, and adds the one-electron contribution back in, producing spin pure expansion vectors and developed by Matt Leininger and works as well as <code class="docutils literal"><span class="pre">EVANGELISTI</span></code>.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: EVANGELISTI, HD_EXACT, HD_KAVE, ORB_ENER, LEININGER, Z_KAVE</li>
<li><strong>Default</strong>: EVANGELISTI</li>
</ul>
</dd>
<dt id="term-hd-otf-detci">HD_OTF (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Do compute the diagonal elements of the Hamiltonian matrix on-the-fly? Otherwise, a diagonal element vector is written to a separate file on disk.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-heff4-psimrcc">HEFF4 (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — Do include the fourth-order contributions to the effective Hamiltonian?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-heff-print-psimrcc">HEFF_PRINT (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — Do print the effective Hamiltonian?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-hess-type-dfocc">HESS_TYPE (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Type of the MO Hessian matrix</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF</li>
<li><strong>Default</strong>: HF</li>
</ul>
</dd>
<dt id="term-hess-update-optking">HESS_UPDATE (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Hessian update scheme</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NONE, BFGS, MS, POWELL, BOFILL</li>
<li><strong>Default</strong>: BFGS</li>
</ul>
</dd>
<dt id="term-hess-update-limit-optking">HESS_UPDATE_LIMIT (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Do limit the magnitude of changes caused by the Hessian update?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-hess-update-limit-max-optking">HESS_UPDATE_LIMIT_MAX (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — If <a class="reference internal" href="#term-hess-update-limit-optking"><span class="xref std std-term">HESS_UPDATE_LIMIT</span></a> is true, changes to the Hessian from the update are limited to the larger of <a class="reference internal" href="#term-hess-update-limit-scale-optking"><span class="xref std std-term">HESS_UPDATE_LIMIT_SCALE</span></a> * (the previous value) and HESS_UPDATE_LIMIT_MAX [au].</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.00</li>
</ul>
</dd>
<dt id="term-hess-update-limit-scale-optking">HESS_UPDATE_LIMIT_SCALE (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — If <a class="reference internal" href="#term-hess-update-limit-optking"><span class="xref std std-term">HESS_UPDATE_LIMIT</span></a> is true, changes to the Hessian from the update are limited to the larger of HESS_UPDATE_LIMIT_SCALE * (the previous value) and <a class="reference internal" href="#term-hess-update-limit-max-optking"><span class="xref std std-term">HESS_UPDATE_LIMIT_MAX</span></a> [au].</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.50</li>
</ul>
</dd>
<dt id="term-hess-update-use-last-optking">HESS_UPDATE_USE_LAST (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Number of previous steps to use in Hessian update, 0 uses all</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-hessian-write-findif">HESSIAN_WRITE (FINDIF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__findif.html#apdx-findif"><span class="std std-ref">FINDIF</span></a> — Do write a hessian output file? If so, the filename will end in .hess, and the prefix is determined by <a class="reference internal" href="#term-writer-file-label-globals"><span class="xref std std-term">WRITER_FILE_LABEL</span></a> (if set), or else by the name of the output file plus the name of the current molecule.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-icore-detci">ICORE (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if <a class="reference internal" href="#term-diag-method-detci"><span class="xref std std-term">DIAG_METHOD</span></a> = SEM), but require less core memory.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-ignore-tau-dcft">IGNORE_TAU (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> <strong>(Expert)</strong> — Controls whether to ignore terms containing non-idempotent contribution to OPDM or not (for debug puproses only). For practical applications only the default must be used</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-independent-j-type-cphf">INDEPENDENT_J_TYPE (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — JK Independent options</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: DIRECT_SCREENING</li>
<li><strong>Default</strong>: DIRECT_SCREENING</li>
</ul>
</dd>
<dt id="term-independent-j-type-scf">INDEPENDENT_J_TYPE (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — JK Independent options</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: DIRECT_SCREENING</li>
<li><strong>Default</strong>: DIRECT_SCREENING</li>
</ul>
</dd>
<dt id="term-intcos-generate-exit-optking">INTCOS_GENERATE_EXIT (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Do only generate the internal coordinates and then stop?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-integral-cutoff-dfocc">INTEGRAL_CUTOFF (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Cutoff value for DF integrals</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 9</li>
</ul>
</dd>
<dt id="term-integral-package-globals">INTEGRAL_PACKAGE (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — Integral package to use. If compiled with ERD or Simint support, change this option to use them; LibInt is used otherwise.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: ERD, LIBINT, SIMINT</li>
<li><strong>Default</strong>: LIBINT</li>
</ul>
</dd>
<dt id="term-interfrag-dist-inv-optking">INTERFRAG_DIST_INV (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Do use <span class="math">\(\frac{1}{R_{AB}}\)</span> for the stretching coordinate between fragments? Otherwise, use <span class="math">\(R_{AB}\)</span>.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-interfrag-hess-optking">INTERFRAG_HESS (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Model Hessian to guess interfragment force constants</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: DEFAULT, FISCHER_LIKE</li>
<li><strong>Default</strong>: DEFAULT</li>
</ul>
</dd>
<dt id="term-interfrag-mode-optking">INTERFRAG_MODE (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — When interfragment coordinates are present, use as reference points either principal axes or fixed linear combinations of atoms.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: FIXED, PRINCIPAL_AXES</li>
<li><strong>Default</strong>: FIXED</li>
</ul>
</dd>
<dt id="term-interfrag-step-limit-optking">INTERFRAG_STEP_LIMIT (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Maximum step size in bohr or radian along an interfragment coordinate</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.5</li>
</ul>
</dd>
<dt id="term-interfragment-connect-optking">INTERFRAGMENT_CONNECT (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — When connecting disparate fragments when frag_mode = SIMPLE, a &#8220;bond&#8221; is assigned if interatomic distance is less than (this number) * sum of covalent radii. The value is then increased until all the fragments are connected (directly or indirectly).</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.8</li>
</ul>
</dd>
<dt id="term-internal-rotations-mcscf">INTERNAL_ROTATIONS (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> — Do consider internal rotations?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-intrafrag-hess-optking">INTRAFRAG_HESS (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Model Hessian to guess intrafragment force constants</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: FISCHER, SCHLEGEL, SIMPLE, LINDH, LINDH_SIMPLE</li>
<li><strong>Default</strong>: SCHLEGEL</li>
</ul>
</dd>
<dt id="term-intrafrag-step-limit-optking">INTRAFRAG_STEP_LIMIT (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Initial maximum step size in bohr or radian along an internal coordinate</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.5</li>
</ul>
</dd>
<dt id="term-intrafrag-step-limit-max-optking">INTRAFRAG_STEP_LIMIT_MAX (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Upper bound for dynamic trust radius [au]</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.0</li>
</ul>
</dd>
<dt id="term-intrafrag-step-limit-min-optking">INTRAFRAG_STEP_LIMIT_MIN (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Lower bound for dynamic trust radius [au]</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.001</li>
</ul>
</dd>
<dt id="term-ints-tolerance-ccdensity">INTS_TOLERANCE (CCDENSITY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccdensity.html#apdx-ccdensity"><span class="std std-ref">CCDENSITY</span></a> — Minimum absolute value below which integrals are neglected.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-14</li>
</ul>
</dd>
<dt id="term-ints-tolerance-dcft">INTS_TOLERANCE (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> <strong>(Expert)</strong> — Minimum absolute value below which integrals are neglected</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-14</li>
</ul>
</dd>
<dt id="term-ints-tolerance-dfmp2">INTS_TOLERANCE (DFMP2)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfmp2.html#apdx-dfmp2"><span class="std std-ref">DFMP2</span></a> — Minimum absolute value below which integrals are neglected.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-ints-tolerance-fisapt">INTS_TOLERANCE (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — Minimum absolute value below which integrals are neglected.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-ints-tolerance-mrcc">INTS_TOLERANCE (MRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mrcc.html#apdx-mrcc"><span class="std std-ref">MRCC</span></a> — Minimum absolute value below which integrals are neglected.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1.0e-12</li>
</ul>
</dd>
<dt id="term-ints-tolerance-sapt">INTS_TOLERANCE (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn&#8217;t much to be gained from loosening it, especially for higher-order SAPT.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1.0e-12</li>
</ul>
</dd>
<dt id="term-ints-tolerance-scf">INTS_TOLERANCE (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Minimum absolute value below which TEI are neglected.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-ip-poles-occ">IP_POLES (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Do compute OCC poles for ionization potentials? Only valid OMP2.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-irc-direction-optking">IRC_DIRECTION (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — IRC mapping direction</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: FORWARD, BACKWARD</li>
<li><strong>Default</strong>: FORWARD</li>
</ul>
</dd>
<dt id="term-irc-step-size-optking">IRC_STEP_SIZE (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — IRC step size in bohr(amu)<span class="math">\(^{1/2}\)</span>.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.2</li>
</ul>
</dd>
<dt id="term-irc-stop-optking">IRC_STOP (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Decide when to stop IRC calculations</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: ASK, STOP, GO</li>
<li><strong>Default</strong>: STOP</li>
</ul>
</dd>
<dt id="term-istop-detci">ISTOP (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Do stop DETCI after string information is formed and before integrals are read?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-jobtype-cclambda">JOBTYPE (CCLAMBDA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cclambda.html#apdx-cclambda"><span class="std std-ref">CCLAMBDA</span></a> <strong>(Expert)</strong> — Type of job being performed</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-keep-intcos-optking">KEEP_INTCOS (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Keep internal coordinate definition file.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-level-shift-dfocc">LEVEL_SHIFT (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Level shift to aid convergence</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.02</li>
</ul>
</dd>
<dt id="term-level-shift-mcscf">LEVEL_SHIFT (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> — Level shift to aid convergence</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-level-shift-occ">LEVEL_SHIFT (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Level shift to aid convergence</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.02</li>
</ul>
</dd>
<dt id="term-linear-ccresponse">LINEAR (CCRESPONSE)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccresponse.html#apdx-ccresponse"><span class="std std-ref">CCRESPONSE</span></a> — Do Bartlett size-extensive linear model?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-lineq-solver-dfocc">LINEQ_SOLVER (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — The solver will be used for simultaneous linear equations.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: CDGESV, FLIN, POPLE</li>
<li><strong>Default</strong>: CDGESV</li>
</ul>
</dd>
<dt id="term-lineq-solver-occ">LINEQ_SOLVER (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — The solver will be used for simultaneous linear equations.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: CDGESV, FLIN, POPLE</li>
<li><strong>Default</strong>: CDGESV</li>
</ul>
</dd>
<dt id="term-linesearch-static-max-optking">LINESEARCH_STATIC_MAX (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — If doing a static line search, this fixes the largest step, whose largest change in an internal coordinate is set to this value (in au)</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.100</li>
</ul>
</dd>
<dt id="term-linesearch-static-min-optking">LINESEARCH_STATIC_MIN (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — If doing a static line search, this fixes the shortest step, whose largest change in an internal coordinate is set to this value (in au)</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.001</li>
</ul>
</dd>
<dt id="term-linesearch-static-n-optking">LINESEARCH_STATIC_N (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — If doing a static line search, scan this many points.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 8</li>
</ul>
</dd>
<dt id="term-literal-cfour-globals">LITERAL_CFOUR (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — Text to be passed directly into CFOUR input files. May contain molecule, options, percent blocks, etc. Access through <code class="docutils literal"><span class="pre">cfour</span> <span class="pre">{...}</span></code> block.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-local-ccenergy">LOCAL (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Do simulate the effects of local correlation techniques?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-local-cceom">LOCAL (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Do simulate the effects of local correlation techniques?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-local-cclambda">LOCAL (CCLAMBDA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cclambda.html#apdx-cclambda"><span class="std std-ref">CCLAMBDA</span></a> — Do simulate the effects of local correlation techniques?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-local-ccresponse">LOCAL (CCRESPONSE)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccresponse.html#apdx-ccresponse"><span class="std std-ref">CCRESPONSE</span></a> — Do simulate local correlation?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-local-convergence-fisapt">LOCAL_CONVERGENCE (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — Relative convergence in orbital localization</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1.0e-12</li>
</ul>
</dd>
<dt id="term-local-convergence-scf">LOCAL_CONVERGENCE (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — The convergence on the orbital localization procedure</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-12</li>
</ul>
</dd>
<dt id="term-local-cphf-cutoff-ccenergy">LOCAL_CPHF_CUTOFF (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Cutoff value for local-coupled-perturbed-Hartree-Fock</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.10</li>
</ul>
</dd>
<dt id="term-local-cphf-cutoff-cclambda">LOCAL_CPHF_CUTOFF (CCLAMBDA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cclambda.html#apdx-cclambda"><span class="std std-ref">CCLAMBDA</span></a> — Cutoff value for local-coupled-perturbed-Hartree-Fock</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.10</li>
</ul>
</dd>
<dt id="term-local-cphf-cutoff-ccresponse">LOCAL_CPHF_CUTOFF (CCRESPONSE)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccresponse.html#apdx-ccresponse"><span class="std std-ref">CCRESPONSE</span></a> — Cutoff value for local-coupled-perturbed-Hartree-Fock</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.10</li>
</ul>
</dd>
<dt id="term-local-cutoff-ccenergy">LOCAL_CUTOFF (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996).</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.02</li>
</ul>
</dd>
<dt id="term-local-cutoff-cceom">LOCAL_CUTOFF (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996).</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.02</li>
</ul>
</dd>
<dt id="term-local-cutoff-cclambda">LOCAL_CUTOFF (CCLAMBDA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cclambda.html#apdx-cclambda"><span class="std std-ref">CCLAMBDA</span></a> — Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996).</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.02</li>
</ul>
</dd>
<dt id="term-local-cutoff-ccresponse">LOCAL_CUTOFF (CCRESPONSE)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccresponse.html#apdx-ccresponse"><span class="std std-ref">CCRESPONSE</span></a> — Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996).</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.01</li>
</ul>
</dd>
<dt id="term-local-do-singles-cceom">LOCAL_DO_SINGLES (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> —</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-local-filter-singles-cceom">LOCAL_FILTER_SINGLES (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Do apply local filtering to singles amplitudes?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-local-filter-singles-cclambda">LOCAL_FILTER_SINGLES (CCLAMBDA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cclambda.html#apdx-cclambda"><span class="std std-ref">CCLAMBDA</span></a> — Do apply local filtering to single de-excitation (<span class="math">\(\lambda 1\)</span> amplitudes?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-local-filter-singles-ccresponse">LOCAL_FILTER_SINGLES (CCRESPONSE)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccresponse.html#apdx-ccresponse"><span class="std std-ref">CCRESPONSE</span></a> — Do apply local filtering to single excitation amplitudes?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-local-ghost-cceom">LOCAL_GHOST (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Permit ghost atoms to hold projected atomic orbitals to include in the virtual space in local-EOM-CCSD calculations</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: -1</li>
</ul>
</dd>
<dt id="term-local-ibo-condition-fisapt">LOCAL_IBO_CONDITION (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> <strong>(Expert)</strong> — Condition number to use in IBO metric inversions</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.0e-7</li>
</ul>
</dd>
<dt id="term-local-ibo-power-fisapt">LOCAL_IBO_POWER (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — IBO localization metric power</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 4</li>
</ul>
</dd>
<dt id="term-local-ibo-stars-fisapt">LOCAL_IBO_STARS (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — IBO Centers for Pi Degeneracy</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-local-ibo-stars-completeness-fisapt">LOCAL_IBO_STARS_COMPLETENESS (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — IBO Charge metric for classification as Pi</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.90</li>
</ul>
</dd>
<dt id="term-local-ibo-use-stars-fisapt">LOCAL_IBO_USE_STARS (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — IBO Stars procedure</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-local-maxiter-fisapt">LOCAL_MAXITER (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — Maximum iterations in localization</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1000</li>
</ul>
</dd>
<dt id="term-local-maxiter-scf">LOCAL_MAXITER (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — The maxiter on the orbital localization procedure</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 200</li>
</ul>
</dd>
<dt id="term-local-method-ccenergy">LOCAL_METHOD (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Type of local-CCSD scheme to be simulated. <code class="docutils literal"><span class="pre">WERNER</span></code> selects the method developed by H.-J. Werner and co-workers, and <code class="docutils literal"><span class="pre">AOBASIS</span></code> selects the method developed by G.E. Scuseria and co-workers (currently inoperative).</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: WERNER, AOBASIS</li>
<li><strong>Default</strong>: WERNER</li>
</ul>
</dd>
<dt id="term-local-method-cceom">LOCAL_METHOD (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Type of local-CCSD scheme to be simulated. <code class="docutils literal"><span class="pre">WERNER</span></code> selects the method developed by H.-J. Werner and co-workers, and <code class="docutils literal"><span class="pre">AOBASIS</span></code> selects the method developed by G.E. Scuseria and co-workers (currently inoperative).</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: WERNER, AOBASIS</li>
<li><strong>Default</strong>: WERNER</li>
</ul>
</dd>
<dt id="term-local-method-cclambda">LOCAL_METHOD (CCLAMBDA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cclambda.html#apdx-cclambda"><span class="std std-ref">CCLAMBDA</span></a> — Type of local-CCSD scheme to be simulated. <code class="docutils literal"><span class="pre">WERNER</span></code> (unique available option) selects the method developed by H.-J. Werner and co-workers.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: WERNER</li>
</ul>
</dd>
<dt id="term-local-method-ccresponse">LOCAL_METHOD (CCRESPONSE)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccresponse.html#apdx-ccresponse"><span class="std std-ref">CCRESPONSE</span></a> — Type of local-CCSD scheme to be simulated. <code class="docutils literal"><span class="pre">WERNER</span></code> (unique available option) selects the method developed by H.-J. Werner and co-workers.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: WERNER</li>
</ul>
</dd>
<dt id="term-local-pairdef-ccenergy">LOCAL_PAIRDEF (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Definition of local pair domains, default is BP, Boughton-Pulay.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: BP, RESPONSE</li>
<li><strong>Default</strong>: BP</li>
</ul>
</dd>
<dt id="term-local-pairdef-cclambda">LOCAL_PAIRDEF (CCLAMBDA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cclambda.html#apdx-cclambda"><span class="std std-ref">CCLAMBDA</span></a> — Definition of local pair domains</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-local-pairdef-ccresponse">LOCAL_PAIRDEF (CCRESPONSE)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccresponse.html#apdx-ccresponse"><span class="std std-ref">CCRESPONSE</span></a> — Definition of local pair domains</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: NONE</li>
</ul>
</dd>
<dt id="term-local-preconditioner-cceom">LOCAL_PRECONDITIONER (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Preconditioner will be used in local CC computations</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: HBAR, FOCK</li>
<li><strong>Default</strong>: HBAR</li>
</ul>
</dd>
<dt id="term-local-use-ghosts-fisapt">LOCAL_USE_GHOSTS (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> <strong>(Expert)</strong> — Use ghost atoms in Pipek-Mezey or IBO metric</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-local-weakp-ccenergy">LOCAL_WEAKP (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Desired treatment of &#8220;weak pairs&#8221; in the local-CCSD method. A value of <code class="docutils literal"><span class="pre">NEGLECT</span></code> ignores weak pairs entirely. A value of <code class="docutils literal"><span class="pre">NONE</span></code> treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NONE, NEGLECT, MP2</li>
<li><strong>Default</strong>: NONE</li>
</ul>
</dd>
<dt id="term-local-weakp-cceom">LOCAL_WEAKP (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Desired treatment of &#8220;weak pairs&#8221; in the local-CCSD method. A value of <code class="docutils literal"><span class="pre">NEGLECT</span></code> ignores weak pairs entirely. A value of <code class="docutils literal"><span class="pre">NONE</span></code> treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NONE, MP2, NEGLECT</li>
<li><strong>Default</strong>: NONE</li>
</ul>
</dd>
<dt id="term-local-weakp-cclambda">LOCAL_WEAKP (CCLAMBDA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cclambda.html#apdx-cclambda"><span class="std std-ref">CCLAMBDA</span></a> — Desired treatment of &#8220;weak pairs&#8221; in the local-CCSD method. The value of <code class="docutils literal"><span class="pre">NONE</span></code> (unique available option) treats weak pairs in the same manner as strong pairs.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: NONE</li>
</ul>
</dd>
<dt id="term-local-weakp-ccresponse">LOCAL_WEAKP (CCRESPONSE)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccresponse.html#apdx-ccresponse"><span class="std std-ref">CCRESPONSE</span></a> — Desired treatment of &#8220;weak pairs&#8221; in the local-CCSD method. The value of <code class="docutils literal"><span class="pre">NONE</span></code> (unique available option) treats weak pairs in the same manner as strong pairs.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: NONE</li>
</ul>
</dd>
<dt id="term-lock-singlet-psimrcc">LOCK_SINGLET (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — Do lock onto a singlet root?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-lse-detci">LSE (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Do use least-squares extrapolation in iterative solution of CI vector?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-lse-collapse-detci">LSE_COLLAPSE (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Number of iterations between least-squares extrapolations</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 3</li>
</ul>
</dd>
<dt id="term-lse-tolerance-detci">LSE_TOLERANCE (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Minimum converged energy for least-squares extrapolation to be performed</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 3</li>
</ul>
</dd>
<dt id="term-madmp2-sleep-dfmp2">MADMP2_SLEEP (DFMP2)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfmp2.html#apdx-dfmp2"><span class="std std-ref">DFMP2</span></a> <strong>(Expert)</strong> — A helpful option, used only in debugging the MADNESS version</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-mat-num-column-print-globals">MAT_NUM_COLUMN_PRINT (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> <strong>(Expert)</strong> — Number of columns to print in calls to <code class="docutils literal"><span class="pre">Matrix::print_mat</span></code>.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 5</li>
</ul>
</dd>
<dt id="term-max-attempts-scf">MAX_ATTEMPTS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — When using <a class="reference internal" href="#term-stability-analysis-scf"><span class="xref std std-term">STABILITY_ANALYSIS</span></a> <code class="docutils literal"><span class="pre">FOLLOW</span></code>, maximum number of orbital optimization attempts to make the wavefunction stable.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-max-ccd-diisvecs-sapt">MAX_CCD_DIISVECS (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — Maximum number of vectors used in CCD-DIIS</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 10</li>
</ul>
</dd>
<dt id="term-max-disp-g-convergence-optking">MAX_DISP_G_CONVERGENCE (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units).</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1.2e-3</li>
</ul>
</dd>
<dt id="term-max-energy-g-convergence-optking">MAX_ENERGY_G_CONVERGENCE (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Convergence criterion for geometry optmization: maximum energy change.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1.0e-6</li>
</ul>
</dd>
<dt id="term-max-force-g-convergence-optking">MAX_FORCE_G_CONVERGENCE (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Convergence criterion for geometry optmization: maximum force (internal coordinates, atomic units).</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 3.0e-4</li>
</ul>
</dd>
<dt id="term-max-mem-buf-scf">MAX_MEM_BUF (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Max memory per buf for PK algo REORDER, for debug and tuning</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-max-mograd-convergence-dfocc">MAX_MOGRAD_CONVERGENCE (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Convergence criterion for maximum orbital gradient</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-3</li>
</ul>
</dd>
<dt id="term-max-mograd-convergence-occ">MAX_MOGRAD_CONVERGENCE (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Convergence criterion for maximum orbital gradient</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-3</li>
</ul>
</dd>
<dt id="term-max-num-vecs-detci">MAX_NUM_VECS (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Maximum number of Davidson subspace vectors which can be held on disk for the CI coefficient and sigma vectors. (There is one H(diag) vector and the number of D vectors is equal to the number of roots). When the number of vectors on disk reaches the value of MAX_NUM_VECS, the Davidson subspace will be collapsed to <a class="reference internal" href="#term-collapse-size-detci"><span class="xref std std-term">COLLAPSE_SIZE</span></a> vectors for each root. This is very helpful for saving disk space. Defaults to <a class="reference internal" href="#term-ci-maxiter-detci"><span class="xref std std-term">CI_MAXITER</span></a> * <a class="reference internal" href="#term-num-roots-detci"><span class="xref std std-term">NUM_ROOTS</span></a> + <a class="reference internal" href="#term-num-init-vecs-detci"><span class="xref std std-term">NUM_INIT_VECS</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-maxiter-ccenergy">MAXITER (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Maximum number of iterations to solve the CC equations</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 50</li>
</ul>
</dd>
<dt id="term-maxiter-cceom">MAXITER (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Maximum number of iterations</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 80</li>
</ul>
</dd>
<dt id="term-maxiter-cclambda">MAXITER (CCLAMBDA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cclambda.html#apdx-cclambda"><span class="std std-ref">CCLAMBDA</span></a> — Maximum number of iterations</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 50</li>
</ul>
</dd>
<dt id="term-maxiter-ccresponse">MAXITER (CCRESPONSE)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccresponse.html#apdx-ccresponse"><span class="std std-ref">CCRESPONSE</span></a> — Maximum number of iterations to converge perturbed amplitude equations</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 50</li>
</ul>
</dd>
<dt id="term-maxiter-dcft">MAXITER (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> — Maximum number of macro- or micro-iterations for both energy and response equations</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 40</li>
</ul>
</dd>
<dt id="term-maxiter-fisapt">MAXITER (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — Maximum number of iterations for CPHF</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 50</li>
</ul>
</dd>
<dt id="term-maxiter-fnocc">MAXITER (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> — Maximum number of CC iterations</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 100</li>
</ul>
</dd>
<dt id="term-maxiter-mcscf">MAXITER (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> — Maximum number of iterations</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 100</li>
</ul>
</dd>
<dt id="term-maxiter-psimrcc">MAXITER (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — Maximum number of iterations to determine the amplitudes</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 100</li>
</ul>
</dd>
<dt id="term-maxiter-sapt">MAXITER (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — Maximum number of CPHF iterations</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 50</li>
</ul>
</dd>
<dt id="term-maxiter-scf">MAXITER (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Maximum number of iterations. <strong>Cfour Interface:</strong> Keyword translates into <a class="reference internal" href="#term-cfour-scf-maxcyc-cfour"><span class="xref std std-term">CFOUR_SCF_MAXCYC</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 100</li>
</ul>
</dd>
<dt id="term-mcscf-algorithm-detci">MCSCF_ALGORITHM (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Convergence algorithm to utilize. Two-Step, Augmented Hessian, or One-Step. Defaults to TS for RASSCF.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: TS, AH</li>
<li><strong>Default</strong>: TS</li>
</ul>
</dd>
<dt id="term-mcscf-diis-error-type-detci">MCSCF_DIIS_ERROR_TYPE (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — DIIS error vector type either, the AO orbital gradient or the orbital rotation update matrix</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: GRAD, UPDATE</li>
<li><strong>Default</strong>: GRAD</li>
</ul>
</dd>
<dt id="term-mcscf-diis-freq-detci">MCSCF_DIIS_FREQ (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — How often to do a DIIS extrapolation for TS convergence</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-mcscf-diis-max-vecs-detci">MCSCF_DIIS_MAX_VECS (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Maximum number of DIIS vectors for TS convergence</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 8</li>
</ul>
</dd>
<dt id="term-mcscf-diis-start-detci">MCSCF_DIIS_START (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Iteration to turn on DIIS for TS convergence</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 3</li>
</ul>
</dd>
<dt id="term-mcscf-e-convergence-detci">MCSCF_E_CONVERGENCE (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Convergence criterion for energy. See Table <a class="reference internal" href="scf.html#table-conv-corl"><span class="std std-ref">Post-SCF Convergence</span></a> for default convergence criteria for different calculation types.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-7</li>
</ul>
</dd>
<dt id="term-mcscf-guess-detci">MCSCF_GUESS (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Initial MCSCF starting guess, MP2 natural orbitals only available for DF-RHF reference</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: MP2, SCF</li>
<li><strong>Default</strong>: SCF</li>
</ul>
</dd>
<dt id="term-mcscf-max-rot-detci">MCSCF_MAX_ROT (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Maximum value in the rotation matrix. If a value is greater than this number all values are scaled.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.5</li>
</ul>
</dd>
<dt id="term-mcscf-maxiter-detci">MCSCF_MAXITER (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Maximum number MCSCF of iterations</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 30</li>
</ul>
</dd>
<dt id="term-mcscf-r-convergence-detci">MCSCF_R_CONVERGENCE (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Convergence criterion for the RMS of the orbital gradient</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-5</li>
</ul>
</dd>
<dt id="term-mcscf-rotate-detci">MCSCF_ROTATE (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Apply a list of 2x2 rotation matrices to the orbitals in the form of [irrep, orbital1, orbital2, theta] where an angle of 0 would do nothing and an angle of 90 would switch the two orbitals.</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-mcscf-so-start-e-detci">MCSCF_SO_START_E (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Start second-order (AH or OS) orbital-orbital MCSCF based on energy convergence</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1e-4</li>
</ul>
</dd>
<dt id="term-mcscf-so-start-grad-detci">MCSCF_SO_START_GRAD (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Start second-order (AH or OS) orbital-orbital MCSCF based on RMS of orbital gradient</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1e-4</li>
</ul>
</dd>
<dt id="term-mcscf-type-detci">MCSCF_TYPE (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Method to handle the two-electron integrals</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: DF, CONV, AO</li>
<li><strong>Default</strong>: CONV</li>
</ul>
</dd>
<dt id="term-memory-adc">MEMORY (ADC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__adc.html#apdx-adc"><span class="std std-ref">ADC</span></a> — The amount of memory available (in Mb)</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1000</li>
</ul>
</dd>
<dt id="term-min-ccd-diisvecs-sapt">MIN_CCD_DIISVECS (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — Minimum number of vectors used in CCD-DIIS</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 4</li>
</ul>
</dd>
<dt id="term-minao-basis-fisapt">MINAO_BASIS (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> <strong>(Expert)</strong> — MinAO Basis for IBO</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: CC-PVTZ-MINAO</li>
</ul>
</dd>
<dt id="term-mixed-detci">MIXED (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Do allow &#8220;mixed&#8221; RAS II/RAS III excitations into the CI space? If FALSE, then if there are any electrons in RAS III, then the number of holes in RAS I cannot exceed the given excitation level <a class="reference internal" href="#term-ex-level-detci"><span class="xref std std-term">EX_LEVEL</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-mixed4-detci">MIXED4 (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Do allow &#8220;mixed&#8221; excitations involving RAS IV into the CI space. Useful to specify a split-virtual CISD[TQ] computation. If FALSE, then if there are any electrons in RAS IV, then the number of holes in RAS I cannot exceed the given excitation level <a class="reference internal" href="#term-ex-level-detci"><span class="xref std std-term">EX_LEVEL</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-mo-diis-num-vecs-dfocc">MO_DIIS_NUM_VECS (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Number of vectors used in orbital DIIS</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 6</li>
</ul>
</dd>
<dt id="term-mo-diis-num-vecs-occ">MO_DIIS_NUM_VECS (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Number of vectors used in orbital DIIS</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 6</li>
</ul>
</dd>
<dt id="term-mo-maxiter-dfocc">MO_MAXITER (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Maximum number of iterations to determine the orbitals</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 50</li>
</ul>
</dd>
<dt id="term-mo-maxiter-occ">MO_MAXITER (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Maximum number of iterations to determine the orbitals</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 50</li>
</ul>
</dd>
<dt id="term-mo-read-mcscf">MO_READ (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> — Do read in from file the MOs from a previous computation?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-mo-read-occ">MO_READ (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-mo-relax-dcft">MO_RELAX (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> <strong>(Expert)</strong> — Controls whether to relax the orbitals during the energy computation or not (for debug puproses only). For practical applications only the default must be used</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-mo-step-max-dfocc">MO_STEP_MAX (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Maximum step size in orbital-optimization procedure</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.5</li>
</ul>
</dd>
<dt id="term-mo-step-max-occ">MO_STEP_MAX (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Maximum step size in orbital-optimization procedure</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.5</li>
</ul>
</dd>
<dt id="term-mo-write-occ">MO_WRITE (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Do write coefficient matrices to external files for direct reading MOs in a subsequent job?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-module-cphf">MODULE (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — What app to test?</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: RCIS, RCPHF, RTDHF, RCPKS, RTDA, RTDDFT</li>
<li><strong>Default</strong>: RCIS</li>
</ul>
</dd>
<dt id="term-mograd-damping-occ">MOGRAD_DAMPING (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Damping factor for the orbital gradient (Rendell et al., JCP, vol. 87, pp. 5976, 1987)</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.0</li>
</ul>
</dd>
<dt id="term-molden-with-virtual-globals">MOLDEN_WITH_VIRTUAL (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — Write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs (false).</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-molden-write-dcft">MOLDEN_WRITE (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> — Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by <a class="reference internal" href="#term-writer-file-label-globals"><span class="xref std std-term">WRITER_FILE_LABEL</span></a> (if set), or else by the name of the output file plus the name of the current molecule.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-molden-write-dfocc">MOLDEN_WRITE (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by <a class="reference internal" href="#term-writer-file-label-globals"><span class="xref std std-term">WRITER_FILE_LABEL</span></a> (if set), or else by the name of the output file plus the name of the current molecule.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-molden-write-scf">MOLDEN_WRITE (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by <a class="reference internal" href="#term-writer-file-label-globals"><span class="xref std std-term">WRITER_FILE_LABEL</span></a> (if set), or else by the name of the output file plus the name of the current molecule.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-mom-occ-scf">MOM_OCC (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta)</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-mom-start-scf">MOM_START (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — The iteration to start MOM on (or 0 for no MOM)</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-mom-vir-scf">MOM_VIR (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta)</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-mp2-amp-type-dfocc">MP2_AMP_TYPE (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — The algorithm that used to handle mp2 amplitudes. The DIRECT option means compute amplitudes on the fly whenever they are necessary.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: DIRECT, CONV</li>
<li><strong>Default</strong>: DIRECT</li>
</ul>
</dd>
<dt id="term-mp2-amps-print-ccenergy">MP2_AMPS_PRINT (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Do print the MP2 amplitudes which are the starting guesses for RHF and UHF reference functions?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-mp2-ccsd-method-psimrcc">MP2_CCSD_METHOD (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — How to perform MP2_CCSD computations</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: I, IA, II</li>
<li><strong>Default</strong>: II</li>
</ul>
</dd>
<dt id="term-mp2-guess-psimrcc">MP2_GUESS (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — Do start from a MP2 guess?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-mp2-os-scale-ccenergy">MP2_OS_SCALE (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — MP2 opposite-spin scaling value</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.20</li>
</ul>
</dd>
<dt id="term-mp2-os-scale-dfmp2">MP2_OS_SCALE (DFMP2)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfmp2.html#apdx-dfmp2"><span class="std std-ref">DFMP2</span></a> — OS Scale</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 6.0/5.0</li>
</ul>
</dd>
<dt id="term-mp2-os-scale-dfocc">MP2_OS_SCALE (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — MP2 opposite-spin scaling value</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 6.0/5.0</li>
</ul>
</dd>
<dt id="term-mp2-os-scale-occ">MP2_OS_SCALE (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — MP2 opposite-spin scaling value</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 6.0/5.0</li>
</ul>
</dd>
<dt id="term-mp2-scale-os-fnocc">MP2_SCALE_OS (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> — Opposite-spin scaling factor for SCS-MP2</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.20</li>
</ul>
</dd>
<dt id="term-mp2-scale-ss-fnocc">MP2_SCALE_SS (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> — Same-spin scaling factor for SCS-MP2</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.0/3.0</li>
</ul>
</dd>
<dt id="term-mp2-sos-scale-dfocc">MP2_SOS_SCALE (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — MP2 Spin-opposite scaling (SOS) value</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.3</li>
</ul>
</dd>
<dt id="term-mp2-sos-scale-occ">MP2_SOS_SCALE (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — MP2 Spin-opposite scaling (SOS) value</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.3</li>
</ul>
</dd>
<dt id="term-mp2-sos-scale2-dfocc">MP2_SOS_SCALE2 (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Spin-opposite scaling (SOS) value for optimized-MP2 orbitals</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.2</li>
</ul>
</dd>
<dt id="term-mp2-sos-scale2-occ">MP2_SOS_SCALE2 (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Spin-opposite scaling (SOS) value for optimized-MP2 orbitals</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.2</li>
</ul>
</dd>
<dt id="term-mp2-ss-scale-ccenergy">MP2_SS_SCALE (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — MP2 same-spin scaling value</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.0/3.0</li>
</ul>
</dd>
<dt id="term-mp2-ss-scale-dfmp2">MP2_SS_SCALE (DFMP2)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfmp2.html#apdx-dfmp2"><span class="std std-ref">DFMP2</span></a> — SS Scale</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.0/3.0</li>
</ul>
</dd>
<dt id="term-mp2-ss-scale-dfocc">MP2_SS_SCALE (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — MP2 same-spin scaling value</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.0/3.0</li>
</ul>
</dd>
<dt id="term-mp2-ss-scale-occ">MP2_SS_SCALE (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — MP2 same-spin scaling value</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.0/3.0</li>
</ul>
</dd>
<dt id="term-mp2-type-globals">MP2_TYPE (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — Algorithm to use for MP2 computation. See <a class="reference internal" href="notes_c.html#table-managedmethods"><span class="std std-ref">Cross-module Redundancies</span></a> for details.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: DF, CONV, CD</li>
<li><strong>Default</strong>: DF</li>
</ul>
</dd>
<dt id="term-mp-type-globals">MP_TYPE (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — Algorithm to use for MPn ( <span class="math">\(n&gt;2\)</span> ) computation (e.g., MP3 or MP2.5 or MP4(SDQ)). See <a class="reference internal" href="notes_c.html#table-managedmethods"><span class="std std-ref">Cross-module Redundancies</span></a> for details.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: DF, CONV, CD</li>
<li><strong>Default</strong>: CONV</li>
</ul>
</dd>
<dt id="term-mpn-detci">MPN (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Do compute the MPn series out to kth order where k is determined by <a class="reference internal" href="#term-max-num-vecs-detci"><span class="xref std std-term">MAX_NUM_VECS</span></a> ? For open-shell systems (<a class="reference internal" href="#term-reference-detci"><span class="xref std std-term">REFERENCE</span></a> is ROHF, <a class="reference internal" href="#term-wfn-detci"><span class="xref std std-term">WFN</span></a> is ZAPTN), DETCI will compute the ZAPTn series. <a class="reference internal" href="#term-guess-vector-detci"><span class="xref std std-term">GUESS_VECTOR</span></a> must be set to UNIT, <a class="reference internal" href="#term-hd-otf-detci"><span class="xref std std-term">HD_OTF</span></a> must be set to TRUE, and <a class="reference internal" href="#term-hd-avg-detci"><span class="xref std std-term">HD_AVG</span></a> must be set to orb_ener; these should happen by default for MPN = TRUE.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-mpn-order-save-detci">MPN_ORDER_SAVE (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — If 0, save the MPn energy; if 1, save the MP(2n-1) energy (if available from <a class="reference internal" href="#term-mpn-wigner-detci"><span class="xref std std-term">MPN_WIGNER</span></a> = true); if 2, save the MP(2n-2) energy (if available from <a class="reference internal" href="#term-mpn-wigner-detci"><span class="xref std std-term">MPN_WIGNER</span></a> = true).</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-mpn-schmidt-detci">MPN_SCHMIDT (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Do employ an orthonormal vector space rather than storing the kth order wavefunction?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-mpn-wigner-detci">MPN_WIGNER (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Do use Wigner formulas in the <span class="math">\(E_{text{mp}n}\)</span> series?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-mrcc-level-mrcc">MRCC_LEVEL (MRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mrcc.html#apdx-mrcc"><span class="std std-ref">MRCC</span></a> — Maximum excitation level. This is used ONLY if it is explicitly set by the user. Single-reference case: all excitations up to this level are included, e.g., 2 for CCSD, 3 for CCSDT, 4 for CCSDTQ, etc. This becomes <code class="docutils literal"><span class="pre">ex.lev</span></code> (option #1) in fort.56.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-mrcc-method-mrcc">MRCC_METHOD (MRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mrcc.html#apdx-mrcc"><span class="std std-ref">MRCC</span></a> <strong>(Expert)</strong> — If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with <code class="xref py py-func docutils literal"><span class="pre">energy()</span></code>. This becomes <code class="docutils literal"><span class="pre">CC/CI</span></code> (option #5) in fort.56. See Table <a class="reference internal" href="mrcc.html#table-mrcc-mrcc-method"><span class="std std-ref">MRCC_METHOD</span></a> for details.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-mrcc-num-doublet-roots-mrcc">MRCC_NUM_DOUBLET_ROOTS (MRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mrcc.html#apdx-mrcc"><span class="std std-ref">MRCC</span></a> — Number of root in case of open shell system. This becomes <code class="docutils literal"><span class="pre">ndoub</span></code> (option #13) int fort.56.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-mrcc-num-singlet-roots-mrcc">MRCC_NUM_SINGLET_ROOTS (MRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mrcc.html#apdx-mrcc"><span class="std std-ref">MRCC</span></a> — Number of singlet roots. (Strictly speaking number of of roots with M_s=0 and S is even.) Use this option only with closed shell reference determinant, it must be zero otherwise. This becomes <code class="docutils literal"><span class="pre">nsing</span></code> (option #2) in fort.56.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-mrcc-num-triplet-roots-mrcc">MRCC_NUM_TRIPLET_ROOTS (MRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mrcc.html#apdx-mrcc"><span class="std std-ref">MRCC</span></a> — Number of triplet roots. (Strictly speaking number of of roots with <span class="math">\(M_s=0\)</span> and S is odd.) See notes at option <a class="reference internal" href="#term-mrcc-num-singlet-roots-mrcc"><span class="xref std std-term">MRCC_NUM_SINGLET_ROOTS</span></a>. This becomes <code class="docutils literal"><span class="pre">ntrip</span></code> (option #3) in fort.56.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-mrcc-omp-num-threads-mrcc">MRCC_OMP_NUM_THREADS (MRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mrcc.html#apdx-mrcc"><span class="std std-ref">MRCC</span></a> <strong>(Expert)</strong> — Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable <span class="target" id="index-1"></span><a class="reference internal" href="external.html#envvar-OMP_NUM_THREADS"><code class="xref std std-envvar docutils literal"><span class="pre">OMP_NUM_THREADS</span></code></a> is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the <code class="docutils literal"><span class="pre">-n</span></code> command-line option described in section <a class="reference internal" href="external.html#sec-threading"><span class="std std-ref">Threading</span></a> does not affect MRCC.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-mrcc-restart-mrcc">MRCC_RESTART (MRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mrcc.html#apdx-mrcc"><span class="std std-ref">MRCC</span></a> <strong>(Expert)</strong> — The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes <code class="docutils literal"><span class="pre">rest</span></code> (option #4) in fort.56.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-ms0-detci">MS0 (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Do use the <span class="math">\(M_s = 0\)</span> component of the state? Defaults to TRUE if closed-shell and FALSE otherwise. Related to the <a class="reference internal" href="#term-s-detci"><span class="xref std std-term">S</span></a> option.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-nat-orbs-detci">NAT_ORBS (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Do compute natural orbitals?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-nat-orbs-dfocc">NAT_ORBS (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Do compute natural orbitals?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-nat-orbs-fnocc">NAT_ORBS (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> — Do use MP2 NOs to truncate virtual space for QCISD/CCSD and (T)?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-nat-orbs-occ">NAT_ORBS (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Do compute natural orbitals?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-nat-orbs-t2-sapt">NAT_ORBS_T2 (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — Do use MP2 natural orbital approximations for the <span class="math">\(v^4\)</span> block of two-electron integrals in the evaluation of second-order T2 amplitudes? Recommended true for all SAPT computations.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-nat-orbs-t3-sapt">NAT_ORBS_T3 (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-nat-orbs-v4-sapt">NAT_ORBS_V4 (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — Do use MP2 natural orbital approximations for the <span class="math">\(v^4\)</span> block of two-electron integrals in the evaluation of CCD T2 amplitudes? Recommended true for all SAPT computations.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-new-triples-ccenergy">NEW_TRIPLES (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Do use new triples?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-new-triples-cceom">NEW_TRIPLES (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Do use new triples?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-newton-convergence-adc">NEWTON_CONVERGENCE (ADC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__adc.html#apdx-adc"><span class="std std-ref">ADC</span></a> — The convergence criterion for pole searching step.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-7</li>
</ul>
</dd>
<dt id="term-no-dfile-detci">NO_DFILE (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Do use the last vector space in the BVEC file to write scratch DVEC rather than using a separate DVEC file? (Only possible if <a class="reference internal" href="#term-num-roots-detci"><span class="xref std std-term">NUM_ROOTS</span></a> = 1.)</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-no-response-sapt">NO_RESPONSE (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — Don&#8217;t solve the CPHF equations? Evaluate <span class="math">\(E_{ind}^{(20)}\)</span> and <span class="math">\(E_{exch-ind}^{(20)}\)</span> instead of their response-including counterparts. Only turn on this option if the induction energy is not going to be used.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-no-singles-psimrcc">NO_SINGLES (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — Do disregard updating single excitation amplitudes?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-norm-tolerance-adc">NORM_TOLERANCE (ADC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__adc.html#apdx-adc"><span class="std std-ref">ADC</span></a> — The cutoff norm of residual vector in SEM step.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-6</li>
</ul>
</dd>
<dt id="term-normal-modes-write-findif">NORMAL_MODES_WRITE (FINDIF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__findif.html#apdx-findif"><span class="std std-ref">FINDIF</span></a> — Do write a file containing the normal modes in Molden format? If so, the filename will end in .molden_normal_modes, and the prefix is determined by <a class="reference internal" href="#term-writer-file-label-globals"><span class="xref std std-term">WRITER_FILE_LABEL</span></a> (if set), or else by the name of the output file plus the name of the current molecule.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-num-amps-print-adc">NUM_AMPS_PRINT (ADC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__adc.html#apdx-adc"><span class="std std-ref">ADC</span></a> — Number of components of transition amplitudes printed</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 5</li>
</ul>
</dd>
<dt id="term-num-amps-print-ccenergy">NUM_AMPS_PRINT (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Number of important <span class="math">\(t_1\)</span> and <span class="math">\(t_2\)</span> amplitudes to print</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 10</li>
</ul>
</dd>
<dt id="term-num-amps-print-cceom">NUM_AMPS_PRINT (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Number of important CC amplitudes to print</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 5</li>
</ul>
</dd>
<dt id="term-num-amps-print-cclambda">NUM_AMPS_PRINT (CCLAMBDA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cclambda.html#apdx-cclambda"><span class="std std-ref">CCLAMBDA</span></a> — Number of important CC amplitudes per excitation level to print. CC analog to <a class="reference internal" href="#term-num-dets-print-detci"><span class="xref std std-term">NUM_DETS_PRINT</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 10</li>
</ul>
</dd>
<dt id="term-num-amps-print-ccresponse">NUM_AMPS_PRINT (CCRESPONSE)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccresponse.html#apdx-ccresponse"><span class="std std-ref">CCRESPONSE</span></a> — Number of important CC amplitudes per excitation level to print. CC analog to <a class="reference internal" href="#term-num-dets-print-detci"><span class="xref std std-term">NUM_DETS_PRINT</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 5</li>
</ul>
</dd>
<dt id="term-num-amps-print-detci">NUM_AMPS_PRINT (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Number of important CC amplitudes per excitation level to print. CC analog to <a class="reference internal" href="#term-num-dets-print-detci"><span class="xref std std-term">NUM_DETS_PRINT</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 10</li>
</ul>
</dd>
<dt id="term-num-dets-print-detci">NUM_DETS_PRINT (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Number of important determinants to print</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 20</li>
</ul>
</dd>
<dt id="term-num-frozen-docc-globals">NUM_FROZEN_DOCC (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — The number of core orbitals to freeze in later correlated computations. This trumps <a class="reference internal" href="#term-freeze-core-globals"><span class="xref std std-term">FREEZE_CORE</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-num-frozen-uocc-globals">NUM_FROZEN_UOCC (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — The number of virtual orbitals to freeze in later correlated computations.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-num-init-vecs-detci">NUM_INIT_VECS (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — The number of initial vectors to use in the CI iterative procedure. Defaults to the number of roots.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-num-roots-detci">NUM_ROOTS (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — number of CI roots to find</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-occ-orbs-print-dfocc">OCC_ORBS_PRINT (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Do print OCC orbital energies?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-occ-orbs-print-occ">OCC_ORBS_PRINT (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Do print OCC orbital energies?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-occ-percentage-fnocc">OCC_PERCENTAGE (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> — Cutoff for occupation of MP2 virtual NOs in FNO-QCISD/CCSD(T). The number of virtual NOs is chosen so the occupation of the truncated virtual space is <a class="reference internal" href="#term-occ-percentage-fnocc"><span class="xref std std-term">OCC_PERCENTAGE</span></a> percent of occupation of the original MP2 virtual space. This option is only used if <a class="reference internal" href="#term-nat-orbs-fnocc"><span class="xref std std-term">NAT_ORBS</span></a> = true. This keyword overrides <a class="reference internal" href="#term-occ-tolerance-fnocc"><span class="xref std std-term">OCC_TOLERANCE</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 99.0</li>
</ul>
</dd>
<dt id="term-occ-tolerance-fnocc">OCC_TOLERANCE (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> — Cutoff for occupation of MP2 virtual NOs in FNO-QCISD/CCSD(T). Virtual NOs with occupations less than <a class="reference internal" href="#term-occ-tolerance-fnocc"><span class="xref std std-term">OCC_TOLERANCE</span></a> will be discarded. This option is only used if <a class="reference internal" href="#term-nat-orbs-fnocc"><span class="xref std std-term">NAT_ORBS</span></a> = true.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1.0e-6</li>
</ul>
</dd>
<dt id="term-occ-tolerance-sapt">OCC_TOLERANCE (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for in each of the above three truncations</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1.0e-6</li>
</ul>
</dd>
<dt id="term-odc-guess-dcft">ODC_GUESS (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> — Whether to perform a guess DC-06 or DC-12 computation for ODC-06 or ODC-12 methods, respectively. Currently only available for ALGORITHM = SIMULTANEOUS.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-oeprop-dfocc">OEPROP (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Do compute one electron properties?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-oeprop-occ">OEPROP (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Do compute one electron properties?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-offdiagonal-ccsd-t-psimrcc">OFFDIAGONAL_CCSD_T (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — Do include the off-diagonal corrections in (T) computations?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-omega-ccresponse">OMEGA (CCRESPONSE)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccresponse.html#apdx-ccresponse"><span class="std std-ref">CCRESPONSE</span></a> — Array that specifies the desired frequencies of the incident radiation field in CCLR calculations. If only one element is given, the units will be assumed to be atomic units. If more than one element is given, then the units must be specified as the final element of the array. Acceptable units are <code class="docutils literal"><span class="pre">HZ</span></code>, <code class="docutils literal"><span class="pre">NM</span></code>, <code class="docutils literal"><span class="pre">EV</span></code>, and <code class="docutils literal"><span class="pre">AU</span></code>.</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-omega-erf-mints">OMEGA_ERF (MINTS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mints.html#apdx-mints"><span class="std std-ref">MINTS</span></a> — Omega scaling for Erf and Erfc.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.20</li>
</ul>
</dd>
<dt id="term-omp-n-thread-cphf">OMP_N_THREAD (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — The maximum number of integral threads (0 for Process::environment.get_n_threads())</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-onepdm-ccdensity">ONEPDM (CCDENSITY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccdensity.html#apdx-ccdensity"><span class="std std-ref">CCDENSITY</span></a> — Do compute one-particle density matrix?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-onepdm-dfmp2">ONEPDM (DFMP2)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfmp2.html#apdx-dfmp2"><span class="std std-ref">DFMP2</span></a> — Do compute one-particle density matrix?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-onepdm-grid-cutoff-ccdensity">ONEPDM_GRID_CUTOFF (CCDENSITY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccdensity.html#apdx-ccdensity"><span class="std std-ref">CCDENSITY</span></a> — Cutoff (e/A^3) for printing one-particle density matrix values on a grid</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.0e-30</li>
</ul>
</dd>
<dt id="term-onepdm-grid-dump-ccdensity">ONEPDM_GRID_DUMP (CCDENSITY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccdensity.html#apdx-ccdensity"><span class="std std-ref">CCDENSITY</span></a> — Write one-particle density matrix on a grid to file opdm.dx</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-onepdm-grid-stepsize-ccdensity">ONEPDM_GRID_STEPSIZE (CCDENSITY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccdensity.html#apdx-ccdensity"><span class="std std-ref">CCDENSITY</span></a> — Step size (Angstrom) for one-particle density matrix values on a grid</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.1</li>
</ul>
</dd>
<dt id="term-onepot-grid-read-scf">ONEPOT_GRID_READ (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Read an external potential from the .dx file?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-oo-scale-dfocc">OO_SCALE (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — OO scaling factor used in MSD</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.01</li>
</ul>
</dd>
<dt id="term-opdm-detci">OPDM (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Do compute one-particle density matrix if not otherwise required?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-opdm-relax-ccdensity">OPDM_RELAX (CCDENSITY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccdensity.html#apdx-ccdensity"><span class="std std-ref">CCDENSITY</span></a> — Do relax the one-particle density matrix?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-opdm-relax-dfmp2">OPDM_RELAX (DFMP2)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfmp2.html#apdx-dfmp2"><span class="std std-ref">DFMP2</span></a> — Do relax the one-particle density matrix?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-opt-coordinates-optking">OPT_COORDINATES (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Geometry optimization coordinates to use. REDUNDANT and INTERNAL are synonyms and the default. DELOCALIZED are the coordinates of Baker. NATURAL are the coordinates of Pulay. CARTESIAN uses only cartesian coordinates. BOTH uses both redundant and cartesian coordinates.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: REDUNDANT, INTERNAL, DELOCALIZED, NATURAL, CARTESIAN, BOTH</li>
<li><strong>Default</strong>: INTERNAL</li>
</ul>
</dd>
<dt id="term-opt-method-dfocc">OPT_METHOD (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian options.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: QNR</li>
<li><strong>Default</strong>: QNR</li>
</ul>
</dd>
<dt id="term-opt-method-occ">OPT_METHOD (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: MSD, ORB_RESP</li>
<li><strong>Default</strong>: ORB_RESP</li>
</ul>
</dd>
<dt id="term-opt-type-optking">OPT_TYPE (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Specifies minimum search, transition-state search, or IRC following</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: MIN, TS, IRC</li>
<li><strong>Default</strong>: MIN</li>
</ul>
</dd>
<dt id="term-orb-opt-dfocc">ORB_OPT (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Do optimize the orbitals?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-orb-opt-occ">ORB_OPT (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Do optimize the orbitals?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-orb-resp-solver-dfocc">ORB_RESP_SOLVER (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: PCG, LINEQ</li>
<li><strong>Default</strong>: PCG</li>
</ul>
</dd>
<dt id="term-orb-resp-solver-occ">ORB_RESP_SOLVER (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: PCG, LINEQ</li>
<li><strong>Default</strong>: PCG</li>
</ul>
</dd>
<dt id="term-orbital-level-shift-dcft">ORBITAL_LEVEL_SHIFT (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> <strong>(Expert)</strong> — The shift applied to the denominator in the orbital update iterations</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-orth-type-dfocc">ORTH_TYPE (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — The algorithm for orthogonalization of MOs</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: GS, MGS</li>
<li><strong>Default</strong>: MGS</li>
</ul>
</dd>
<dt id="term-orth-type-occ">ORTH_TYPE (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — The algorithm for orthogonalization of MOs</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: GS, MGS</li>
<li><strong>Default</strong>: MGS</li>
</ul>
</dd>
<dt id="term-overlap-check-cceom">OVERLAP_CHECK (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Report overlaps with old excited-state wave functions, if * available, and store current wave functions for later use.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-p-thermo">P (THERMO)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__thermo.html#apdx-thermo"><span class="std std-ref">THERMO</span></a> — Pressure in Pascal for thermodynamic analysis. Note that 100000. is the value for IUPAC STP.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 101325</li>
</ul>
</dd>
<dt id="term-pair-energies-print-ccenergy">PAIR_ENERGIES_PRINT (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Do print MP2 and CCSD pair energies for RHF references?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-parallel-scf">PARALLEL (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — Do run in parallel?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-pcg-beta-type-dfocc">PCG_BETA_TYPE (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: FLETCHER_REEVES, POLAK_RIBIERE</li>
<li><strong>Default</strong>: FLETCHER_REEVES</li>
</ul>
</dd>
<dt id="term-pcg-beta-type-occ">PCG_BETA_TYPE (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Type of PCG beta parameter (Fletcher-Reeves or Polak-Ribiere).</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: FLETCHER_REEVES, POLAK_RIBIERE</li>
<li><strong>Default</strong>: FLETCHER_REEVES</li>
</ul>
</dd>
<dt id="term-pcg-convergence-dfocc">PCG_CONVERGENCE (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Convergence criterion for residual vector of preconditioned conjugate gradient method.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-6</li>
</ul>
</dd>
<dt id="term-pcg-convergence-occ">PCG_CONVERGENCE (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Convergence criterion for residual vector of preconditioned conjugate gradient method.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-6</li>
</ul>
</dd>
<dt id="term-pcg-maxiter-dfocc">PCG_MAXITER (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Maximum number of preconditioned conjugate gradient iterations.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 50</li>
</ul>
</dd>
<dt id="term-pcg-maxiter-occ">PCG_MAXITER (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Maximum number of preconditioned conjugate gradient iterations.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 30</li>
</ul>
</dd>
<dt id="term-pcm-globals">PCM (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — PCM boolean for pcmsolver module</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-pcm-cc-type-globals">PCM_CC_TYPE (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — PCM-CCSD algorithm type.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: PTE</li>
<li><strong>Default</strong>: PTE</li>
</ul>
</dd>
<dt id="term-pcm-scf-type-globals">PCM_SCF_TYPE (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> <strong>(Expert)</strong> — Use total or separate potentials and charges in the PCM-SCF step.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: TOTAL, SEPARATE</li>
<li><strong>Default</strong>: TOTAL</li>
</ul>
</dd>
<dt id="term-perturb-cbs-psimrcc">PERTURB_CBS (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> <strong>(Expert)</strong> — Do compute the perturbative corrections for basis set incompleteness?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-perturb-cbs-coupling-psimrcc">PERTURB_CBS_COUPLING (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> <strong>(Expert)</strong> — Do include the terms that couple different reference determinants in perturbative CBS correction computations?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-perturb-dipole-scf">PERTURB_DIPOLE (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — An array of length three describing the magnitude (atomic units) of the dipole field in the {x,y,z} directions</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-perturb-h-scf">PERTURB_H (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Do perturb the Hamiltonian?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-perturb-magnitude-detci">PERTURB_MAGNITUDE (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — The magnitude of perturbation <span class="math">\(z\)</span> in <span class="math">\(H = H_0 + z H_1\)</span></p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.0</li>
</ul>
</dd>
<dt id="term-perturb-magnitude-scf">PERTURB_MAGNITUDE (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Size of the perturbation (applies only to dipole perturbations). Deprecated - use PERTURB_DIPOLE instead</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-perturb-with-scf">PERTURB_WITH (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — The operator used to perturb the Hamiltonian, if requested. DIPOLE_X, DIPOLE_Y and DIPOLE_Z will be removed in favor of the DIPOLE option in the future</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: DIPOLE, DIPOLE_X, DIPOLE_Y, DIPOLE_Z, EMBPOT, SPHERE, DX</li>
<li><strong>Default</strong>: DIPOLE</li>
</ul>
</dd>
<dt id="term-phi-points-scf">PHI_POINTS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Number of azimuthal grid points for spherical potential integration</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 360</li>
</ul>
</dd>
<dt id="term-pk-algo-scf">PK_ALGO (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — Select the PK algorithm to use. For debug purposes, selection will be automated later.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: REORDER, YOSHIMINE</li>
<li><strong>Default</strong>: REORDER</li>
</ul>
</dd>
<dt id="term-pk-all-nonsym-scf">PK_ALL_NONSYM (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — All densities are considered non symmetric, debug only.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-pk-max-buckets-scf">PK_MAX_BUCKETS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — Maximum numbers of batches to read PK supermatrix.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 500</li>
</ul>
</dd>
<dt id="term-pk-no-incore-scf">PK_NO_INCORE (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — Deactivate in core algorithm. For debug purposes.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-points-findif">POINTS (FINDIF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__findif.html#apdx-findif"><span class="std std-ref">FINDIF</span></a> — Number of points for finite-differences (3 or 5)</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 3</li>
</ul>
</dd>
<dt id="term-pole-maxiter-adc">POLE_MAXITER (ADC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__adc.html#apdx-adc"><span class="std std-ref">ADC</span></a> — Maximum iteration number in pole searching</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 20</li>
</ul>
</dd>
<dt id="term-ppl-type-dfocc">PPL_TYPE (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Type of the CCSD PPL term.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: LOW_MEM, HIGH_MEM, CD, AUTO</li>
<li><strong>Default</strong>: AUTO</li>
</ul>
</dd>
<dt id="term-pr-adc">PR (ADC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__adc.html#apdx-adc"><span class="std std-ref">ADC</span></a> — Do use the partial renormalization scheme for the ground state wavefunction?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-preconditioner-detci">PRECONDITIONER (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — This specifies the type of preconditioner to use in the selected diagonalization method. The valid options are: <code class="docutils literal"><span class="pre">DAVIDSON</span></code> which approximates the Hamiltonian matrix by the diagonal elements; <code class="docutils literal"><span class="pre">H0BLOCK_INV</span></code> which uses an exact Hamiltonian of <a class="reference internal" href="#term-h0-blocksize-detci"><span class="xref std std-term">H0_BLOCKSIZE</span></a> and explicitly inverts it; <code class="docutils literal"><span class="pre">GEN_DAVIDSON</span></code> which does a spectral decomposition of H0BLOCK; <code class="docutils literal"><span class="pre">ITER_INV</span></code> using an iterative approach to obtain the correction vector of H0BLOCK. The <code class="docutils literal"><span class="pre">H0BLOCK_INV</span></code>, <code class="docutils literal"><span class="pre">GEN_DAVIDSON</span></code>, and <code class="docutils literal"><span class="pre">ITER_INV</span></code> approaches are all formally equivalent but the <code class="docutils literal"><span class="pre">ITER_INV</span></code> is less computationally expensive. Default is <code class="docutils literal"><span class="pre">DAVIDSON</span></code>.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: LANCZOS, DAVIDSON, GEN_DAVIDSON, H0BLOCK, H0BLOCK_INV, ITER_INV, H0BLOCK_COUPLING, EVANGELISTI</li>
<li><strong>Default</strong>: DAVIDSON</li>
</ul>
</dd>
<dt id="term-print-cphf">PRINT (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — The amount of information printed to the output file</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-print-efp">PRINT (EFP)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__efp.html#apdx-efp"><span class="std std-ref">EFP</span></a> — The amount of information printed to the output file.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-print-globals">PRINT (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — The amount of information to print to the output file. 1 prints basic information, and higher levels print more information. A value of 5 will print very large amounts of debugging information.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-print-sapt">PRINT (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-print-basis-scf">PRINT_BASIS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Flag to print the basis set.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-print-mos-scf">PRINT_MOS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Flag to print the molecular orbitals.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-print-opt-params-optking">PRINT_OPT_PARAMS (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Print all optking parameters.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-print-trajectory-xyz-file-optking">PRINT_TRAJECTORY_XYZ_FILE (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Should an xyz trajectory file be kept (useful for visualization)?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-process-grid-scf">PROCESS_GRID (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — The dimension sizes of the processor grid</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-prop-all-ccdensity">PROP_ALL (CCDENSITY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccdensity.html#apdx-ccdensity"><span class="std std-ref">CCDENSITY</span></a> — Compute non-relaxed properties for all excited states.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-prop-all-cclambda">PROP_ALL (CCLAMBDA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cclambda.html#apdx-cclambda"><span class="std std-ref">CCLAMBDA</span></a> — Compute unrelaxed properties for all excited states.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-prop-root-ccdensity">PROP_ROOT (CCDENSITY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccdensity.html#apdx-ccdensity"><span class="std std-ref">CCDENSITY</span></a> — Root number (within its irrep) for computing properties</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-prop-root-cceom">PROP_ROOT (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Root number (within its irrep) for computing properties. Defaults to highest root requested.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-prop-root-cclambda">PROP_ROOT (CCLAMBDA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cclambda.html#apdx-cclambda"><span class="std std-ref">CCLAMBDA</span></a> — Root number (within its irrep) for computing properties</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-prop-sym-ccdensity">PROP_SYM (CCDENSITY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccdensity.html#apdx-ccdensity"><span class="std std-ref">CCDENSITY</span></a> — The symmetry of states</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-prop-sym-cceom">PROP_SYM (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Symmetry of the state to compute properties. Defaults to last irrep for which states are requested.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-prop-sym-cclambda">PROP_SYM (CCLAMBDA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cclambda.html#apdx-cclambda"><span class="std std-ref">CCLAMBDA</span></a> — The symmetry of states</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-properties-globals">PROPERTIES (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — List of properties to compute</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-properties-origin-globals">PROPERTIES_ORIGIN (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — Either <a class="reference internal" href="oeprop.html#table-oe-origin"><span class="std std-ref">a set of 3 coordinates or a string</span></a> describing the origin about which one-electron properties are computed.</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-property-ccenergy">PROPERTY (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — The response property desired. Acceptable values are <code class="docutils literal"><span class="pre">POLARIZABILITY</span></code> (default) for dipole-polarizabilities, <code class="docutils literal"><span class="pre">ROTATION</span></code> for specific rotations, <code class="docutils literal"><span class="pre">ROA</span></code> for Raman Optical Activity, and <code class="docutils literal"><span class="pre">ALL</span></code> for all of the above.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: POLARIZABILITY, ROTATION, MAGNETIZABILITY, ROA, ALL</li>
<li><strong>Default</strong>: POLARIZABILITY</li>
</ul>
</dd>
<dt id="term-property-ccresponse">PROPERTY (CCRESPONSE)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccresponse.html#apdx-ccresponse"><span class="std std-ref">CCRESPONSE</span></a> — The response property desired. Acceptable values are <code class="docutils literal"><span class="pre">POLARIZABILITY</span></code> (default) for dipole polarizabilities, <code class="docutils literal"><span class="pre">ROTATION</span></code> for specific rotations, <code class="docutils literal"><span class="pre">ROA</span></code> for Raman Optical Activity (<code class="docutils literal"><span class="pre">ROA_TENSOR</span></code> for each displacement), and <code class="docutils literal"><span class="pre">ALL</span></code> for all of the above.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: POLARIZABILITY, ROTATION, ROA, ROA_TENSOR, ALL</li>
<li><strong>Default</strong>: POLARIZABILITY</li>
</ul>
</dd>
<dt id="term-pt-energy-psimrcc">PT_ENERGY (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — The type of perturbation theory computation to perform</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: SECOND_ORDER, SCS_SECOND_ORDER, PSEUDO_SECOND_ORDER, SCS_PSEUDO_SECOND_ORDER</li>
<li><strong>Default</strong>: SECOND_ORDER</li>
</ul>
</dd>
<dt id="term-puream-globals">PUREAM (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — Do use pure angular momentum basis functions? If not explicitly set, the default comes from the basis set. <strong>Cfour Interface:</strong> Keyword translates into <a class="reference internal" href="#term-cfour-spherical-cfour"><span class="xref std std-term">CFOUR_SPHERICAL</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-qc-coupling-dcft">QC_COUPLING (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> — Controls whether to include the coupling terms in the DCFT electronic Hessian (for ALOGRITHM = QC with QC_TYPE = SIMULTANEOUS only)</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-qc-module-globals">QC_MODULE (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — When several modules can compute the same methods and the default routing is not suitable, this targets a module. <code class="docutils literal"><span class="pre">CCENERGY</span></code> covers CCHBAR, etc. <code class="docutils literal"><span class="pre">OCC</span></code> covers OCC and DFOCC.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: CCENERGY, DETCI, DFMP2, FNOCC, OCC</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-qc-type-dcft">QC_TYPE (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> — Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: TWOSTEP, SIMULTANEOUS</li>
<li><strong>Default</strong>: SIMULTANEOUS</li>
</ul>
</dd>
<dt id="term-qchf-dfocc">QCHF (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Do perform a QCHF computation?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-qchf-scf">QCHF (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Do perform a QCHF computation?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-qmefp-efp">QMEFP (EFP)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__efp.html#apdx-efp"><span class="std std-ref">EFP</span></a> <strong>(Expert)</strong> — Do turn on QM/EFP terms?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-qmefp-elst-efp">QMEFP_ELST (EFP)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__efp.html#apdx-efp"><span class="std std-ref">EFP</span></a> — Do include electrostatics energy term in QM/EFP computation?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-qmefp-pol-efp">QMEFP_POL (EFP)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__efp.html#apdx-efp"><span class="std std-ref">EFP</span></a> — Do include polarization energy term in EFP computation?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-r4s-detci">R4S (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Do restrict strings with <span class="math">\(e-\)</span> in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., <a class="reference internal" href="#term-ex-level-detci"><span class="xref std std-term">EX_LEVEL</span></a>), or else the string is discarded.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-r-convergence-ccenergy">R_CONVERGENCE (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Convergence criterion for wavefunction (change) in CC amplitude equations.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-7</li>
</ul>
</dd>
<dt id="term-r-convergence-cceom">R_CONVERGENCE (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Convergence criterion for norm of the residual vector in the Davidson algorithm for CC-EOM.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-6</li>
</ul>
</dd>
<dt id="term-r-convergence-cclambda">R_CONVERGENCE (CCLAMBDA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cclambda.html#apdx-cclambda"><span class="std std-ref">CCLAMBDA</span></a> — Convergence criterion for wavefunction (change) in CC lambda-amplitude equations.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-7</li>
</ul>
</dd>
<dt id="term-r-convergence-ccresponse">R_CONVERGENCE (CCRESPONSE)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccresponse.html#apdx-ccresponse"><span class="std std-ref">CCRESPONSE</span></a> — Convergence criterion for wavefunction (change) in perturbed CC equations.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-7</li>
</ul>
</dd>
<dt id="term-r-convergence-dcft">R_CONVERGENCE (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> — Convergence criterion for the RMS of the residual vector in density cumulant updates, as well as the solution of the density cumulant and orbital response equations. In the orbital updates controls the RMS of the SCF error vector</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-10</li>
</ul>
</dd>
<dt id="term-r-convergence-detci">R_CONVERGENCE (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Convergence criterion for CI residual vector in the Davidson algorithm (RMS error). The default is 1e-4 for energies and 1e-7 for gradients.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-4</li>
</ul>
</dd>
<dt id="term-r-convergence-dfocc">R_CONVERGENCE (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Convergence criterion for amplitudes (residuals).</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-5</li>
</ul>
</dd>
<dt id="term-r-convergence-fnocc">R_CONVERGENCE (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> — Convergence for the CC amplitudes. Note that convergence is met only when <a class="reference internal" href="#term-e-convergence-fnocc"><span class="xref std std-term">E_CONVERGENCE</span></a> and <a class="reference internal" href="#term-r-convergence-fnocc"><span class="xref std std-term">R_CONVERGENCE</span></a> are satisfied.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1.0e-7</li>
</ul>
</dd>
<dt id="term-r-convergence-occ">R_CONVERGENCE (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Convergence criterion for amplitudes (residuals).</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-5</li>
</ul>
</dd>
<dt id="term-r-convergence-psimrcc">R_CONVERGENCE (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — Convergence criterion for amplitudes (residuals).</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-9</li>
</ul>
</dd>
<dt id="term-r-points-scf">R_POINTS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Number of radial grid points for spherical potential integration</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 100</li>
</ul>
</dd>
<dt id="term-radius-scf">RADIUS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Radius (bohr) of a hard-sphere external potential</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 10.0</li>
</ul>
</dd>
<dt id="term-ras1-globals">RAS1 (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> <strong>(Expert)</strong> — An array giving the number of orbitals per irrep for RAS1</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-ras2-globals">RAS2 (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> <strong>(Expert)</strong> — An array giving the number of orbitals per irrep for RAS2</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-ras3-globals">RAS3 (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> <strong>(Expert)</strong> — An array giving the number of orbitals per irrep for RAS3</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-ras34-max-detci">RAS34_MAX (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — maximum number of electrons in RAS III + IV</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: -1</li>
</ul>
</dd>
<dt id="term-ras3-max-detci">RAS3_MAX (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — maximum number of electrons in RAS III</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: -1</li>
</ul>
</dd>
<dt id="term-ras4-globals">RAS4 (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> <strong>(Expert)</strong> — An array giving the number of orbitals per irrep for RAS4</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-ras4-max-detci">RAS4_MAX (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — maximum number of electrons in RAS IV</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: -1</li>
</ul>
</dd>
<dt id="term-read-scf-3index-dfocc">READ_SCF_3INDEX (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Do read 3-index integrals from SCF files?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-reference-adc">REFERENCE (ADC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__adc.html#apdx-adc"><span class="std std-ref">ADC</span></a> — Reference wavefunction type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: RHF</li>
<li><strong>Default</strong>: RHF</li>
</ul>
</dd>
<dt id="term-reference-ccdensity">REFERENCE (CCDENSITY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccdensity.html#apdx-ccdensity"><span class="std std-ref">CCDENSITY</span></a> — Reference wavefunction type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: RHF</li>
</ul>
</dd>
<dt id="term-reference-ccenergy">REFERENCE (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Reference wavefunction type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: RHF, ROHF, UHF</li>
<li><strong>Default</strong>: RHF</li>
</ul>
</dd>
<dt id="term-reference-cceom">REFERENCE (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Reference wavefunction type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: RHF, ROHF, UHF</li>
<li><strong>Default</strong>: RHF</li>
</ul>
</dd>
<dt id="term-reference-ccresponse">REFERENCE (CCRESPONSE)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccresponse.html#apdx-ccresponse"><span class="std std-ref">CCRESPONSE</span></a> — Reference wavefunction type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: RHF</li>
</ul>
</dd>
<dt id="term-reference-cctransort">REFERENCE (CCTRANSORT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cctransort.html#apdx-cctransort"><span class="std std-ref">CCTRANSORT</span></a> — Reference wavefunction type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: RHF</li>
</ul>
</dd>
<dt id="term-reference-cctriples">REFERENCE (CCTRIPLES)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cctriples.html#apdx-cctriples"><span class="std std-ref">CCTRIPLES</span></a> — Reference wavefunction type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: RHF</li>
</ul>
</dd>
<dt id="term-reference-dcft">REFERENCE (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> — Reference wavefunction type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: UHF, RHF, ROHF</li>
<li><strong>Default</strong>: RHF</li>
</ul>
</dd>
<dt id="term-reference-detci">REFERENCE (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Reference wavefunction type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: RHF, ROHF</li>
<li><strong>Default</strong>: RHF</li>
</ul>
</dd>
<dt id="term-reference-mcscf">REFERENCE (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> — Reference wavefunction type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: RHF, ROHF, UHF, TWOCON, MCSCF, GENERAL</li>
<li><strong>Default</strong>: RHF</li>
</ul>
</dd>
<dt id="term-reference-scf">REFERENCE (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Reference wavefunction type. <strong>Cfour Interface:</strong> Keyword translates into <a class="reference internal" href="#term-cfour-reference-cfour"><span class="xref std std-term">CFOUR_REFERENCE</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: RHF, ROHF, UHF, CUHF, RKS, UKS</li>
<li><strong>Default</strong>: RHF</li>
</ul>
</dd>
<dt id="term-reference-sym-detci">REFERENCE_SYM (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Irrep for CI vectors; -1 = find automatically. This option allows the user to look for CI vectors of a different irrep than the reference. This probably only makes sense for Full CI, and it would probably not work with unit vector guesses. Numbering starts from zero for the totally-symmetric irrep.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: -1</li>
</ul>
</dd>
<dt id="term-reg-param-dfocc">REG_PARAM (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Regularization parameter</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.4</li>
</ul>
</dd>
<dt id="term-regularization-dfocc">REGULARIZATION (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Do use regularized denominators?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-relativistic-globals">RELATIVISTIC (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> <strong>(Expert)</strong> — Relativistic Hamiltonian type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NO, X2C</li>
<li><strong>Default</strong>: NO</li>
</ul>
</dd>
<dt id="term-relax-guess-orbitals-dcft">RELAX_GUESS_ORBITALS (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> <strong>(Expert)</strong> — Controls whether to relax the guess orbitals by taking the guess density cumulant and performing orbital update on the first macroiteration (for ALOGRITHM = TWOSTEP only)</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-relax-tau-dcft">RELAX_TAU (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> <strong>(Expert)</strong> — Controls whether to relax tau during the cumulant updates or not</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-relaxed-occ">RELAXED (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Do consider orbital response contributions for PDMs and GFM?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-repl-otf-detci">REPL_OTF (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Do string replacements on the fly in DETCI? Can save a gigantic amount of memory (especially for truncated CI&#8217;s) but is somewhat flaky and hasn&#8217;t been tested for a while. It may work only works for certain classes of RAS calculations. The current code is very slow with this option turned on.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-response-algorithm-dcft">RESPONSE_ALGORITHM (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> — Algorithm to use for the solution of DC-06 response equations in computation of analytic gradients and properties</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: TWOSTEP, SIMULTANEOUS</li>
<li><strong>Default</strong>: TWOSTEP</li>
</ul>
</dd>
<dt id="term-restart-ccenergy">RESTART (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Do restart the coupled-cluster iterations from old <span class="math">\(t_1\)</span> and <span class="math">\(t_2\)</span> amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-restart-cclambda">RESTART (CCLAMBDA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cclambda.html#apdx-cclambda"><span class="std std-ref">CCLAMBDA</span></a> — Do restart the coupled-cluster iterations from old <span class="math">\(\lambda_1\)</span> and <span class="math">\(\lambda_2\)</span> amplitudes?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-restart-ccresponse">RESTART (CCRESPONSE)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccresponse.html#apdx-ccresponse"><span class="std std-ref">CCRESPONSE</span></a> — Do restart from on-disk amplitudes?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-restart-detci">RESTART (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Do restart a DETCI iteration that terminated prematurely? It assumes that the CI and sigma vectors are on disk.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-restart-eom-cc3-cceom">RESTART_EOM_CC3 (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Do restart from on-disk?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-restricted-docc-globals">RESTRICTED_DOCC (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF)</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-restricted-uocc-globals">RESTRICTED_UOCC (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF)</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-rfo-follow-root-optking">RFO_FOLLOW_ROOT (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Do follow the initial RFO vector after the first step?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-rfo-normalization-max-optking">RFO_NORMALIZATION_MAX (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Eigenvectors of RFO matrix whose final column is smaller than this are ignored.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 100</li>
</ul>
</dd>
<dt id="term-rfo-root-optking">RFO_ROOT (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Root for RFO to follow, 0 being lowest (for a minimum)</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-rhf-triplets-cceom">RHF_TRIPLETS (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Do form a triplet state from RHF reference?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-rms-disp-g-convergence-optking">RMS_DISP_G_CONVERGENCE (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Convergence criterion for geometry optmization: rms displacement (internal coordinates, atomic units).</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1.2e-3</li>
</ul>
</dd>
<dt id="term-rms-force-g-convergence-optking">RMS_FORCE_G_CONVERGENCE (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Convergence criterion for geometry optmization: rms force (internal coordinates, atomic units).</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 3.0e-4</li>
</ul>
</dd>
<dt id="term-rms-mograd-convergence-dfocc">RMS_MOGRAD_CONVERGENCE (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Convergence criterion for RMS orbital gradient. Default adjusts depending on <a class="reference internal" href="#term-e-convergence-occ"><span class="xref std std-term">E_CONVERGENCE</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-6</li>
</ul>
</dd>
<dt id="term-rms-mograd-convergence-occ">RMS_MOGRAD_CONVERGENCE (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Convergence criterion for RMS orbital gradient. Default adjusts depending on <a class="reference internal" href="#term-e-convergence-occ"><span class="xref std std-term">E_CONVERGENCE</span></a>.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-6</li>
</ul>
</dd>
<dt id="term-roots-per-irrep-adc">ROOTS_PER_IRREP (ADC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__adc.html#apdx-adc"><span class="std std-ref">ADC</span></a> — The poles per irrep vector</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-roots-per-irrep-ccdensity">ROOTS_PER_IRREP (CCDENSITY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccdensity.html#apdx-ccdensity"><span class="std std-ref">CCDENSITY</span></a> — The number of electronic states to computed, per irreducible representation</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-roots-per-irrep-cceom">ROOTS_PER_IRREP (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Number of excited states per irreducible representation for EOM-CC and CC-LR calculations. Irreps denote the final state symmetry, not the symmetry of the transition.</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-roots-per-irrep-cclambda">ROOTS_PER_IRREP (CCLAMBDA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cclambda.html#apdx-cclambda"><span class="std std-ref">CCLAMBDA</span></a> — The number of electronic states to computed, per irreducible representation</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-rotate-mo-angle-mcscf">ROTATE_MO_ANGLE (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> <strong>(Expert)</strong> — For orbital rotations after convergence, the angle (in degrees) by which to rotate.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-rotate-mo-irrep-mcscf">ROTATE_MO_IRREP (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> <strong>(Expert)</strong> — For orbital rotations after convergence, irrep (1-based, Cotton order) of the orbitals to rotate.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-rotate-mo-p-mcscf">ROTATE_MO_P (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> <strong>(Expert)</strong> — For orbital rotations after convergence, number of the first orbital (1-based) to rotate.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-rotate-mo-q-mcscf">ROTATE_MO_Q (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> <strong>(Expert)</strong> — For orbital rotations after convergence, number of the second orbital (1-based) to rotate.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-rotational-symmetry-number-thermo">ROTATIONAL_SYMMETRY_NUMBER (THERMO)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__thermo.html#apdx-thermo"><span class="std std-ref">THERMO</span></a> — Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this option is the sole way to influence the symmetry-dependent aspects of the thermodynamic analysis.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-rsrfo-alpha-max-optking">RSRFO_ALPHA_MAX (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Absolute maximum value of RS-RFO.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1e8</li>
</ul>
</dd>
<dt id="term-run-ccsd-fnocc">RUN_CCSD (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> <strong>(Expert)</strong> — do ccsd rather than qcisd?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-run-cctransort-cctransort">RUN_CCTRANSORT (CCTRANSORT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cctransort.html#apdx-cctransort"><span class="std std-ref">CCTRANSORT</span></a> — Use cctransort module NOTE: Turning this option off requires separate * installation of ccsort and transqt2 modules, see <a class="reference external" href="http://github.com/psi4/psi4pasture">http://github.com/psi4/psi4pasture</a></p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-run-cepa-fnocc">RUN_CEPA (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> <strong>(Expert)</strong> — Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won&#8217;t have any effect on the procedure.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-run-mp2-fnocc">RUN_MP2 (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> <strong>(Expert)</strong> — do only evaluate mp2 energy?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-run-mp3-fnocc">RUN_MP3 (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> <strong>(Expert)</strong> — do only evaluate mp3 energy?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-run-mp4-fnocc">RUN_MP4 (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> <strong>(Expert)</strong> — do only evaluate mp4 energy?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-s-detci">S (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — The value of the spin quantum number <span class="math">\(S\)</span> is given by this option. The default is determined by the value of the multiplicity. This is used for two things: (1) determining the phase of the redundant half of the CI vector when the <span class="math">\(M_s = 0\)</span> component is used (i.e., <a class="reference internal" href="#term-ms0-detci"><span class="xref std std-term">MS0</span></a> = <code class="docutils literal"><span class="pre">TRUE</span></code>), and (2) making sure the guess vector has the desired value of <span class="math">\(\langle S^2\rangle\)</span> (if <a class="reference internal" href="#term-calc-s-squared-detci"><span class="xref std std-term">CALC_S_SQUARED</span></a> is <code class="docutils literal"><span class="pre">TRUE</span></code> and <a class="reference internal" href="#term-icore-detci"><span class="xref std std-term">ICORE</span></a> = <code class="docutils literal"><span class="pre">1</span></code>).</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-s-orthogonalization-scf">S_ORTHOGONALIZATION (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — SO orthogonalization: symmetric or canonical?</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: SYMMETRIC, CANONICAL</li>
<li><strong>Default</strong>: SYMMETRIC</li>
</ul>
</dd>
<dt id="term-s-tolerance-scf">S_TOLERANCE (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Minimum S matrix eigenvalue to be used before compensating for linear dependencies.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-7</li>
</ul>
</dd>
<dt id="term-sad-chol-tolerance-scf">SAD_CHOL_TOLERANCE (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — Auxiliary basis for the SAD guess</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-7</li>
</ul>
</dd>
<dt id="term-sad-d-convergence-scf">SAD_D_CONVERGENCE (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Convergence criterion for SCF density in SAD Guess.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-5</li>
</ul>
</dd>
<dt id="term-sad-e-convergence-scf">SAD_E_CONVERGENCE (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Convergence criterion for SCF energy in SAD Guess.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-5</li>
</ul>
</dd>
<dt id="term-sad-frac-occ-scf">SAD_FRAC_OCC (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — Auxiliary basis for the SAD guess</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-sad-maxiter-scf">SAD_MAXITER (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — Maximum number of SAD guess iterations</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 50</li>
</ul>
</dd>
<dt id="term-sad-print-scf">SAD_PRINT (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — The amount of SAD information to print to the output</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-sad-scf-type-scf">SAD_SCF_TYPE (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — SCF type of SAD guess</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: DIRECT, DF</li>
<li><strong>Default</strong>: DF</li>
</ul>
</dd>
<dt id="term-sapt-scf">SAPT (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — Are going to do SAPT? If so, what part?</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: FALSE, 2-DIMER, 2-MONOMER_A, 2-MONOMER_B, 3-TRIMER, 3-DIMER_AB, 3-DIMER_BC, 3-DIMER_AC, 3-MONOMER_A, 3-MONOMER_B, 3-MONOMER_C</li>
<li><strong>Default</strong>: FALSE</li>
</ul>
</dd>
<dt id="term-sapt0-e10-sapt">SAPT0_E10 (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> <strong>(Expert)</strong> — For SAPT0 only, compute only first-order electrostatics and exchange. The integrals are computed before any terms, so all integrals will be computed even if they are not needed for the requested term</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-sapt0-e20disp-sapt">SAPT0_E20DISP (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> <strong>(Expert)</strong> — For SAPT0 only, compute only second-order induction The integrals are computed before any terms, so all integrals will be computed even if they are not needed for the requested term</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-sapt0-e20ind-sapt">SAPT0_E20IND (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> <strong>(Expert)</strong> — For SAPT0 only, compute only second-order induction The integrals are computed before any terms, so all integrals will be computed even if they are not needed for the requested term</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-sapt-level-sapt">SAPT_LEVEL (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — The level of theory for SAPT</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: SAPT0, SAPT2, SAPT2+, SAPT2+3</li>
<li><strong>Default</strong>: SAPT0</li>
</ul>
</dd>
<dt id="term-sapt-mem-check-sapt">SAPT_MEM_CHECK (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — Do force SAPT2 and higher to die if it thinks there isn&#8217;t enough memory? Turning this off is ill-advised.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-sapt-mem-factor-sapt">SAPT_MEM_FACTOR (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> <strong>(Expert)</strong> — Proportion of memory available for the DF-MP2 three-index integral buffers used to evaluate dispersion.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.9</li>
</ul>
</dd>
<dt id="term-sapt-mem-safety-sapt">SAPT_MEM_SAFETY (SAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__sapt.html#apdx-sapt"><span class="std std-ref">SAPT</span></a> — Memory safety</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.9</li>
</ul>
</dd>
<dt id="term-save-jk-scf">SAVE_JK (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Keep JK object for later use?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-save-uhf-nos-scf">SAVE_UHF_NOS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Save the UHF NOs</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-scf-mem-safety-factor-scf">SCF_MEM_SAFETY_FACTOR (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Memory safety factor for allocating JK</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.75</li>
</ul>
</dd>
<dt id="term-scf-type-cphf">SCF_TYPE (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — SCF Type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: DIRECT, DF, PK, OUT_OF_CORE, PS, INDEPENDENT, GTFOCK</li>
<li><strong>Default</strong>: DIRECT</li>
</ul>
</dd>
<dt id="term-scf-type-scf">SCF_TYPE (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — What algorithm to use for the SCF computation. See Table <a class="reference internal" href="scf.html#table-conv-scf"><span class="std std-ref">SCF Convergence &amp; Algorithm</span></a> for default algorithm for different calculation types.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: DIRECT, DF, PK, OUT_OF_CORE, FAST_DF, CD, INDEPENDENT, GTFOCK</li>
<li><strong>Default</strong>: PK</li>
</ul>
</dd>
<dt id="term-schmidt-add-residual-tolerance-cceom">SCHMIDT_ADD_RESIDUAL_TOLERANCE (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Minimum absolute value above which a guess vector to a root is added to the Davidson algorithm in the EOM-CC iterative procedure.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-3</li>
</ul>
</dd>
<dt id="term-schwarz-cutoff-cphf">SCHWARZ_CUTOFF (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — The Schwarz cutoff value</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.0e-12</li>
</ul>
</dd>
<dt id="term-scs-ccsd-ccenergy">SCS_CCSD (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Do spin-component-scaled CCSD</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-scs-ccsd-fnocc">SCS_CCSD (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> — Do SCS-CCSD?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-scs-cepa-fnocc">SCS_CEPA (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> — Do SCS-CEPA? Note that the scaling factors will be identical to those for SCS-CCSD.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-scs-mp2-ccenergy">SCS_MP2 (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Do spin-component-scaled MP2 (SCS-MP2)?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-scs-mp2-fnocc">SCS_MP2 (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> — Do SCS-MP2?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-scs-type-dfocc">SCS_TYPE (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Type of the SCS method</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: SCS, SCSN, SCSVDW, SCSMI</li>
<li><strong>Default</strong>: SCS</li>
</ul>
</dd>
<dt id="term-scs-type-occ">SCS_TYPE (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Type of the SCS method</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: SCS, SCSN, SCSVDW, SCSMI</li>
<li><strong>Default</strong>: SCS</li>
</ul>
</dd>
<dt id="term-scsn-mp2-ccenergy">SCSN_MP2 (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Do SCS-MP2 with parameters optimized for nucleic acids?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-sekino-cclambda">SEKINO (CCLAMBDA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cclambda.html#apdx-cclambda"><span class="std std-ref">CCLAMBDA</span></a> — Do Sekino-Bartlett size-extensive model-III?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-sekino-ccresponse">SEKINO (CCRESPONSE)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccresponse.html#apdx-ccresponse"><span class="std std-ref">CCRESPONSE</span></a> — Do Sekino-Bartlett size-extensive model-III?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-sem-maxiter-adc">SEM_MAXITER (ADC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__adc.html#apdx-adc"><span class="std std-ref">ADC</span></a> — Maximum iteration number in simultaneous expansion method</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 30</li>
</ul>
</dd>
<dt id="term-semicanonical-ccenergy">SEMICANONICAL (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Convert ROHF MOs to semicanonical MOs</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-semicanonical-cceom">SEMICANONICAL (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Convert ROHF MOs to semicanonical MOs</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-semicanonical-cctransort">SEMICANONICAL (CCTRANSORT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cctransort.html#apdx-cctransort"><span class="std std-ref">CCTRANSORT</span></a> — Force conversion of ROHF MOs to semicanonical MOs to run UHF-based energies</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-semicanonical-cctriples">SEMICANONICAL (CCTRIPLES)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cctriples.html#apdx-cctriples"><span class="std std-ref">CCTRIPLES</span></a> — Convert ROHF MOs to semicanonical MOs</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-sf-restrict-detci">SF_RESTRICT (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Do eliminate determinants not valid for spin-complete spin-flip CI&#8217;s? [see J. S. Sears et al, J. Chem. Phys. 118, 9084-9094 (2003)]</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-sigma-overlap-detci">SIGMA_OVERLAP (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Do print the sigma overlap matrix? Not generally useful.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-singles-print-cceom">SINGLES_PRINT (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Do print information on the iterative solution to the single-excitation EOM-CC problem used as a guess to full EOM-CC?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-small-cutoff-psimrcc">SMALL_CUTOFF (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> —</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-socc-globals">SOCC (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — An array containing the number of singly-occupied orbitals per irrep (in Cotton order). The value of <a class="reference internal" href="#term-docc-globals"><span class="xref std std-term">DOCC</span></a> should also be set.</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-socc-mcscf">SOCC (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> — The number of singly occupied orbitals, per irrep</p>
<ul class="last simple">
<li><strong>Type</strong>: array</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-solver-convergence-cphf">SOLVER_CONVERGENCE (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Solver convergence threshold (max 2-norm).</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1.0e-6</li>
</ul>
</dd>
<dt id="term-solver-exact-diagonal-cphf">SOLVER_EXACT_DIAGONAL (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Solver exact diagonal or eigenvalue difference?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-solver-max-subspace-cphf">SOLVER_MAX_SUBSPACE (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — DL Solver maximum number of subspace vectors</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 6</li>
</ul>
</dd>
<dt id="term-solver-maxiter-cphf">SOLVER_MAXITER (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Solver maximum iterations</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 100</li>
</ul>
</dd>
<dt id="term-solver-min-subspace-cphf">SOLVER_MIN_SUBSPACE (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — DL Solver number of subspace vectors to collapse to</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 2</li>
</ul>
</dd>
<dt id="term-solver-n-guess-cphf">SOLVER_N_GUESS (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — DL Solver number of guesses</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-solver-n-root-cphf">SOLVER_N_ROOT (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — DL Solver number of roots</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-solver-norm-cphf">SOLVER_NORM (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — DL Solver minimum corrector norm to add to subspace</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 1.0e-6</li>
</ul>
</dd>
<dt id="term-solver-precondition-cphf">SOLVER_PRECONDITION (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Solver precondition type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: SUBSPACE, JACOBI, NONE</li>
<li><strong>Default</strong>: JACOBI</li>
</ul>
</dd>
<dt id="term-solver-precondition-maxiter-cphf">SOLVER_PRECONDITION_MAXITER (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Solver precondition max steps</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-solver-precondition-steps-cphf">SOLVER_PRECONDITION_STEPS (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Solver precondition step type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: CONSTANT, TRIANGULAR</li>
<li><strong>Default</strong>: TRIANGULAR</li>
</ul>
</dd>
<dt id="term-solver-quantity-cphf">SOLVER_QUANTITY (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Solver residue or eigenvector delta</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: EIGENVECTOR, RESIDUAL</li>
<li><strong>Default</strong>: RESIDUAL</li>
</ul>
</dd>
<dt id="term-solver-type-cphf">SOLVER_TYPE (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Solver type (for interchangeable solvers)</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: DL, RAYLEIGH</li>
<li><strong>Default</strong>: DL</li>
</ul>
</dd>
<dt id="term-sos-type-dfocc">SOS_TYPE (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Type of the SOS method</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: SOS, SOSPI</li>
<li><strong>Default</strong>: SOS</li>
</ul>
</dd>
<dt id="term-sos-type-occ">SOS_TYPE (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Type of the SOS method</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: SOS, SOSPI</li>
<li><strong>Default</strong>: SOS</li>
</ul>
</dd>
<dt id="term-soscf-scf">SOSCF (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Do use second-order SCF convergence methods?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-soscf-conv-scf">SOSCF_CONV (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Second order convergence threshold.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 5.0e-3</li>
</ul>
</dd>
<dt id="term-soscf-max-iter-scf">SOSCF_MAX_ITER (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Maximum number of second-order microiterations to perform.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 5</li>
</ul>
</dd>
<dt id="term-soscf-min-iter-scf">SOSCF_MIN_ITER (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Minimum number of second-order microiterations to perform.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-soscf-print-scf">SOSCF_PRINT (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Do we print the SOSCF microiterations?.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-soscf-start-convergence-scf">SOSCF_START_CONVERGENCE (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — When to start second-order SCF iterations based on gradient RMS.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1.0e-2</li>
</ul>
</dd>
<dt id="term-spinadapt-energies-ccenergy">SPINADAPT_ENERGIES (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Do print spin-adapted pair energies?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-ss-e-convergence-cceom">SS_E_CONVERGENCE (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-6</li>
</ul>
</dd>
<dt id="term-ss-r-convergence-cceom">SS_R_CONVERGENCE (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-6</li>
</ul>
</dd>
<dt id="term-ss-skip-diag-cceom">SS_SKIP_DIAG (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Do skip diagonalization of Hbar SS block?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-ss-vecs-per-root-cceom">SS_VECS_PER_ROOT (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — SS vectors stored per root</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 5</li>
</ul>
</dd>
<dt id="term-ssapt0-scale-fisapt">SSAPT0_SCALE (FISAPT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fisapt.html#apdx-fisapt"><span class="std std-ref">FISAPT</span></a> — Do sSAPT0 exchange-scaling with F-SAPT</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-stability-add-vectors-dcft">STABILITY_ADD_VECTORS (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> <strong>(Expert)</strong> — The number of vectors that can be added simultaneously into the subspace for Davidson&#8217;s diagonalization in stability check</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 20</li>
</ul>
</dd>
<dt id="term-stability-analysis-scf">STABILITY_ANALYSIS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NONE, CHECK, FOLLOW</li>
<li><strong>Default</strong>: NONE</li>
</ul>
</dd>
<dt id="term-stability-augment-space-tol-dcft">STABILITY_AUGMENT_SPACE_TOL (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> <strong>(Expert)</strong> — The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 0.1</li>
</ul>
</dd>
<dt id="term-stability-check-dcft">STABILITY_CHECK (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> <strong>(Expert)</strong> — Performs stability analysis of the DCFT energy</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-stability-convergence-dcft">STABILITY_CONVERGENCE (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> <strong>(Expert)</strong> — Controls the convergence of the Davidson&#8217;s diagonalization in stability check</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 1e-4</li>
</ul>
</dd>
<dt id="term-stability-max-space-size-dcft">STABILITY_MAX_SPACE_SIZE (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> <strong>(Expert)</strong> — The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the convergence (STABILITY_CONVERGENCE) is not satisfied</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 200</li>
</ul>
</dd>
<dt id="term-stability-n-eigenvalues-dcft">STABILITY_N_EIGENVALUES (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> <strong>(Expert)</strong> — The number of Hessian eigenvalues computed during the stability check</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 3</li>
</ul>
</dd>
<dt id="term-stability-n-guess-vectors-dcft">STABILITY_N_GUESS_VECTORS (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> <strong>(Expert)</strong> — The number of guess vectors used for Davidson&#8217;s diagonalization in stability check</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 20</li>
</ul>
</dd>
<dt id="term-step-type-optking">STEP_TYPE (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Geometry optimization step type, either Newton-Raphson or Rational Function Optimization</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: RFO, NR, SD, LINESEARCH_STATIC</li>
<li><strong>Default</strong>: RFO</li>
</ul>
</dd>
<dt id="term-symm-tol-optking">SYMM_TOL (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Symmetry tolerance for testing whether a mode is symmetric.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-conv"><span class="std std-ref">conv double</span></a></li>
<li><strong>Default</strong>: 0.05</li>
</ul>
</dd>
<dt id="term-symmetrize-occ">SYMMETRIZE (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Do symmetrize the GFM and OPDM in the EKT computations?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-t-thermo">T (THERMO)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__thermo.html#apdx-thermo"><span class="std std-ref">THERMO</span></a> — Temperature in Kelvin for thermodynamic analysis. Note that 273.15 is the value for IUPAC STP.</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 298.15</li>
</ul>
</dd>
<dt id="term-t2-coupled-ccenergy">T2_COUPLED (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> —</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-t3-ws-incore-ccenergy">T3_WS_INCORE (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> — Do build W intermediates required for cc3 in core memory?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-t3-ws-incore-cceom">T3_WS_INCORE (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Do build W intermediates required for eom_cc3 in core memory?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-t-amps-cchbar">T_AMPS (CCHBAR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cchbar.html#apdx-cchbar"><span class="std std-ref">CCHBAR</span></a> — Do compute the T amplitude equation matrix elements?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-tdhf-mem-safety-factor-cphf">TDHF_MEM_SAFETY_FACTOR (CPHF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cphf.html#apdx-cphf"><span class="std std-ref">CPHF</span></a> — Memory safety factor for allocating JK</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.75</li>
</ul>
</dd>
<dt id="term-tdm-detci">TDM (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — Do compute the transition density? Note: only transition densities between roots of the same symmetry will be evaluated. DETCI does not compute states of different irreps within the same computation; to do this, lower the symmetry of the computation.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-test-b-optking">TEST_B (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Do test B matrix?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-test-derivative-b-optking">TEST_DERIVATIVE_B (OPTKING)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__optking.html#apdx-optking"><span class="std std-ref">OPTKING</span></a> — Do test derivative B matrix?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-theta-points-scf">THETA_POINTS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Number of colatitude grid points for spherical potential integration</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 360</li>
</ul>
</dd>
<dt id="term-thickness-scf">THICKNESS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — Thickness (bohr) of a hard-sphere external potential</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 20.0</li>
</ul>
</dd>
<dt id="term-three-particle-dcft">THREE_PARTICLE (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> — Whether to compute three-particle energy correction or not</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: NONE, PERTURBATIVE</li>
<li><strong>Default</strong>: NONE</li>
</ul>
</dd>
<dt id="term-tikhonow-max-psimrcc">TIKHONOW_MAX (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — The cycle after which Tikhonow regularization is stopped. Set to zero to allow regularization in all iterations</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 5</li>
</ul>
</dd>
<dt id="term-tikhonow-omega-dcft">TIKHONOW_OMEGA (DCFT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dcft.html#apdx-dcft"><span class="std std-ref">DCFT</span></a> <strong>(Expert)</strong> — The shift applied to the denominator in the density cumulant update iterations</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-tikhonow-omega-psimrcc">TIKHONOW_OMEGA (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — The shift to apply to the denominators, {it c.f.} Taube and Bartlett, JCP, 130, 144112 (2009)</p>
<ul class="last simple">
<li><strong>Type</strong>: double</li>
<li><strong>Default</strong>: 0.0</li>
</ul>
</dd>
<dt id="term-tikhonow-triples-psimrcc">TIKHONOW_TRIPLES (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> <strong>(Expert)</strong> — Do use Tikhonow regularization in (T) computations?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-tile-sz-scf">TILE_SZ (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — The tile size for the distributed matrices</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 512</li>
</ul>
</dd>
<dt id="term-tpdm-detci">TPDM (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Do compute two-particle density matrix if not otherwise required? Warning: This will hold 4 dense active TPDM&#8217;s in memory</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-tpdm-abcd-type-occ">TPDM_ABCD_TYPE (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: DIRECT, COMPUTE</li>
<li><strong>Default</strong>: DIRECT</li>
</ul>
</dd>
<dt id="term-translate-psi4-cfour">TRANSLATE_PSI4 (CFOUR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cfour.html#apdx-cfour"><span class="std std-ref">CFOUR</span></a> — Do translate set Psi4 options to their cfour counterparts.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-triples-algorithm-psimrcc">TRIPLES_ALGORITHM (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — The type of algorithm to use for (T) computations</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: SPIN_ADAPTED, RESTRICTED, UNRESTRICTED</li>
<li><strong>Default</strong>: RESTRICTED</li>
</ul>
</dd>
<dt id="term-triples-diis-psimrcc">TRIPLES_DIIS (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — Do use DIIS extrapolation to accelerate convergence for iterative triples excitations?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-triples-iabc-type-dfocc">TRIPLES_IABC_TYPE (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — The algorithm to handle (ia|bc) type integrals that used for (T) correction.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: INCORE, AUTO, DIRECT, DISK</li>
<li><strong>Default</strong>: DISK</li>
</ul>
</dd>
<dt id="term-triples-low-memory-fnocc">TRIPLES_LOW_MEMORY (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> — Do use low memory option for triples contribution? Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-turn-on-actv-mcscf">TURN_ON_ACTV (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> —</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-uhf-noons-scf">UHF_NOONS (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> — The number of NOONs to print in a UHF calc</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: 3</li>
</ul>
</dd>
<dt id="term-units-globals">UNITS (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — Units used in geometry specification</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: BOHR, AU, A.U., ANGSTROMS, ANG, ANGSTROM</li>
<li><strong>Default</strong>: ANGSTROMS</li>
</ul>
</dd>
<dt id="term-update-detci">UPDATE (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — The update or correction vector formula, either <code class="docutils literal"><span class="pre">DAVIDSON</span></code> (default) or <code class="docutils literal"><span class="pre">OLSEN</span></code>.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: DAVIDSON, OLSEN</li>
<li><strong>Default</strong>: DAVIDSON</li>
</ul>
</dd>
<dt id="term-use-df-ints-fnocc">USE_DF_INTS (FNOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__fnocc.html#apdx-fnocc"><span class="std std-ref">FNOCC</span></a> <strong>(Expert)</strong> — Use 3-index integrals to generate 4-index ERI&#8217;s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation.</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-use-spin-sym-psimrcc">USE_SPIN_SYM (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — Do use symmetry to map equivalent determinants onto each other, for efficiency?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-use-spin-symmetry-psimrcc">USE_SPIN_SYMMETRY (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> <strong>(Expert)</strong> — Whether to use spin symmetry to map equivalent configurations onto each other, for efficiency</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-val-ex-level-detci">VAL_EX_LEVEL (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> — In a RAS CI, this is the additional excitation level for allowing electrons out of RAS I into RAS II. The maximum number of holes in RAS I is therefore <a class="reference internal" href="#term-ex-level-detci"><span class="xref std std-term">EX_LEVEL</span></a> + VAL_EX_LEVEL.</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 0</li>
</ul>
</dd>
<dt id="term-vecs-cc3-cceom">VECS_CC3 (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Vectors stored in CC3 computations</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 10</li>
</ul>
</dd>
<dt id="term-vecs-per-root-cceom">VECS_PER_ROOT (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> — Vectors stored per root</p>
<ul class="last simple">
<li><strong>Type</strong>: integer</li>
<li><strong>Default</strong>: 12</li>
</ul>
</dd>
<dt id="term-wabei-lowdisk-cchbar">WABEI_LOWDISK (CCHBAR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cchbar.html#apdx-cchbar"><span class="std std-ref">CCHBAR</span></a> — Do use the minimal-disk algorithm for Wabei? It&#8217;s VERY slow!</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-wfn-ccdensity">WFN (CCDENSITY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccdensity.html#apdx-ccdensity"><span class="std std-ref">CCDENSITY</span></a> <strong>(Expert)</strong> — Wavefunction type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: SCF</li>
</ul>
</dd>
<dt id="term-wfn-ccenergy">WFN (CCENERGY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccenergy.html#apdx-ccenergy"><span class="std std-ref">CCENERGY</span></a> <strong>(Expert)</strong> — Wavefunction type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: CCSD, CCSD_T, CCSD_AT, EOM_CCSD, LEOM_CCSD, BCCD, BCCD_T, CC2, CC3, EOM_CC2, EOM_CC3, CCSD_MVD</li>
<li><strong>Default</strong>: NONE</li>
</ul>
</dd>
<dt id="term-wfn-cceom">WFN (CCEOM)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cceom.html#apdx-cceom"><span class="std std-ref">CCEOM</span></a> <strong>(Expert)</strong> — Wavefunction type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: EOM_CCSD, EOM_CC2, EOM_CC3</li>
<li><strong>Default</strong>: EOM_CCSD</li>
</ul>
</dd>
<dt id="term-wfn-cchbar">WFN (CCHBAR)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cchbar.html#apdx-cchbar"><span class="std std-ref">CCHBAR</span></a> <strong>(Expert)</strong> — Wavefunction type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: SCF</li>
</ul>
</dd>
<dt id="term-wfn-cclambda">WFN (CCLAMBDA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cclambda.html#apdx-cclambda"><span class="std std-ref">CCLAMBDA</span></a> <strong>(Expert)</strong> — Wavefunction type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: SCF</li>
</ul>
</dd>
<dt id="term-wfn-ccresponse">WFN (CCRESPONSE)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccresponse.html#apdx-ccresponse"><span class="std std-ref">CCRESPONSE</span></a> <strong>(Expert)</strong> — Wavefunction type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: SCF</li>
</ul>
</dd>
<dt id="term-wfn-cctransort">WFN (CCTRANSORT)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cctransort.html#apdx-cctransort"><span class="std std-ref">CCTRANSORT</span></a> <strong>(Expert)</strong> — Wavefunction type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-wfn-cctriples">WFN (CCTRIPLES)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cctriples.html#apdx-cctriples"><span class="std std-ref">CCTRIPLES</span></a> <strong>(Expert)</strong> — Wavefunction type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: SCF</li>
</ul>
</dd>
<dt id="term-wfn-detci">WFN (DETCI)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__detci.html#apdx-detci"><span class="std std-ref">DETCI</span></a> <strong>(Expert)</strong> — Wavefunction type. This should be set automatically from the calling Psithon function.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: DETCI, CI, ZAPTN, DETCAS, CASSCF, RASSCF</li>
<li><strong>Default</strong>: DETCI</li>
</ul>
</dd>
<dt id="term-wfn-globals">WFN (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> <strong>(Expert)</strong> — Wavefunction type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: SCF</li>
</ul>
</dd>
<dt id="term-wfn-scf">WFN (SCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__scf.html#apdx-scf"><span class="std std-ref">SCF</span></a> <strong>(Expert)</strong> — Wavefunction type</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: SCF</li>
<li><strong>Default</strong>: SCF</li>
</ul>
</dd>
<dt id="term-wfn-sym-mcscf">WFN_SYM (MCSCF)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__mcscf.html#apdx-mcscf"><span class="std std-ref">MCSCF</span></a> — The symmetry of the SCF wavefunction.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: A, AG, AU, AP, APP, A1, A2, B, BG, BU, B1, B2, B3, B1G, B2G, B3G, B1U, B2U, B3U, 0, 1, 2, 3, 4, 5, 6, 7, 8</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-wfn-sym-psimrcc">WFN_SYM (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — The symmetry of the target wavefunction, specified either by Schönflies symbol, or irrep number (in Cotton ordering)</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: A, AG, AU, AP, APP, A1, A2, B, BG, BU, B1, B2, B3, B1G, B2G, B3G, B1U, B2U, B3U, 0, 1, 2, 3, 4, 5, 6, 7, 8</li>
<li><strong>Default</strong>: 1</li>
</ul>
</dd>
<dt id="term-wfn-type-dfocc">WFN_TYPE (DFOCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__dfocc.html#apdx-dfocc"><span class="std std-ref">DFOCC</span></a> — Type of the wavefunction.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: DF-OMP2, DF-OMP3, DF-OLCCD, DF-OMP2.5, DFGRAD, DF-CCSD, DF-CCD, DF-CCSD(T), DF-CCSD(AT), QCHF</li>
<li><strong>Default</strong>: DF-OMP2</li>
</ul>
</dd>
<dt id="term-wfn-type-occ">WFN_TYPE (OCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__occ.html#apdx-occ"><span class="std std-ref">OCC</span></a> — Type of the wavefunction.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Possible Values</strong>: OMP2, OMP3, OCEPA, OMP2.5</li>
<li><strong>Default</strong>: OMP2</li>
</ul>
</dd>
<dt id="term-writer-file-label-globals">WRITER_FILE_LABEL (GLOBALS)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__globals.html#apdx-globals"><span class="std std-ref">GLOBALS</span></a> — Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive.</p>
<ul class="last simple">
<li><strong>Type</strong>: string</li>
<li><strong>Default</strong>: No Default</li>
</ul>
</dd>
<dt id="term-xi-ccdensity">XI (CCDENSITY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccdensity.html#apdx-ccdensity"><span class="std std-ref">CCDENSITY</span></a> — Do compute Xi?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-xi-connect-ccdensity">XI_CONNECT (CCDENSITY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccdensity.html#apdx-ccdensity"><span class="std std-ref">CCDENSITY</span></a> <strong>(Expert)</strong> — Do require <span class="math">\(\bar{H}\)</span> and <span class="math">\(R\)</span> to be connected?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-zero-internal-amps-psimrcc">ZERO_INTERNAL_AMPS (PSIMRCC)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__psimrcc.html#apdx-psimrcc"><span class="std std-ref">PSIMRCC</span></a> — Do zero the internal amplitudes, i.e., those that map reference determinants onto each other?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: true</li>
</ul>
</dd>
<dt id="term-zeta-ccdensity">ZETA (CCDENSITY)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__ccdensity.html#apdx-ccdensity"><span class="std std-ref">CCDENSITY</span></a> — Do use zeta?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
<dt id="term-zeta-cclambda">ZETA (CCLAMBDA)</dt>
<dd><p class="first"><a class="reference internal" href="autodir_options_c/module__cclambda.html#apdx-cclambda"><span class="std std-ref">CCLAMBDA</span></a> — Do use zeta?</p>
<ul class="last simple">
<li><strong>Type</strong>: <a class="reference internal" href="notes_c.html#op-c-boolean"><span class="std std-ref">boolean</span></a></li>
<li><strong>Default</strong>: false</li>
</ul>
</dd>
</dl>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
        <p class="logo"><a href="index.html" title="index">
          <img class="logo" src="_static/psi4square.png" alt="Logo"/>
        </a></p><!-- 
#
# @BEGIN LICENSE
#
# Psi4: an open-source quantum chemistry software package
#
# Copyright (c) 2007-2017 The Psi4 Developers.
#
# The copyrights for code used from other parties are included in
# the corresponding files.
#
# This file is part of Psi4.
#
# Psi4 is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, version 3.
#
# Psi4 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with Psi4; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# @END LICENSE
# -->


<div id="searchbox" style="display: none" role="search">
  <!--<h3>Quick search</h3>-->
    <form class="search" action="search.html" method="get">
      <!--<div><input type="text" name="q" placeholder="search docs" /></div>-->
      <div><input type="text" name="q" placeholder="&#xF002;" style="font-family:FontAwesome, Ariel" /></div>
      <!--<div><input type="submit" value="Go" /></div>-->
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="relbar-bottom">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >Index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="autodoc_options_c_bymodule.html" title="Keywords by Module"
             ><i class="fa fa-long-arrow-right fa-lg"></i></a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="appendices.html" title="Appendices"
             ><i class="fa fa-long-arrow-left fa-lg"></i></a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="index.html" title="Table Of Contents"
             ><i class="fa fa-book fa-lg"></i></a> &nbsp; &nbsp;</li>
    <li><a href="http://psicode.org/"><i class="fa fa-home fa-lg"></i></a></li>
    <li><a href="http://github.com/psi4/psi4"><i class="fa fa-github fa-lg"></i></a></li>
    <li><a href="http://forum.psicode.org"><i class="fa fa-comments-o fa-lg"></i></a></li>
    <li><a href="https://github.com/psi4/psi4/edit/master/doc/sphinxman/source/autodoc_glossary_options_c.rst"><i class="fa fa-pencil fa-lg"></i></a></li>
    <li style="color: #1a4162">&nbsp;&middot;&nbsp;</li>
    <li><a href="https://github.com/psi4/psi4/tree/add49b9">1.1</a></li>
    <li style="color: #1a4162">&nbsp;&middot;&nbsp;</li>
    <li class="nav-item nav-item-0"><a href="index.html">
        <span style="font-family: Optima, sans-serif;">P<span style="font-size: 82%;">SI</span>4</span>
        </a><i class="fa fa-angle-double-right" style="color: #a2a7b3; text-shadow: none;"></i></li>

          <li class="nav-item nav-item-1"><a href="appendices.html" >Appendices</a><i class="fa fa-angle-double-right" style="color: #a2a7b3; text-shadow: none;"></i></li> 
      </ul>
    </div>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, The Psi4 Project.
      Last updated on Wednesday, 17 May 2017 05:47AM.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.6.
    </div>
    <!-- cloud_sptheme 1.4 -->
  </body>
</html>