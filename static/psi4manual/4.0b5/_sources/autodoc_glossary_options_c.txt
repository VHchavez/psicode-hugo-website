
.. include:: autodoc_abbr_options_c.rst


.. _`apdx:options_c_alpha`:

Keywords by Alpha
=================

.. glossary::
   :sorted:

   BENCH (GLOBALS)
      :ref:`apdx:GLOBALS` |w---w| Some codes (DFT) can dump benchmarking data to separate output files

      * **Type**: integer
      * **Default**: 0

   DOCC (GLOBALS)
      :ref:`apdx:GLOBALS` |w---w| An array containing the number of doubly-occupied orbitals per irrep (in Cotton order)

      * **Type**: array
      * **Default**: No Default

   FREEZE_CORE (GLOBALS)
      :ref:`apdx:GLOBALS` |w---w| Specifies how many core orbitals to freeze in correlated computations. ``TRUE`` will default to freezing the standard default number of core orbitals. For PSI, the standard number of core orbitals is the number of orbitals in the nearest previous noble gas atom. More precise control over the number of frozen orbitals can be attained by using the keywords |globals__num_frozen_docc| (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or |globals__frozen_docc| (gives the number of orbitals to freeze per irreducible representation)

      * **Type**: string
      * **Possible Values**: FALSE, TRUE
      * **Default**: FALSE

   FROZEN_DOCC (GLOBALS)
      :ref:`apdx:GLOBALS` |w---w| An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps |globals__num_frozen_docc| and |globals__freeze_core|.

      * **Type**: array
      * **Default**: No Default

   FROZEN_UOCC (GLOBALS)
      :ref:`apdx:GLOBALS` |w---w| An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps |globals__num_frozen_uocc|.

      * **Type**: array
      * **Default**: No Default

   NUM_FROZEN_DOCC (GLOBALS)
      :ref:`apdx:GLOBALS` |w---w| The number of core orbitals to freeze in later correlated computations. This trumps |globals__freeze_core|.

      * **Type**: integer
      * **Default**: 0

   NUM_FROZEN_UOCC (GLOBALS)
      :ref:`apdx:GLOBALS` |w---w| The number of virtual orbitals to freeze in later correlated computations.

      * **Type**: integer
      * **Default**: 0

   PRINT (GLOBALS)
      :ref:`apdx:GLOBALS` |w---w| The amount of information to print to the output file. 1 prints basic information, and higher levels print more information. A value of 5 will print very large amounts of debugging information.

      * **Type**: integer
      * **Default**: 1

   PROPERTIES (GLOBALS)
      :ref:`apdx:GLOBALS` |w---w| List of properties to compute

      * **Type**: array
      * **Default**: No Default

   PROPERTIES_ORIGIN (GLOBALS)
      :ref:`apdx:GLOBALS` |w---w| Either a set of 3 coordinates, or a string (see manual) describing the origin about which one-electron properties are computed

      * **Type**: array
      * **Default**: No Default

   PUREAM (GLOBALS)
      :ref:`apdx:GLOBALS` |w---w| Do use pure angular momentum basis functions? If not explicitly set, the default comes from the basis set.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   SOCC (GLOBALS)
      :ref:`apdx:GLOBALS` |w---w| An array containing the number of singly-occupied orbitals per irrep (in Cotton order). The value of |globals__docc| should also be set.

      * **Type**: array
      * **Default**: No Default

   UNITS (GLOBALS)
      :ref:`apdx:GLOBALS` |w---w| Units used in geometry specification

      * **Type**: string
      * **Possible Values**: BOHR, AU, A.U., ANGSTROMS, ANG, ANGSTROM
      * **Default**: ANGSTROMS

   WRITER_FILE_LABEL (GLOBALS)
      :ref:`apdx:GLOBALS` |w---w| Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive.

      * **Type**: string
      * **Default**: No Default

   CACHELEVEL (ADC)
      :ref:`apdx:ADC` |w---w| How to cache quantities within the DPD library

      * **Type**: integer
      * **Default**: 2

   MEMORY (ADC)
      :ref:`apdx:ADC` |w---w| The amount of memory available (in Mb)

      * **Type**: integer
      * **Default**: 1000

   NEWTON_CONVERGENCE (ADC)
      :ref:`apdx:ADC` |w---w| The convergence criterion for pole searching step.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-7

   NORM_TOLERANCE (ADC)
      :ref:`apdx:ADC` |w---w| The cutoff norm of residual vector in SEM step.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-6

   NUM_AMPS_PRINT (ADC)
      :ref:`apdx:ADC` |w---w| Number of components of transition amplitudes printed

      * **Type**: integer
      * **Default**: 5

   POLE_MAXITER (ADC)
      :ref:`apdx:ADC` |w---w| Maximum iteration number in pole searching

      * **Type**: integer
      * **Default**: 20

   PR (ADC)
      :ref:`apdx:ADC` |w---w| Do use the partial renormalization scheme for the ground state wavefunction?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   REFERENCE (ADC)
      :ref:`apdx:ADC` |w---w| Reference wavefunction type

      * **Type**: string
      * **Possible Values**: RHF
      * **Default**: RHF

   ROOTS_PER_IRREP (ADC)
      :ref:`apdx:ADC` |w---w| The poles per irrep vector

      * **Type**: array
      * **Default**: No Default

   SEM_MAXITER (ADC)
      :ref:`apdx:ADC` |w---w| Maximum iteration number in simultaneous expansion method

      * **Type**: integer
      * **Default**: 30

   AO_BASIS (CCDENSITY)
      :ref:`apdx:CCDENSITY` |w---w| The algorithm to use for the :math:`\left<VV||VV\right>` terms

      * **Type**: string
      * **Possible Values**: NONE, DISK, DIRECT
      * **Default**: NONE

   CACHELEVEL (CCDENSITY)
      :ref:`apdx:CCDENSITY` |w---w| The amount of cacheing of data to perform

      * **Type**: integer
      * **Default**: 2

   GAUGE (CCDENSITY)
      :ref:`apdx:CCDENSITY` |w---w| The type of gauge to use for properties

      * **Type**: string
      * **Default**: LENGTH

   INTS_TOLERANCE (CCDENSITY)
      :ref:`apdx:CCDENSITY` |w---w| Minimum absolute value below which integrals are neglected.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-14

   ONEPDM (CCDENSITY)
      :ref:`apdx:CCDENSITY` |w---w| Do compute one-particle density matrix?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   ONEPDM_GRID_CUTOFF (CCDENSITY)
      :ref:`apdx:CCDENSITY` |w---w| Cutoff (e/A^3) for printing one-particle density matrix values on a grid

      * **Type**: double
      * **Default**: 1.0e-30

   ONEPDM_GRID_DUMP (CCDENSITY)
      :ref:`apdx:CCDENSITY` |w---w| Write one-particle density matrix on a grid to file opdm.dx

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   ONEPDM_GRID_STEPSIZE (CCDENSITY)
      :ref:`apdx:CCDENSITY` |w---w| Stepsize (Angstrom) for one-particle density matrix values on a grid

      * **Type**: double
      * **Default**: 0.1

   OPDM_RELAX (CCDENSITY)
      :ref:`apdx:CCDENSITY` |w---w| Do relax the one-particle density matrix?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   PROP_ALL (CCDENSITY)
      :ref:`apdx:CCDENSITY` |w---w| Compute non-relaxed properties for all excited states.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   PROP_ROOT (CCDENSITY)
      :ref:`apdx:CCDENSITY` |w---w| Root number (within its irrep) for computing properties

      * **Type**: integer
      * **Default**: 1

   PROP_SYM (CCDENSITY)
      :ref:`apdx:CCDENSITY` |w---w| The symmetry of states

      * **Type**: integer
      * **Default**: 1

   REFERENCE (CCDENSITY)
      :ref:`apdx:CCDENSITY` |w---w| Reference wavefunction type

      * **Type**: string
      * **Default**: RHF

   ROOTS_PER_IRREP (CCDENSITY)
      :ref:`apdx:CCDENSITY` |w---w| The number of electronic states to computed, per irreducible representation

      * **Type**: array
      * **Default**: No Default

   XI (CCDENSITY)
      :ref:`apdx:CCDENSITY` |w---w| Do compute Xi?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   ZETA (CCDENSITY)
      :ref:`apdx:CCDENSITY` |w---w| Do use zeta?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   ABCD (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Type of ABCD algorithm will be used

      * **Type**: string
      * **Possible Values**: NEW, OLD
      * **Default**: NEW

   ANALYZE (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Do analyze T2 amplitudes

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest :math:`T_1` amplitude. Default adjusts depending on |ccenergy__e_convergence|.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-5

   CACHELEVEL (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., :math:`\langle ij | ab \rangle>` integrals) may be held in the cache.

      * **Type**: integer
      * **Default**: 2

   CACHETYPE (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of ``LOW`` selects a "low priority" scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a "least recently used" scheme in which the oldest item in the cache will be the first one deleted.

      * **Type**: string
      * **Possible Values**: LOW, LRU
      * **Default**: LOW

   CC_NUM_THREADS (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Number of threads

      * **Type**: integer
      * **Default**: 1

   CC_OS_SCALE (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Coupled-cluster opposite-spin scaling value

      * **Type**: double
      * **Default**: 1.27

   CC_SS_SCALE (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Coupled-cluster same-spin scaling value

      * **Type**: double
      * **Default**: 1.13

   DF_BASIS_MP2 (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Auxiliary basis set for MP2 density fitting calculations

      * **Type**: string
      * **Possible Values**: :ref:`basis string <apdx:basisElement>`
      * **Default**: No Default

   DF_LMP2 (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Do use density fitting? Turned on with specification of fitting basis.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   DIAG_METHOD (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Diagonalization method for the CI matrix

      * **Type**: string
      * **Possible Values**: DAVIDSON, FULL
      * **Default**: DAVIDSON

   DIIS (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Do use DIIS extrapolation to accelerate convergence?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   DIIS_MAX_VECS (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Maximum number of error vectors stored for DIIS extrapolation

      * **Type**: integer
      * **Default**: 5

   DIIS_START_ITER (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Iteration at which to start DIIS extrapolation

      * **Type**: integer
      * **Default**: 3

   DISTANT_PAIR_CUTOFF (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Distant pair cutoff

      * **Type**: double
      * **Default**: 8.0

   DOMAINS (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| 

      * **Type**: array
      * **Default**: No Default

   DOMAIN_PRINT (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Do print the domains?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   DOMAIN_PRINT_EXIT (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Do exit after printing the domains?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   E_CONVERGENCE (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Convergence criterion for energy (change). See Table// :ref:`Post-SCF Convergence <table:conv_corl>` for default convergence// criteria for different calculation types.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-6

   FOCK_TOLERANCE (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Minimum absolute value below which parts of the Fock matrix are skipped.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-2

   INTS_TOLERANCE (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Minimum absolute value below which integrals are neglected.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-7

   LOCAL (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Do simulate the effects of local correlation techniques?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   LOCAL_AMPS_PRINT_CUTOFF (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Cutoff value for printing local amplitudes

      * **Type**: double
      * **Default**: 0.60

   LOCAL_CPHF_CUTOFF (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Cutoff value for local-coupled-perturbed-Hartree-Fock

      * **Type**: double
      * **Default**: 0.10

   LOCAL_CUTOFF (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Localization cutoff

      * **Type**: double
      * **Default**: 0.02

   LOCAL_GHOST (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| 

      * **Type**: integer
      * **Default**: -1

   LOCAL_METHOD (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Type of local-CIS scheme to be simulated. ``WERNER`` selects the method// developed by H.-J. Werner and co-workers, and ``AOBASIS`` selects the method// developed by G.E. Scuseria and co-workers.

      * **Type**: string
      * **Possible Values**: AOBASIS, WERNER
      * **Default**: WERNER

   LOCAL_PAIRDEF (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Definition of local pair domains, default is BP, Boughton-Pulay.

      * **Type**: string
      * **Possible Values**: BP, RESPONSE
      * **Default**: BP

   LOCAL_WEAKP (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Desired treatment of "weak pairs" in the local-CIS method. A value of// ``NEGLECT`` ignores weak pairs entirely. A value of ``NONE`` treats weak pairs in// the same manner as strong pairs. A value of MP2 uses second-order perturbation// theory to correct the local-CIS energy computed with weak pairs ignored.

      * **Type**: string
      * **Possible Values**: MP2, NEGLECT, NONE
      * **Default**: MP2

   MAXITER (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Maximum number of iterations

      * **Type**: integer
      * **Default**: 50

   MEMORY (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| The amount of memory available (in Mb)

      * **Type**: integer
      * **Default**: 2000

   MP2_AMPS_PRINT (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Do print the MP2 amplitudes which are the starting guesses for RHF and UHF reference functions?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   MP2_OS_SCALE (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| The scale factor used for opposite-spin pairs in SCS computations

      * **Type**: double
      * **Default**: 6.0/5.0

   MP2_SS_SCALE (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| The scale factor used for same-spin pairs in SCS computations

      * **Type**: double
      * **Default**: 1.0/3.0

   NEGLECT_DISTANT_PAIR (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Do neglect distant pairs?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   NEW_TRIPLES (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Do use new triples?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   NUM_AMPS_PRINT (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Number of important :math:`t_1` and :math:`t_2` amplitudes to print

      * **Type**: integer
      * **Default**: 10

   PAIR_ENERGIES_PRINT (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Do print MP2 and CCSD pair energies for RHF references?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   PROPERTY (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| The response property desired. Acceptable values are ``POLARIZABILITY`` (default) for dipole-polarizabilities, ``ROTATION`` for specific rotations, ``ROA`` for Raman Optical Activity, and ``ALL`` for all of the above.

      * **Type**: string
      * **Possible Values**: POLARIZABILITY, ROTATION, MAGNETIZABILITY, ROA, ALL
      * **Default**: POLARIZABILITY

   REFERENCE (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Reference wavefunction type

      * **Type**: string
      * **Possible Values**: RHF
      * **Default**: RHF

   RESTART (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Do restart the coupled-cluster iterations from old :math:`t_1` and :math:`t_2` amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   ROOTS_PER_IRREP (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| The number of electronic states to computed, per irreducible// representation

      * **Type**: array
      * **Default**: No Default

   R_CONVERGENCE (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Convergence criterion for T2 amplitudes (RMS change).

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-5

   SCREEN_INTS (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Do screen integrals?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   SCS (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Do spin-component-scaled MP2 (SCS-MP2)?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   SCSN_MP2 (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Do SCS-MP2 with parameters optimized for nucleic acids?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   SCS_CCSD (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Do spin-component-scaled CCSD

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   SCS_MP2 (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Do spin-component-scaled MP2 (SCS-MP2)?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   SCS_N (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Do SCS-MP2 with parameters optimized for nucleic acids?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   SEMICANONICAL (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Convert ROHF MOs to semicanonical MOs

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   SPINADAPT_ENERGIES (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Do print spin-adapted pair energies?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   T2_COUPLED (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   T3_WS_INCORE (CCENERGY)
      :ref:`apdx:CCENERGY` |w---w| Do build W intermediates required for cc3 in core memory?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   ABCD (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Type of ABCD algorithm will be used

      * **Type**: string
      * **Possible Values**: NEW, OLD
      * **Default**: NEW

   CACHELEVEL (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., :math:`\langle ij | ab \rangle>` integrals) may be held in the cache.

      * **Type**: integer
      * **Default**: 2

   CACHETYPE (CCEOM)
      :ref:`apdx:CCEOM` |w---w| The criterion used to retain/release cached data

      * **Type**: string
      * **Possible Values**: LOW, LRU
      * **Default**: LRU

   CC3_FOLLOW_ROOT (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Do turn on root following for CC3

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   CC_NUM_THREADS (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Number of threads

      * **Type**: integer
      * **Default**: 1

   COLLAPSE_WITH_LAST (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Do collapse with last vector?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   COMPLEX_TOLERANCE (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Complex tolerance applied in CCEOM computations

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-12

   EOM_GUESS (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = ``SINGLES``, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = ``DISK``, guess vectors from a previous computation will be read from disk. If EOM_GUESS = ``INPUT``, guess vectors will be specified in user input. The latter method is not currently available.

      * **Type**: string
      * **Possible Values**: SINGLES, DISK, INPUT
      * **Default**: SINGLES

   EOM_REFERENCE (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Reference wavefunction type for EOM computations

      * **Type**: string
      * **Possible Values**: RHF, ROHF, UHF
      * **Default**: RHF

   E_CONVERGENCE (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table :ref:`Post-SCF Convergence <table:conv_corl>` for default convergence criteria for different calculation types.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-6

   FULL_MATRIX (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Do use full effective Hamiltonian matrix?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   LOCAL (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Do simulate the effects of local correlation techniques?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   LOCAL_CUTOFF (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996).

      * **Type**: double
      * **Default**: 0.02

   LOCAL_DO_SINGLES (CCEOM)
      :ref:`apdx:CCEOM` |w---w| 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   LOCAL_FILTER_SINGLES (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Do apply local filtering to singles amplitudes?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   LOCAL_GHOST (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Permit ghost atoms to hold projected atomic orbitals to include in the virtual space in local-EOM-CCSD calculations

      * **Type**: integer
      * **Default**: -1

   LOCAL_METHOD (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Type of local-CCSD scheme to be simulated. ``WERNER`` selects the method developed by H.-J. Werner and co-workers, and ``AOBASIS`` selects the method developed by G.E. Scuseria and co-workers (currently inoperative).

      * **Type**: string
      * **Possible Values**: WERNER, AOBASIS
      * **Default**: WERNER

   LOCAL_PRECONDITIONER (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Preconditioner will be used in local CC computations

      * **Type**: string
      * **Possible Values**: HBAR, FOCK
      * **Default**: HBAR

   LOCAL_WEAKP (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Desired treatment of "weak pairs" in the local-CCSD method. A value of ``NEGLECT`` ignores weak pairs entirely. A value of ``NONE`` treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored.

      * **Type**: string
      * **Possible Values**: NONE, MP2, NEGLECT
      * **Default**: NONE

   MAXITER (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Maximum number of iterations

      * **Type**: integer
      * **Default**: 80

   NEW_TRIPLES (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Do use new triples?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   NUM_AMPS_PRINT (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Number of important CC amplitudes to print

      * **Type**: integer
      * **Default**: 5

   PROP_ROOT (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Root number (within its irrep) for computing properties. Defaults to highest root requested.

      * **Type**: integer
      * **Default**: 0

   PROP_SYM (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Symmetry of the state to compute properties. Defaults to last irrep for which states are requested.

      * **Type**: integer
      * **Default**: 1

   REFERENCE (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Reference wavefunction type

      * **Type**: string
      * **Possible Values**: RHF, ROHF, UHF
      * **Default**: RHF

   RESTART_EOM_CC3 (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Do restart from on-disk?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   RHF_TRIPLETS (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Do form a triplet state from RHF reference?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   ROOTS_PER_IRREP (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Number of excited states per irreducible representation for EOM-CC and CC-LR calculations. Irreps denote the final state symmetry, not the symmetry of the transition.

      * **Type**: array
      * **Default**: No Default

   R_CONVERGENCE (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Convergence criterion for norm of the residual vector in the Davidson algorithm for CC-EOM.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-6

   SCHMIDT_ADD_RESIDUAL_TOLERANCE (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Minimum absolute value above which a guess vector to a root is added to the Davidson algorithm in the EOM-CC iterative procedure.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-3

   SEMICANONICAL (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Convert ROHF MOs to semicanonical MOs

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   SINGLES_PRINT (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Do print information on the iterative solution to the single-excitation EOM-CC problem used as a guess to full EOM-CC?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   SS_E_CONVERGENCE (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-6

   SS_R_CONVERGENCE (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-6

   SS_SKIP_DIAG (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Do skip diagonalization of Hbar SS block?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   SS_VECS_PER_ROOT (CCEOM)
      :ref:`apdx:CCEOM` |w---w| SS vectors stored per root

      * **Type**: integer
      * **Default**: 5

   T3_WS_INCORE (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Do build W intermediates required for eom_cc3 in core memory?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   VECS_CC3 (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Vectors stored in CC3 computations

      * **Type**: integer
      * **Default**: 10

   VECS_PER_ROOT (CCEOM)
      :ref:`apdx:CCEOM` |w---w| Vectors stored per root

      * **Type**: integer
      * **Default**: 12

   CACHELEVEL (CCHBAR)
      :ref:`apdx:CCHBAR` |w---w| Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., :math:`\langle ij | ab \rangle>` integrals) may be held in the cache.

      * **Type**: integer
      * **Default**: 2

   EOM_REFERENCE (CCHBAR)
      :ref:`apdx:CCHBAR` |w---w| Reference wavefunction type for EOM computations

      * **Type**: string
      * **Default**: RHF

   T_AMPS (CCHBAR)
      :ref:`apdx:CCHBAR` |w---w| Do compute the Tamplitude equation matrix elements?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   WABEI_LOWDISK (CCHBAR)
      :ref:`apdx:CCHBAR` |w---w| Do use the minimal-disk algorithm for Wabei? It's VERY slow!

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   ABCD (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` |w---w| Type of ABCD algorithm will be used

      * **Type**: string
      * **Default**: NEW

   AO_BASIS (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` |w---w| The algorithm to use for the :math:`\left<VV||VV\right>` terms

      * **Type**: string
      * **Possible Values**: NONE, DISK, DIRECT
      * **Default**: NONE

   CACHELEVEL (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` |w---w| Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., :math:`\langle ij | ab \rangle>` integrals) may be held in the cache.

      * **Type**: integer
      * **Default**: 2

   CAS_FILES_WRITE (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` |w---w| Do write the OEI, TEI, OPDM, TPDM, and Lagrangian files in canonical form, Pitzer order?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   DIIS (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` |w---w| Do use DIIS extrapolation to accelerate convergence?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   FOLLOW_ROOT (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` |w---w| Root to get OPDM

      * **Type**: integer
      * **Default**: 1

   LOCAL (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` |w---w| Do simulate the effects of local correlation techniques?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   LOCAL_CPHF_CUTOFF (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` |w---w| Cutoff value for local-coupled-perturbed-Hartree-Fock

      * **Type**: double
      * **Default**: 0.10

   LOCAL_CUTOFF (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` |w---w| Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996).

      * **Type**: double
      * **Default**: 0.02

   LOCAL_FILTER_SINGLES (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` |w---w| Do apply local filtering to single de-excitation (\ :math:`\lambda 1` amplitudes?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   LOCAL_METHOD (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` |w---w| Type of local-CCSD scheme to be simulated. ``WERNER`` (unique avaliable option) selects the method developed by H.-J. Werner and co-workers.

      * **Type**: string
      * **Default**: WERNER

   LOCAL_PAIRDEF (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` |w---w| Definition of local pair domains

      * **Type**: string
      * **Default**: No Default

   LOCAL_WEAKP (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` |w---w| Desired treatment of "weak pairs" in the local-CCSD method. The value of ``NONE`` (unique avaliable option) treats weak pairs in the same manner as strong pairs.

      * **Type**: string
      * **Default**: NONE

   MAXITER (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` |w---w| Maximum number of iterations

      * **Type**: integer
      * **Default**: 50

   NUM_AMPS_PRINT (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` |w---w| Number of important CC amplitudes per excitation level to print. CC analog to |detci__num_dets_print|.

      * **Type**: integer
      * **Default**: 10

   PROP_ALL (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` |w---w| Compute unrelaxed properties for all excited states.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   PROP_ROOT (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` |w---w| Root number (within its irrep) for computing properties

      * **Type**: integer
      * **Default**: 1

   PROP_SYM (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` |w---w| The symmetry of states

      * **Type**: integer
      * **Default**: 1

   RESTART (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` |w---w| Do restart the coupled-cluster iterations from old :math:`\lambda_1` and :math:`\lambda_2` amplitudes?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   ROOTS_PER_IRREP (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` |w---w| The number of electronic states to computed, per irreducible representation

      * **Type**: array
      * **Default**: No Default

   R_CONVERGENCE (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` |w---w| Convergence criterion for wavefunction (change) in CC lambda-amplitude equations.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-7

   SEKINO (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` |w---w| Do Sekino-Bartlett size-extensive model-III?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   ZETA (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` |w---w| Do use zeta?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   ABCD (CCRESPONSE)
      :ref:`apdx:CCRESPONSE` |w---w| Type of ABCD algorithm will be used

      * **Type**: string
      * **Default**: NEW

   ANALYZE (CCRESPONSE)
      :ref:`apdx:CCRESPONSE` |w---w| Do analyze X2 amplitudes

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   CACHELEVEL (CCRESPONSE)
      :ref:`apdx:CCRESPONSE` |w---w| Cacheing level for libdpd

      * **Type**: integer
      * **Default**: 2

   DIIS (CCRESPONSE)
      :ref:`apdx:CCRESPONSE` |w---w| Do use DIIS extrapolation to accelerate convergence?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   GAUGE (CCRESPONSE)
      :ref:`apdx:CCRESPONSE` |w---w| Specifies the choice of representation of the electric dipole operator. Acceptable values are ``LENGTH`` for the usual length-gauge representation, ``VELOCITY`` for the modified velocity-gauge representation in which the static-limit optical rotation tensor is subtracted from the frequency- dependent tensor, or ``BOTH``. Note that, for optical rotation calculations, only the choices of ``VELOCITY`` or ``BOTH`` will yield origin-independent results.

      * **Type**: string
      * **Possible Values**: LENGTH, VELOCITY, BOTH
      * **Default**: LENGTH

   LINEAR (CCRESPONSE)
      :ref:`apdx:CCRESPONSE` |w---w| Do Bartlett size-extensive linear model?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   LOCAL (CCRESPONSE)
      :ref:`apdx:CCRESPONSE` |w---w| Do simulate local correlation?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   LOCAL_CPHF_CUTOFF (CCRESPONSE)
      :ref:`apdx:CCRESPONSE` |w---w| Cutoff value for local-coupled-perturbed-Hartree-Fock

      * **Type**: double
      * **Default**: 0.10

   LOCAL_CUTOFF (CCRESPONSE)
      :ref:`apdx:CCRESPONSE` |w---w| Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996).

      * **Type**: double
      * **Default**: 0.01

   LOCAL_FILTER_SINGLES (CCRESPONSE)
      :ref:`apdx:CCRESPONSE` |w---w| Do apply local filtering to single excitation amplitudes?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   LOCAL_METHOD (CCRESPONSE)
      :ref:`apdx:CCRESPONSE` |w---w| Type of local-CCSD scheme to be simulated. ``WERNER`` (unique avaliable option) selects the method developed by H.-J. Werner and co-workers.

      * **Type**: string
      * **Default**: WERNER

   LOCAL_PAIRDEF (CCRESPONSE)
      :ref:`apdx:CCRESPONSE` |w---w| Definition of local pair domains

      * **Type**: string
      * **Default**: NONE

   LOCAL_WEAKP (CCRESPONSE)
      :ref:`apdx:CCRESPONSE` |w---w| Desired treatment of "weak pairs" in the local-CCSD method. The value of ``NONE`` (unique avaliable option) treats weak pairs in the same manner as strong pairs.

      * **Type**: string
      * **Default**: NONE

   MAXITER (CCRESPONSE)
      :ref:`apdx:CCRESPONSE` |w---w| Maximum number of iterations to converge perturbed amplitude equations

      * **Type**: integer
      * **Default**: 50

   NUM_AMPS_PRINT (CCRESPONSE)
      :ref:`apdx:CCRESPONSE` |w---w| Number of important CC amplitudes per excitation level to print. CC analog to |detci__num_dets_print|.

      * **Type**: integer
      * **Default**: 5

   OMEGA (CCRESPONSE)
      :ref:`apdx:CCRESPONSE` |w---w| Array that specifies the desired frequencies of the incident// radiation field in CCLR calculations. If only one element is// given, the units will be assumed to be atomic units. If more// than one element is given, then the units must be specified as the final// element of the array. Acceptable units are ``HZ``, ``NM``, ``EV``, and ``AU``.

      * **Type**: array
      * **Default**: No Default

   PROPERTY (CCRESPONSE)
      :ref:`apdx:CCRESPONSE` |w---w| Array that specifies the desired frequencies of the incident// radiation field in CCLR calculations. If only one element is// given, the units will be assumed to be atomic units. If more// than one element is given, then the units must be specified as the final// element of the array. Acceptable units are HZ, NM, EV, and AU.

      * **Type**: string
      * **Possible Values**: POLARIZABILITY, ROTATION, ROA, ALL
      * **Default**: POLARIZABILITY

   REFERENCE (CCRESPONSE)
      :ref:`apdx:CCRESPONSE` |w---w| Reference wavefunction type

      * **Type**: string
      * **Default**: RHF

   RESTART (CCRESPONSE)
      :ref:`apdx:CCRESPONSE` |w---w| Do restart from on-disk amplitudes?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   R_CONVERGENCE (CCRESPONSE)
      :ref:`apdx:CCRESPONSE` |w---w| Convergence criterion for wavefunction (change) in perturbed CC equations.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-7

   SEKINO (CCRESPONSE)
      :ref:`apdx:CCRESPONSE` |w---w| Do Sekino-Bartlett size-extensive model-III?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   AO_BASIS (CCSORT)
      :ref:`apdx:CCSORT` |w---w| The algorithm to use for the :math:`\left<VV||VV\right>` terms

      * **Type**: string
      * **Possible Values**: NONE, DISK, DIRECT
      * **Default**: NONE

   CACHELEVEL (CCSORT)
      :ref:`apdx:CCSORT` |w---w| Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., :math:`\langle ij | ab \rangle>` integrals) may be held in the cache.

      * **Type**: integer
      * **Default**: 2

   EOM_REFERENCE (CCSORT)
      :ref:`apdx:CCSORT` |w---w| Reference wavefunction type for EOM computations

      * **Type**: string
      * **Default**: RHF

   INTS_TOLERANCE (CCSORT)
      :ref:`apdx:CCSORT` |w---w| Minimum absolute value below which integrals are neglected.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-14

   KEEP_OEIFILE (CCSORT)
      :ref:`apdx:CCSORT` |w---w| Do retain the input one-electron integrals?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   KEEP_TEIFILE (CCSORT)
      :ref:`apdx:CCSORT` |w---w| Do retain the input two-electron integrals?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   LOCAL (CCSORT)
      :ref:`apdx:CCSORT` |w---w| Do simulate the effects of local correlation techniques?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   LOCAL_CORE_CUTOFF (CCSORT)
      :ref:`apdx:CCSORT` |w---w| Local core cutoff value

      * **Type**: double
      * **Default**: 0.05

   LOCAL_CPHF_CUTOFF (CCSORT)
      :ref:`apdx:CCSORT` |w---w| Cutoff value for local-coupled-perturbed-Hartree-Fock

      * **Type**: double
      * **Default**: 0.10

   LOCAL_CUTOFF (CCSORT)
      :ref:`apdx:CCSORT` |w---w| Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996).

      * **Type**: double
      * **Default**: 0.02

   LOCAL_DOMAIN_MAG (CCSORT)
      :ref:`apdx:CCSORT` |w---w| Do generate magnetic-field CPHF solutions for local-CC?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   LOCAL_DOMAIN_POLAR (CCSORT)
      :ref:`apdx:CCSORT` |w---w| Do use augment domains with polarized orbitals?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   LOCAL_DOMAIN_SEP (CCSORT)
      :ref:`apdx:CCSORT` |w---w| 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   LOCAL_FILTER_SINGLES (CCSORT)
      :ref:`apdx:CCSORT` |w---w| Do apply local filtering to single excitation amplitudes?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   LOCAL_METHOD (CCSORT)
      :ref:`apdx:CCSORT` |w---w| Type of local-CCSD scheme to be simulated. ``WERNER`` (unique avaliable option) selects the method developed by H.-J. Werner and co-workers.

      * **Type**: string
      * **Default**: WERNER

   LOCAL_PAIRDEF (CCSORT)
      :ref:`apdx:CCSORT` |w---w| Definition of local pair domains, unique avaliable option is BP, Boughton-Pulay.

      * **Type**: string
      * **Default**: BP

   LOCAL_WEAKP (CCSORT)
      :ref:`apdx:CCSORT` |w---w| Desired treatment of "weak pairs" in the local-CCSD method. The value of ``NONE`` (unique avaliable option) treats weak pairs in the same manner as strong pairs.

      * **Type**: string
      * **Default**: NONE

   OMEGA (CCSORT)
      :ref:`apdx:CCSORT` |w---w| Energy of applied field [au] for dynamic properties

      * **Type**: array
      * **Default**: No Default

   PROPERTY (CCSORT)
      :ref:`apdx:CCSORT` |w---w| The response property desired. The unique acceptable values is ``POLARIZABILITY`` for dipole-polarizabilitie.

      * **Type**: string
      * **Default**: POLARIZABILITY

   REFERENCE (CCSORT)
      :ref:`apdx:CCSORT` |w---w| Reference wavefunction type

      * **Type**: string
      * **Default**: RHF

   SEMICANONICAL (CCSORT)
      :ref:`apdx:CCSORT` |w---w| Convert ROHF MOs to semicanonical MOs

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   CC_NUM_THREADS (CCTRIPLES)
      :ref:`apdx:CCTRIPLES` |w---w| Number of threads

      * **Type**: integer
      * **Default**: 1

   REFERENCE (CCTRIPLES)
      :ref:`apdx:CCTRIPLES` |w---w| Reference wavefunction type

      * **Type**: string
      * **Default**: RHF

   SEMICANONICAL (CCTRIPLES)
      :ref:`apdx:CCTRIPLES` |w---w| Convert ROHF MOs to semicanonical MOs

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   CACHELEVEL (CPHF)
      :ref:`apdx:CPHF` |w---w| The amount of cacheing of data to perform

      * **Type**: integer
      * **Default**: 2

   CACHETYPE (CPHF)
      :ref:`apdx:CPHF` |w---w| The criterion used to retain/release cached data

      * **Type**: string
      * **Possible Values**: LRU, LOW
      * **Default**: LRU

   CIS_AD_STATES (CPHF)
      :ref:`apdx:CPHF` |w---w| Which states to save AD Matrices for? * Positive - Singlets * Negative - Triplets *

      * **Type**: array
      * **Default**: No Default

   CIS_AMPLITUDE_CUTOFF (CPHF)
      :ref:`apdx:CPHF` |w---w| Minimum singles amplitude to print in CIS analysis

      * **Type**: double
      * **Default**: 0.15

   CIS_DOPDM_STATES (CPHF)
      :ref:`apdx:CPHF` |w---w| Which states to save AO difference OPDMs for? * Positive - Singlets * Negative - Triplets *

      * **Type**: array
      * **Default**: No Default

   CIS_MEM_SAFETY_FACTOR (CPHF)
      :ref:`apdx:CPHF` |w---w| Memory safety factor for allocating JK

      * **Type**: double
      * **Default**: 0.75

   CIS_NO_STATES (CPHF)
      :ref:`apdx:CPHF` |w---w| Which states to save AO Natural Orbitals for? * Positive - Singlets * Negative - Triplets *

      * **Type**: array
      * **Default**: No Default

   CIS_OPDM_STATES (CPHF)
      :ref:`apdx:CPHF` |w---w| Which states to save AO OPDMs for? * Positive - Singlets * Negative - Triplets *

      * **Type**: array
      * **Default**: No Default

   CIS_TOPDM_STATES (CPHF)
      :ref:`apdx:CPHF` |w---w| Which states to save AO transition OPDMs for? * Positive - Singlets * Negative - Triplets *

      * **Type**: array
      * **Default**: No Default

   CPHF_MEM_SAFETY_FACTOR (CPHF)
      :ref:`apdx:CPHF` |w---w| Memory safety factor for allocating JK

      * **Type**: double
      * **Default**: 0.75

   CPHF_TASKS (CPHF)
      :ref:`apdx:CPHF` |w---w| Which tasks to run CPHF For * Valid choices: * -Polarizability *

      * **Type**: array
      * **Default**: No Default

   DEBUG (CPHF)
      :ref:`apdx:CPHF` |w---w| The amount of debug information printed to the output file

      * **Type**: integer
      * **Default**: 0

   DF_BASIS_SCF (CPHF)
      :ref:`apdx:CPHF` |w---w| Auxiliary basis for SCF

      * **Type**: string
      * **Possible Values**: :ref:`basis string <apdx:basisElement>`
      * **Default**: No Default

   DO_SINGLETS (CPHF)
      :ref:`apdx:CPHF` |w---w| Do singlet states? Default true

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   DO_TRIPLETS (CPHF)
      :ref:`apdx:CPHF` |w---w| Do triplet states? Default true

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   EXPLICIT_HAMILTONIAN (CPHF)
      :ref:`apdx:CPHF` |w---w| Do explicit hamiltonian only?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   FITTING_ALGORITHM (CPHF)
      :ref:`apdx:CPHF` |w---w| Fitting algorithm (0 for old, 1 for new)

      * **Type**: integer
      * **Default**: 0

   FITTING_CONDITION (CPHF)
      :ref:`apdx:CPHF` |w---w| The maximum reciprocal condition allowed in the fitting metric

      * **Type**: double
      * **Default**: 1.0e-12

   MODULE (CPHF)
      :ref:`apdx:CPHF` |w---w| What app to test?

      * **Type**: string
      * **Possible Values**: RCIS, RCPHF, RTDHF, RCPKS, RTDA, RTDDFT
      * **Default**: RCIS

   MP2_OS_SCALE (CPHF)
      :ref:`apdx:CPHF` |w---w| The scale factor used for opposite-spin pairs in SCS computations

      * **Type**: double
      * **Default**: 6.0/5.0

   MP2_SS_SCALE (CPHF)
      :ref:`apdx:CPHF` |w---w| The scale factor used for same-spin pairs in SCS computations

      * **Type**: double
      * **Default**: 1.0/3.0

   MP2_TYPE (CPHF)
      :ref:`apdx:CPHF` |w---w| What algorithm to use for the MP2 computation

      * **Type**: string
      * **Possible Values**: DF, CONV
      * **Default**: DF

   OMP_N_THREAD (CPHF)
      :ref:`apdx:CPHF` |w---w| The maximum number of integral threads (0 for omp_get_max_threads())

      * **Type**: integer
      * **Default**: 0

   OPDM (CPHF)
      :ref:`apdx:CPHF` |w---w| Do compute the one particle density matrix, for properties?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   OPDM_RELAX (CPHF)
      :ref:`apdx:CPHF` |w---w| Do add relaxation terms to the one particle density matrix, for properties?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   PRINT (CPHF)
      :ref:`apdx:CPHF` |w---w| The amount of information printed to the output file

      * **Type**: integer
      * **Default**: 1

   REFERENCE (CPHF)
      :ref:`apdx:CPHF` |w---w| Reference wavefunction type

      * **Type**: string
      * **Possible Values**: RHF, UHF, ROHF
      * **Default**: RHF

   SCF_TYPE (CPHF)
      :ref:`apdx:CPHF` |w---w| SCF Type

      * **Type**: string
      * **Possible Values**: DIRECT, DF, PK, OUT\_OF\_CORE, PS
      * **Default**: DIRECT

   SCHWARZ_CUTOFF (CPHF)
      :ref:`apdx:CPHF` |w---w| The schwarz cutoff value

      * **Type**: double
      * **Default**: 1.0e-12

   SCS (CPHF)
      :ref:`apdx:CPHF` |w---w| Do perform a spin component scaled MP2 computation?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   SCS_N (CPHF)
      :ref:`apdx:CPHF` |w---w| Do perform a spin component scaled (N) MP2 computation?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   SOLVER_CONVERGENCE (CPHF)
      :ref:`apdx:CPHF` |w---w| Solver convergence threshold (max 2-norm).

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1.0e-6

   SOLVER_EXACT_DIAGONAL (CPHF)
      :ref:`apdx:CPHF` |w---w| Solver exact diagonal or eigenvalue difference?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   SOLVER_MAXITER (CPHF)
      :ref:`apdx:CPHF` |w---w| Solver maximum iterations

      * **Type**: integer
      * **Default**: 100

   SOLVER_MAX_SUBSPACE (CPHF)
      :ref:`apdx:CPHF` |w---w| DL Solver maximum number of subspace vectors

      * **Type**: integer
      * **Default**: 6

   SOLVER_MIN_SUBSPACE (CPHF)
      :ref:`apdx:CPHF` |w---w| DL Solver number of subspace vectors to collapse to

      * **Type**: integer
      * **Default**: 2

   SOLVER_NORM (CPHF)
      :ref:`apdx:CPHF` |w---w| DL Solver minimum corrector norm to add to subspace

      * **Type**: double
      * **Default**: 1.0e-6

   SOLVER_N_GUESS (CPHF)
      :ref:`apdx:CPHF` |w---w| DL Solver number of guesses

      * **Type**: integer
      * **Default**: 1

   SOLVER_N_ROOT (CPHF)
      :ref:`apdx:CPHF` |w---w| DL Solver number of roots

      * **Type**: integer
      * **Default**: 1

   SOLVER_PRECONDITION (CPHF)
      :ref:`apdx:CPHF` |w---w| Solver precondition type

      * **Type**: string
      * **Possible Values**: SUBSPACE, JACOBI, NONE
      * **Default**: JACOBI

   SOLVER_PRECONDITION_MAXITER (CPHF)
      :ref:`apdx:CPHF` |w---w| Solver precondtion max steps

      * **Type**: integer
      * **Default**: 1

   SOLVER_PRECONDITION_STEPS (CPHF)
      :ref:`apdx:CPHF` |w---w| Solver precondition step type

      * **Type**: string
      * **Possible Values**: CONSTANT, TRIANGULAR
      * **Default**: TRIANGULAR

   SOLVER_QUANTITY (CPHF)
      :ref:`apdx:CPHF` |w---w| Solver residue or eigenvector delta

      * **Type**: string
      * **Possible Values**: EIGENVECTOR, RESIDUAL
      * **Default**: RESIDUAL

   SOLVER_TYPE (CPHF)
      :ref:`apdx:CPHF` |w---w| Solver type (for interchangeable solvers)

      * **Type**: string
      * **Possible Values**: DL, RAYLEIGH
      * **Default**: DL

   TDHF_MEM_SAFETY_FACTOR (CPHF)
      :ref:`apdx:CPHF` |w---w| Memory safety factor for allocating JK

      * **Type**: double
      * **Default**: 0.75

   ALGORITHM (DCFT)
      :ref:`apdx:DCFT` |w---w| The algorithm to use for the density cumulant and orbital updates in the DCFT energy computation. Two-step algorithm (default) is usually more efficient for small systems, but for large systems the simultaneous algorithm is recommended. In the cases where the convergence problems are encountered (especially for highly symmetric systems) QC algorithm can be used.

      * **Type**: string
      * **Possible Values**: TWOSTEP, SIMULTANEOUS, QC
      * **Default**: TWOSTEP

   AO_BASIS (DCFT)
      :ref:`apdx:DCFT` |w---w| Controls whether to avoid the AO->MO transformation of the two-electron integrals for the four-virtual case (<VV||VV>) by computing the corresponding terms in the AO basis. AO_BASIS = DISK algorithm reduces the memory requirements and can significantly reduce the cost of the energy computation if SIMULTANEOUS algorithm is used. For the TWOSTEP algorithm, however, AO_BASIS = DISK option is not recommended due to the extra I/O.

      * **Type**: string
      * **Possible Values**: NONE, DISK
      * **Default**: NONE

   DCFT_FUNCTIONAL (DCFT)
      :ref:`apdx:DCFT` |w---w| Chooses appropriate DCFT method

      * **Type**: string
      * **Possible Values**: DC-06, DC-12, CEPA0
      * **Default**: DC-06

   DIIS_START_CONVERGENCE (DCFT)
      :ref:`apdx:DCFT` |w---w| Value of RMS of the density cumulant residual and SCF error vector below which DIIS extrapolation starts. Same keyword controls the DIIS extrapolation for the solution of the response equations.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-3

   LAMBDA_MAXITER (DCFT)
      :ref:`apdx:DCFT` |w---w| Maximum number of density cumulant update micro-iterations per macro-iteration (for ALOGRITHM = TWOSTEP). Same keyword controls the maximum number of density cumulant response micro-iterations per macro-iteration for the solution of the response equations (for RESPONSE_ALOGRITHM = TWOSTEP)

      * **Type**: integer
      * **Default**: 50

   MAXITER (DCFT)
      :ref:`apdx:DCFT` |w---w| Maximum number of the macro-iterations for both the energy and the solution of the response equations

      * **Type**: integer
      * **Default**: 40

   QC_COUPLING (DCFT)
      :ref:`apdx:DCFT` |w---w| Controls whether to include the coupling terms in the DCFT electronic Hessian (for ALOGRITHM = QC only)

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   REFERENCE (DCFT)
      :ref:`apdx:DCFT` |w---w| Reference wavefunction type

      * **Type**: string
      * **Possible Values**: UHF
      * **Default**: UHF

   RESPONSE_ALGORITHM (DCFT)
      :ref:`apdx:DCFT` |w---w| The algorithm to use for the solution of the response equations for the analytic gradients and properties.

      * **Type**: string
      * **Possible Values**: TWOSTEP, SIMULTANEOUS
      * **Default**: TWOSTEP

   R_CONVERGENCE (DCFT)
      :ref:`apdx:DCFT` |w---w| Convergence criterion for the RMS of the residual vector in the density cumulant updates, as well as the solution of the density cumulant and orbital response equations. In the orbital updates controls the RMS of the SCF error vector

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-10

   SCF_MAXITER (DCFT)
      :ref:`apdx:DCFT` |w---w| Maximum number of the orbital update micro-iterations per macro-iteration (for ALOGRITHM = TWOSTEP). Same keyword controls the maximum number of orbital response micro-iterations per macro-iteration for the solution of the response equations (for RESPONSE_ALOGRITHM = TWOSTEP)

      * **Type**: integer
      * **Default**: 50

   AVG_STATES (DETCI)
      :ref:`apdx:DETCI` |w---w| Array giving the root numbers of the states to average in a state-averaged procedure such as SA-CASSCF. Root numbering starts from 1.

      * **Type**: array
      * **Default**: No Default

   AVG_WEIGHTS (DETCI)
      :ref:`apdx:DETCI` |w---w| Array giving the weights for each state in a state-averaged procedure

      * **Type**: array
      * **Default**: No Default

   CIBLKS_PRINT (DETCI)
      :ref:`apdx:DETCI` |w---w| Do print a summary of the CI blocks?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   CI_NUM_THREADS (DETCI)
      :ref:`apdx:DETCI` |w---w| Number of threads for DETCI.

      * **Type**: integer
      * **Default**: 1

   DETCI_FREEZE_CORE (DETCI)
      :ref:`apdx:DETCI` |w---w| Do freeze core orbitals?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   EX_LEVEL (DETCI)
      :ref:`apdx:DETCI` |w---w| The CI excitation level

      * **Type**: integer
      * **Default**: 2

   E_CONVERGENCE (DETCI)
      :ref:`apdx:DETCI` |w---w| Convergence criterion for energy. See Table :ref:`Post-SCF Convergence <table:conv_corl>` for default convergence criteria for different calculation types.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-6

   FCI (DETCI)
      :ref:`apdx:DETCI` |w---w| Do a full CI (FCI)? If TRUE, overrides the value of |detci__ex_level|.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   ICORE (DETCI)
      :ref:`apdx:DETCI` |w---w| Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if |detci__diag_method| = SEM), but require less core memory.

      * **Type**: integer
      * **Default**: 1

   ISTOP (DETCI)
      :ref:`apdx:DETCI` |w---w| Do stop DETCI after string information is formed and before integrals are read?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   MAXITER (DETCI)
      :ref:`apdx:DETCI` |w---w| Maximum number of iterations to diagonalize the Hamiltonian

      * **Type**: integer
      * **Default**: 12

   NUM_DETS_PRINT (DETCI)
      :ref:`apdx:DETCI` |w---w| Number of important determinants to print

      * **Type**: integer
      * **Default**: 20

   NUM_ROOTS (DETCI)
      :ref:`apdx:DETCI` |w---w| number of CI roots to find

      * **Type**: integer
      * **Default**: 1

   REFERENCE (DETCI)
      :ref:`apdx:DETCI` |w---w| Reference wavefunction type

      * **Type**: string
      * **Possible Values**: RHF, ROHF
      * **Default**: RHF

   R_CONVERGENCE (DETCI)
      :ref:`apdx:DETCI` |w---w| Convergence criterion for CI residual vector in the Davidson algorithm (RMS error). The default is 1e-4 for energies and 1e-7 for gradients.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-4

   S_SQUARED (DETCI)
      :ref:`apdx:DETCI` |w---w| Do calculate the value of :math:`\langle S^2\rangle` for each root? Only supported for |detci__icore| = 1.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   VAL_EX_LEVEL (DETCI)
      :ref:`apdx:DETCI` |w---w| In a RAS CI, this is the additional excitation level for allowing electrons out of RAS I into RAS II. The maximum number of holes in RAS I is therefore |detci__ex_level| + VAL_EX_LEVEL.

      * **Type**: integer
      * **Default**: 0

   ACTIVE (DETCI)
      :ref:`apdx:DETCI` |w---w| An array giving the number of active orbitals (occupied plus unoccupied) per irrep (shorthand to make MCSCF easier to specify than using RAS keywords)

      * **Type**: array
      * **Default**: No Default

   A_RAS3_MAX (DETCI)
      :ref:`apdx:DETCI` |w---w| maximum number of alpha electrons in RAS III

      * **Type**: integer
      * **Default**: -1

   B_RAS3_MAX (DETCI)
      :ref:`apdx:DETCI` |w---w| maximum number of beta electrons in RAS III

      * **Type**: integer
      * **Default**: -1

   MS0 (DETCI)
      :ref:`apdx:DETCI` |w---w| Do use the :math:`M_s = 0` component of the state? Defaults to TRUE if closed-shell and FALSE otherwise. Related to the |detci__s| option.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   RAS34_MAX (DETCI)
      :ref:`apdx:DETCI` |w---w| maximum number of electrons in RAS III + IV

      * **Type**: integer
      * **Default**: -1

   RAS3_MAX (DETCI)
      :ref:`apdx:DETCI` |w---w| maximum number of electrons in RAS III

      * **Type**: integer
      * **Default**: -1

   RAS4_MAX (DETCI)
      :ref:`apdx:DETCI` |w---w| maximum number of electrons in RAS IV

      * **Type**: integer
      * **Default**: -1

   RESTRICTED_DOCC (DETCI)
      :ref:`apdx:DETCI` |w---w| An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF)

      * **Type**: array
      * **Default**: No Default

   RESTRICTED_UOCC (DETCI)
      :ref:`apdx:DETCI` |w---w| An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF)

      * **Type**: array
      * **Default**: No Default

   S (DETCI)
      :ref:`apdx:DETCI` |w---w| The value of the spin quantum number :math:`S` is given by this option. The default is determined by the value of the multiplicity. This is used for two things: (1) determining the phase of the redundant half of the CI vector when the :math:`M_s = 0` component is used (i.e., |detci__ms0| = ``TRUE``), and (2) making sure the guess vector has the desired value of :math:`\langle S^2\rangle` (if |detci__s_squared| is ``TRUE`` and |detci__icore| = ``1``).

      * **Type**: double
      * **Default**: 0.0

   DIAG_METHOD (DETCI)
      :ref:`apdx:DETCI` |w---w| This specifies which method is to be used in diagonalizing the Hamiltonian. The valid options are: ``RSP``, to form the entire H matrix and diagonalize using libciomr to obtain all eigenvalues (n.b. requires HUGE memory); ``OLSEN``, to use Olsen's preconditioned inverse subspace method (1990); ``MITRUSHENKOV``, to use a 2x2 Olsen/Davidson method; and ``DAVIDSON`` (or ``SEM``) to use Liu's Simultaneous Expansion Method, which is identical to the Davidson method if only one root is to be found. There also exists a SEM debugging mode, ``SEMTEST``. The ``SEM`` method is the most robust, but it also requires :math:`2NM+1` CI vectors on disk, where :math:`N` is the maximum number of iterations and :math:`M` is the number of roots.

      * **Type**: string
      * **Possible Values**: RSP, OLSEN, MITRUSHENKOV, DAVIDSON, SEM, SEMTEST
      * **Default**: SEM

   LSE (DETCI)
      :ref:`apdx:DETCI` |w---w| Do use least-squares extrapolation in iterative solution of CI vector?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   LSE_COLLAPSE (DETCI)
      :ref:`apdx:DETCI` |w---w| Number of iterations between least-squares extrapolations

      * **Type**: integer
      * **Default**: 3

   LSE_TOLERANCE (DETCI)
      :ref:`apdx:DETCI` |w---w| Minimum converged energy for least-squares extrapolation to be performed

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 3

   PRECONDITIONER (DETCI)
      :ref:`apdx:DETCI` |w---w| This specifies the type of preconditioner to use in the selected diagonalization method. The valid options are: ``DAVIDSON`` which approximates the Hamiltonian matrix by the diagonal elements; ``H0BLOCK_INV`` which uses an exact Hamiltonian of |detci__h0_blocksize| and explicitly inverts it; ``GEN_DAVIDSON`` which does a spectral decomposition of H0BLOCK; ``ITER_INV`` using an iterative approach to obtain the correction vector of H0BLOCK. The ``H0BLOCK_INV``, ``GEN_DAVIDSON``, and ``ITER_INV`` approaches are all formally equivalent but the ``ITER_INV`` is less computationally expensive. Default is ``DAVIDSON``.

      * **Type**: string
      * **Possible Values**: LANCZOS, DAVIDSON, GEN\_DAVIDSON, H0BLOCK, H0BLOCK\_INV, ITER\_INV, H0BLOCK\_COUPLING, EVANGELISTI
      * **Default**: DAVIDSON

   UPDATE (DETCI)
      :ref:`apdx:DETCI` |w---w| The update or correction vector formula, either ``DAVIDSON`` (default) or ``OLSEN``.

      * **Type**: string
      * **Possible Values**: DAVIDSON, OLSEN
      * **Default**: DAVIDSON

   DIPMOM (DETCI)
      :ref:`apdx:DETCI` |w---w| Do compute the dipole moment?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   NAT_ORBS_WRITE (DETCI)
      :ref:`apdx:DETCI` |w---w| Do write the natural orbitals?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   NAT_ORBS_WRITE_ROOT (DETCI)
      :ref:`apdx:DETCI` |w---w| Sets the root number for which CI natural orbitals are written to PSIF_CHKPT. The default value is 1 (lowest root).

      * **Type**: integer
      * **Default**: 1

   OPDM (DETCI)
      :ref:`apdx:DETCI` |w---w| Do compute one-particle density matrix if not otherwise required?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   OPDM_AVG (DETCI)
      :ref:`apdx:DETCI` |w---w| Do average the OPDM over several roots in order to obtain a state-average one-particle density matrix? This density matrix can be diagonalized to obtain the CI natural orbitals.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   OPDM_PRINT (DETCI)
      :ref:`apdx:DETCI` |w---w| Do print the one-particle density matrix for each root?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   TDM (DETCI)
      :ref:`apdx:DETCI` |w---w| Do compute the transition density? Note: only transition densities between roots of the same symmetry will be evaluated. DETCI does not compute states of different irreps within the same computation; to do this, lower the symmetry of the computation.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   TDM_PRINT (DETCI)
      :ref:`apdx:DETCI` |w---w| Do print the transition density?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   TDM_WRITE (DETCI)
      :ref:`apdx:DETCI` |w---w| Do write the transition density?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   TPDM (DETCI)
      :ref:`apdx:DETCI` |w---w| Do compute two-particle density matrix if not otherwise required?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   TPDM_PRINT (DETCI)
      :ref:`apdx:DETCI` |w---w| Do print the two-particle density matrix? (Warning: large tensor)

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   FOLLOW_ROOT (DETCI)
      :ref:`apdx:DETCI` |w---w| The root to write out the two-particle density matrix for (the one-particle density matrices are written for all roots). Useful for a state-specific CASSCF or CI optimization on an excited state.

      * **Type**: integer
      * **Default**: 1

   RESTART (DETCI)
      :ref:`apdx:DETCI` |w---w| Do restart a DETCI iteration that terminated prematurely? It assumes that the CI and sigma vectors are on disk; the number of vectors specified by RESTART_VECS (obsolete) is collapsed down to one vector per root.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   COLLAPSE_SIZE (DETCI)
      :ref:`apdx:DETCI` |w---w| Gives the number of vectors to retain when the Davidson subspace is collapsed (see |detci__max_num_vecs|). If greater than one, the collapsed subspace retains the best estimate of the CI vector for the previous n iterations. Defaults to 1.

      * **Type**: integer
      * **Default**: 1

   MAX_NUM_VECS (DETCI)
      :ref:`apdx:DETCI` |w---w| Maximum number of Davidson subspace vectors which can be held on disk for the CI coefficient and sigma vectors. (There is one H(diag) vector and the number of D vectors is equal to the number of roots). When the number of vectors on disk reaches the value of MAX_NUM_VECS, the Davidson subspace will be collapsed to |detci__collapse_size| vectors for each root. This is very helpful for saving disk space. Defaults to |detci__maxiter| * |detci__num_roots| + |detci__num_init_vecs|.

      * **Type**: integer
      * **Default**: 0

   NUM_VECS_WRITE (DETCI)
      :ref:`apdx:DETCI` |w---w| Number of vectors to export

      * **Type**: integer
      * **Default**: 1

   VECS_WRITE (DETCI)
      :ref:`apdx:DETCI` |w---w| Do store converged vector(s) at the end of the run? The vector(s) is(are) stored in a transparent format such that other programs can use it easily. The format is specified in :source:`src/lib/libqt/slaterdset.h` .

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   MPN (DETCI)
      :ref:`apdx:DETCI` |w---w| Do compute the MPn series out to kth order where k is determined by |detci__max_num_vecs| ? For open-shell systems (|detci__reference| is ROHF, |detci__wfn| is ZAPTN), DETCI will compute the ZAPTn series. |detci__guess_vector| must be set to UNIT, |detci__hd_otf| must be set to TRUE, and |detci__hd_avg| must be set to orb_ener; these should happen by default for MPN = TRUE.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   CC (DETCI)
      :ref:`apdx:DETCI` |w---w| Do coupled-cluster computation?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   CC_A_RAS3_MAX (DETCI)
      :ref:`apdx:DETCI` |w---w| maximum number of alpha electrons in RAS III, for CC

      * **Type**: integer
      * **Default**: -1

   CC_B_RAS3_MAX (DETCI)
      :ref:`apdx:DETCI` |w---w| maximum number of beta electrons in RAS III, for CC

      * **Type**: integer
      * **Default**: -1

   CC_EX_LEVEL (DETCI)
      :ref:`apdx:DETCI` |w---w| The CC excitation level

      * **Type**: integer
      * **Default**: 2

   CC_RAS34_MAX (DETCI)
      :ref:`apdx:DETCI` |w---w| maximum number of electrons in RAS III + IV, for CC

      * **Type**: integer
      * **Default**: -1

   CC_RAS3_MAX (DETCI)
      :ref:`apdx:DETCI` |w---w| maximum number of electrons in RAS III, for CC

      * **Type**: integer
      * **Default**: -1

   CC_RAS4_MAX (DETCI)
      :ref:`apdx:DETCI` |w---w| maximum number of electrons in RAS IV, for CC

      * **Type**: integer
      * **Default**: -1

   CC_VAL_EX_LEVEL (DETCI)
      :ref:`apdx:DETCI` |w---w| The CC valence excitation level

      * **Type**: integer
      * **Default**: 0

   CC_VECS_READ (DETCI)
      :ref:`apdx:DETCI` |w---w| Do import a CC vector from disk?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   CC_VECS_WRITE (DETCI)
      :ref:`apdx:DETCI` |w---w| Do export a CC vector to disk?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   DIIS (DETCI)
      :ref:`apdx:DETCI` |w---w| Do use DIIS extrapolation to accelerate CC convergence?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   DIIS_FREQ (DETCI)
      :ref:`apdx:DETCI` |w---w| How often to do a DIIS extrapolation. 1 means do DIIS every iteration, 2 is every other iteration, etc.

      * **Type**: integer
      * **Default**: 1

   DIIS_MAX_VECS (DETCI)
      :ref:`apdx:DETCI` |w---w| Maximum number of error vectors stored for DIIS extrapolation

      * **Type**: integer
      * **Default**: 5

   DIIS_MIN_VECS (DETCI)
      :ref:`apdx:DETCI` |w---w| Minimum number of error vectors stored for DIIS extrapolation

      * **Type**: integer
      * **Default**: 2

   DIIS_START_ITER (DETCI)
      :ref:`apdx:DETCI` |w---w| Iteration at which to start using DIIS

      * **Type**: integer
      * **Default**: 1

   NUM_AMPS_PRINT (DETCI)
      :ref:`apdx:DETCI` |w---w| Number of important CC amplitudes per excitation level to print. CC analog to |detci__num_dets_print|.

      * **Type**: integer
      * **Default**: 10

   BASIS (DFMP2)
      :ref:`apdx:DFMP2` |w---w| Primary basis set

      * **Type**: string
      * **Possible Values**: :ref:`basis string <apdx:basisElement>`
      * **Default**: NONE

   DFMP2_MEM_FACTOR (DFMP2)
      :ref:`apdx:DFMP2` |w---w| \% of memory for DF-MP2 three-index buffers

      * **Type**: double
      * **Default**: 0.9

   DFMP2_P2_TOLERANCE (DFMP2)
      :ref:`apdx:DFMP2` |w---w| Minimum error in the 2-norm of the P(2) matrix for corrections to Lia and P.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 0.0

   DFMP2_P_TOLERANCE (DFMP2)
      :ref:`apdx:DFMP2` |w---w| Minimum error in the 2-norm of the P matrix for skeleton-core Fock matrix derivatives.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 0.0

   DF_BASIS_MP2 (DFMP2)
      :ref:`apdx:DFMP2` |w---w| Auxiliary basis set for MP2 density fitting computations. :ref:`Defaults <apdx:basisFamily>` to a RI basis.

      * **Type**: string
      * **Possible Values**: :ref:`basis string <apdx:basisElement>`
      * **Default**: No Default

   DF_INTS_NUM_THREADS (DFMP2)
      :ref:`apdx:DFMP2` |w---w| Number of threads to compute integrals with. 0 is wild card

      * **Type**: integer
      * **Default**: 0

   INTS_TOLERANCE (DFMP2)
      :ref:`apdx:DFMP2` |w---w| Minimum absolute value below which integrals are neglected.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 0.0

   MP2_OS_SCALE (DFMP2)
      :ref:`apdx:DFMP2` |w---w| OS Scale

      * **Type**: double
      * **Default**: 6.0/5.0

   MP2_SS_SCALE (DFMP2)
      :ref:`apdx:DFMP2` |w---w| SS Scale

      * **Type**: double
      * **Default**: 1.0/3.0

   MP2_TYPE (DFMP2)
      :ref:`apdx:DFMP2` |w---w| Algorithm to use for the MP2 computation

      * **Type**: string
      * **Possible Values**: DF, CONV
      * **Default**: DF

   ONEPDM (DFMP2)
      :ref:`apdx:DFMP2` |w---w| Do compute one-particle density matrix?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   OPDM_RELAX (DFMP2)
      :ref:`apdx:DFMP2` |w---w| Do relax the one-particle density matrix?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   DISP_SIZE (FINDIF)
      :ref:`apdx:FINDIF` |w---w| Displacement size in au for finite-differences.

      * **Type**: double
      * **Default**: 0.005

   GRADIENT_WRITE (FINDIF)
      :ref:`apdx:FINDIF` |w---w| Do write a gradient output file? If so, the filename will end in .grad, and the prefix is determined by |globals__writer_file_label| (if set), or else by the name of the output file plus the name of the current molecule.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   HESSIAN_WRITE (FINDIF)
      :ref:`apdx:FINDIF` |w---w| Do write a hessian output file? If so, the filename will end in .hess, and the prefix is determined by |globals__writer_file_label| (if set), or else by the name of the output file plus the name of the current molecule.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   POINTS (FINDIF)
      :ref:`apdx:FINDIF` |w---w| Number of points for finite-differences (3 or 5)

      * **Type**: integer
      * **Default**: 3

   BRUECKNER_MAXITER (FNOCC)
      :ref:`apdx:FNOCC` |w---w| Maximum number of iterations for Brueckner orbitals optimization

      * **Type**: integer
      * **Default**: 20

   CC_SCALE_OS (FNOCC)
      :ref:`apdx:FNOCC` |w---w| Oppposite-spin scaling factor for SCS-CCSD

      * **Type**: double
      * **Default**: 1.27

   CC_SCALE_SS (FNOCC)
      :ref:`apdx:FNOCC` |w---w| Same-spin scaling factor for SCS-CCSD

      * **Type**: double
      * **Default**: 1.13

   CC_TIMINGS (FNOCC)
      :ref:`apdx:FNOCC` |w---w| Do time each cc diagram?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   CEPA_NO_SINGLES (FNOCC)
      :ref:`apdx:FNOCC` |w---w| Flag to exclude singly excited configurations from a coupled-pair computation.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   CHOLESKY_TOLERANCE (FNOCC)
      :ref:`apdx:FNOCC` |w---w| tolerance for Cholesky decomposition of the ERI tensor

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1.0e-4

   DFCC (FNOCC)
      :ref:`apdx:FNOCC` |w---w| Do use density fitting or cholesky decomposition in CC? This keyword is used internally by the driver. Changing its value will have no effect on the computation.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   DF_BASIS_CC (FNOCC)
      :ref:`apdx:FNOCC` |w---w| Auxilliary basis for df-ccsd(t).

      * **Type**: string
      * **Possible Values**: :ref:`basis string <apdx:basisElement>`
      * **Default**: No Default

   DIIS_MAX_VECS (FNOCC)
      :ref:`apdx:FNOCC` |w---w| Desired number of DIIS vectors

      * **Type**: integer
      * **Default**: 8

   DIPMOM (FNOCC)
      :ref:`apdx:FNOCC` |w---w| Compute the dipole moment? Note that dipole moments are only available in the FNOCC module for the ACPF, AQCC, CISD, and CEPA(0) methods.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   E_CONVERGENCE (FNOCC)
      :ref:`apdx:FNOCC` |w---w| Convergence criterion for CC energy. See Table :ref:`Post-SCF Convergence <table:conv_corl>` for default convergence criteria for different calculation types. Note that convergence is	 met only when |fnocc__e_convergence| and |fnocc__r_convergence|	 are satisfied.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1.0e-6

   MAXITER (FNOCC)
      :ref:`apdx:FNOCC` |w---w| Maximum number of CC iterations

      * **Type**: integer
      * **Default**: 100

   MP2_SCALE_OS (FNOCC)
      :ref:`apdx:FNOCC` |w---w| Opposite-spin scaling factor for SCS-MP2

      * **Type**: double
      * **Default**: 1.20

   MP2_SCALE_SS (FNOCC)
      :ref:`apdx:FNOCC` |w---w| Same-spin scaling factor for SCS-MP2

      * **Type**: double
      * **Default**: 1.0/3.0

   NAT_ORBS (FNOCC)
      :ref:`apdx:FNOCC` |w---w| Do use MP2 NOs to truncate virtual space for QCISD/CCSD and (T)?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   OCC_TOLERANCE (FNOCC)
      :ref:`apdx:FNOCC` |w---w| Cutoff for occupation of MP2 NO orbitals in FNO-QCISD/CCSD(T) ( only valid if |fnocc__nat_orbs| = true )

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1.0e-6

   R_CONVERGENCE (FNOCC)
      :ref:`apdx:FNOCC` |w---w| Convergence for the CC amplitudes. Note that convergence is	 met only when |fnocc__e_convergence| and |fnocc__r_convergence|	 are satisfied.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1.0e-7

   SCS_CCSD (FNOCC)
      :ref:`apdx:FNOCC` |w---w| Do SCS-CCSD?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   SCS_CEPA (FNOCC)
      :ref:`apdx:FNOCC` |w---w| Do SCS-CEPA? Note that the scaling factors will be identical to those for SCS-CCSD.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   SCS_MP2 (FNOCC)
      :ref:`apdx:FNOCC` |w---w| Do SCS-MP2?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   TRIPLES_LOW_MEMORY (FNOCC)
      :ref:`apdx:FNOCC` |w---w| Do use low memory option for triples contribution? Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   CANONICALIZE_ACTIVE_FAVG (MCSCF)
      :ref:`apdx:MCSCF` |w---w| Do canonicalize the active orbitals such that the average Fock matrix is diagonal?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   CANONICALIZE_INACTIVE_FAVG (MCSCF)
      :ref:`apdx:MCSCF` |w---w| Do canonicalize the inactive (DOCC and Virtual) orbitals such that the average Fock matrix is diagonal?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   CI_DIIS (MCSCF)
      :ref:`apdx:MCSCF` |w---w| Do use DIIS extrapolation to accelerate convergence of the CI coefficients?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   DIIS (MCSCF)
      :ref:`apdx:MCSCF` |w---w| Do use DIIS extrapolation to accelerate convergence of the SCF energy (MO coefficients only)?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   DIIS_MAX_VECS (MCSCF)
      :ref:`apdx:MCSCF` |w---w| Maximum number of error vectors stored for DIIS extrapolation

      * **Type**: integer
      * **Default**: 7

   DOCC (MCSCF)
      :ref:`apdx:MCSCF` |w---w| The number of doubly occupied orbitals, per irrep

      * **Type**: array
      * **Default**: No Default

   D_CONVERGENCE (MCSCF)
      :ref:`apdx:MCSCF` |w---w| Convergence criterion for density.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-6

   E_CONVERGENCE (MCSCF)
      :ref:`apdx:MCSCF` |w---w| Convergence criterion for energy.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-6

   FAVG (MCSCF)
      :ref:`apdx:MCSCF` |w---w| Do use the average Fock matrix during the SCF optimization?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   FAVG_START (MCSCF)
      :ref:`apdx:MCSCF` |w---w| Iteration at which to begin using the averaged Fock matrix

      * **Type**: integer
      * **Default**: 5

   FOLLOW_ROOT (MCSCF)
      :ref:`apdx:MCSCF` |w---w| Which solution of the SCF equations to find, where 1 is the SCF ground state

      * **Type**: integer
      * **Default**: 1

   FORCE_TWOCON (MCSCF)
      :ref:`apdx:MCSCF` |w---w| Do attempt to force a two configruation solution by starting with CI coefficents of :math:`\pm \sqrt{\frac{1}{2}}` ?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   INTERNAL_ROTATIONS (MCSCF)
      :ref:`apdx:MCSCF` |w---w| Do consider internal rotations?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   LEVEL_SHIFT (MCSCF)
      :ref:`apdx:MCSCF` |w---w| Level shift to aid convergence

      * **Type**: double
      * **Default**: 0.0

   MAXITER (MCSCF)
      :ref:`apdx:MCSCF` |w---w| Maximum number of iterations

      * **Type**: integer
      * **Default**: 100

   MO_READ (MCSCF)
      :ref:`apdx:MCSCF` |w---w| Do read in from file the MOs from a previous computation?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   REFERENCE (MCSCF)
      :ref:`apdx:MCSCF` |w---w| Reference wavefunction type

      * **Type**: string
      * **Possible Values**: RHF, ROHF, UHF, TWOCON, MCSCF, GENERAL
      * **Default**: RHF

   SOCC (MCSCF)
      :ref:`apdx:MCSCF` |w---w| The number of singly occupied orbitals, per irrep

      * **Type**: array
      * **Default**: No Default

   TURN_ON_ACTV (MCSCF)
      :ref:`apdx:MCSCF` |w---w| 

      * **Type**: integer
      * **Default**: 0

   WFN_SYM (MCSCF)
      :ref:`apdx:MCSCF` |w---w| The symmetry of the SCF wavefunction.

      * **Type**: string
      * **Possible Values**: A, AG, AU, AP, APP, A1, A2, B, BG, BU, B1, B2, B3, B1G, B2G, B3G, B1U, B2U, B3U, 0, 1, 2, 3, 4, 5, 6, 7, 8
      * **Default**: 1

   BASIS (MINTS)
      :ref:`apdx:MINTS` |w---w| Primary basis set

      * **Type**: string
      * **Possible Values**: :ref:`basis string <apdx:basisElement>`
      * **Default**: No Default

   OMEGA_ERF (MINTS)
      :ref:`apdx:MINTS` |w---w| Omega scaling for Erf and Erfc.

      * **Type**: double
      * **Default**: 0.20

   E_CONVERGENCE (MRCC)
      :ref:`apdx:MRCC` |w---w| Convergence criterion for energy. See Table :ref:`Post-SCF Convergence <table:conv_corl>` for default convergence criteria for different calculation types. This becomes ``tol`` (option \#16) in fort.56.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-6

   INTS_TOLERANCE (MRCC)
      :ref:`apdx:MRCC` |w---w| Minimum absolute value below which integrals are neglected.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1.0e-12

   MRCC_LEVEL (MRCC)
      :ref:`apdx:MRCC` |w---w| Maximum excitation level. This is used ONLY if it is explicity set by the user. Single-reference case: all excitations up to this level are included, e.g., 2 for CCSD, 3 for CCSDT, 4 for CCSDTQ, etc. This becomes ``ex.lev`` (option \#1) in fort.56.

      * **Type**: integer
      * **Default**: 2

   MRCC_NUM_DOUBLET_ROOTS (MRCC)
      :ref:`apdx:MRCC` |w---w| Number of root in case of open shell system. This becomes ``ndoub`` (option \#13) int fort.56.

      * **Type**: integer
      * **Default**: 0

   MRCC_NUM_SINGLET_ROOTS (MRCC)
      :ref:`apdx:MRCC` |w---w| Number of singlet roots. (Strictly speaking number of of roots with M_s=0 and S is even.) Use this option only with closed shell reference determinant, it must be zero otherwise. This becomes ``nsing`` (option \#2) in fort.56.

      * **Type**: integer
      * **Default**: 1

   MRCC_NUM_TRIPLET_ROOTS (MRCC)
      :ref:`apdx:MRCC` |w---w| Number of triplet roots. (Strictly speaking number of of roots with :math:`M_s=0` and S is odd.) See notes at option |mrcc__mrcc_num_singlet_roots|. This becomes ``ntrip`` (option \#3) in fort.56.

      * **Type**: integer
      * **Default**: 0

   CACHELEVEL (OCC)
      :ref:`apdx:OCC` |w---w| Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., :math:`\langle ij | ab \rangle>` integrals) may be held in the cache.

      * **Type**: integer
      * **Default**: 2

   CCL_ENERGY (OCC)
      :ref:`apdx:OCC` |w---w| Do compute CC Lambda energy? In order to this option to be valid one should use "TPDM_ABCD_TYPE = COMPUTE" option.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   CC_DIIS_MAX_VECS (OCC)
      :ref:`apdx:OCC` |w---w| Maximum number of vectors used in amplitude DIIS

      * **Type**: integer
      * **Default**: 6

   CC_DIIS_MIN_VECS (OCC)
      :ref:`apdx:OCC` |w---w| Minimum number of vectors used in amplitude DIIS

      * **Type**: integer
      * **Default**: 2

   CC_MAXITER (OCC)
      :ref:`apdx:OCC` |w---w| Maximum number of iterations to determine the amplitudes

      * **Type**: integer
      * **Default**: 50

   CEPA_OS_SCALE (OCC)
      :ref:`apdx:OCC` |w---w| CEPA opposite-spin scaling value from SCS-CCSD

      * **Type**: double
      * **Default**: 1.27

   CEPA_SOS_SCALE (OCC)
      :ref:`apdx:OCC` |w---w| CEPA Spin-opposite scaling (SOS) value

      * **Type**: double
      * **Default**: 1.3

   CEPA_SS_SCALE (OCC)
      :ref:`apdx:OCC` |w---w| CEPA same-spin scaling value from SCS-CCSD

      * **Type**: double
      * **Default**: 1.13

   CEPA_TYPE (OCC)
      :ref:`apdx:OCC` |w---w| CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0.

      * **Type**: string
      * **Possible Values**: CEPA0
      * **Default**: CEPA0

   CUTOFF (OCC)
      :ref:`apdx:OCC` |w---w| Cutoff value for numerical procedures

      * **Type**: integer
      * **Default**: 14

   DO_DIIS (OCC)
      :ref:`apdx:OCC` |w---w| Do apply DIIS extrapolation?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   DO_LEVEL_SHIFT (OCC)
      :ref:`apdx:OCC` |w---w| Do apply level shifting?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   DO_SCS (OCC)
      :ref:`apdx:OCC` |w---w| Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set 'DO_SCS' to true

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   DO_SOS (OCC)
      :ref:`apdx:OCC` |w---w| Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set 'DO_SOS' to true

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   E3_SCALE (OCC)
      :ref:`apdx:OCC` |w---w| Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.)

      * **Type**: double
      * **Default**: 0.25

   EA_POLES (OCC)
      :ref:`apdx:OCC` |w---w| Do compute OCC poles for electron affinities? Only valid for OMP2.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   EKT_EA (OCC)
      :ref:`apdx:OCC` |w---w| Do compute virtual orbital energies based on extended Koopmans' theorem?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   EKT_IP (OCC)
      :ref:`apdx:OCC` |w---w| Do compute occupied orbital energies based on extended Koopmans' theorem?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   EP_EA_POLES (OCC)
      :ref:`apdx:OCC` |w---w| Do compute EP-OCC poles for electron affinities? Only valid for OMP2.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   EP_IP_POLES (OCC)
      :ref:`apdx:OCC` |w---w| Do compute EP-OCC poles for ionization potentials? Only valid OMP2.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   EP_MAXITER (OCC)
      :ref:`apdx:OCC` |w---w| Maximum number of electron propagator iterations.

      * **Type**: integer
      * **Default**: 30

   E_CONVERGENCE (OCC)
      :ref:`apdx:OCC` |w---w| Convergence criterion for energy. See Table :ref:`Post-SCF Convergence <table:conv_corl>` for default convergence criteria for different calculation types.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-6

   IP_POLES (OCC)
      :ref:`apdx:OCC` |w---w| Do compute OCC poles for ionization potentials? Only valid OMP2.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   LEVEL_SHIFT (OCC)
      :ref:`apdx:OCC` |w---w| Level shift to aid convergence

      * **Type**: double
      * **Default**: 0.02

   LINEQ_SOLVER (OCC)
      :ref:`apdx:OCC` |w---w| The solver will be used for simultaneous linear equations.

      * **Type**: string
      * **Possible Values**: CDGESV, FLIN, POPLE
      * **Default**: CDGESV

   MAX_MOGRAD_CONVERGENCE (OCC)
      :ref:`apdx:OCC` |w---w| Convergence criterion for maximum orbital gradient

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-3

   MOGRAD_DAMPING (OCC)
      :ref:`apdx:OCC` |w---w| Damping factor for the orbital gradient (Rendell et al., JCP, vol. 87, pp. 5976, 1987)

      * **Type**: double
      * **Default**: 1.0

   MO_DIIS_NUM_VECS (OCC)
      :ref:`apdx:OCC` |w---w| Number of vectors used in orbital DIIS

      * **Type**: integer
      * **Default**: 6

   MO_MAXITER (OCC)
      :ref:`apdx:OCC` |w---w| Maximum number of iterations to determine the orbitals

      * **Type**: integer
      * **Default**: 50

   MO_READ (OCC)
      :ref:`apdx:OCC` |w---w| Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   MO_STEP_MAX (OCC)
      :ref:`apdx:OCC` |w---w| Maximum step size in orbital-optimization procedure

      * **Type**: double
      * **Default**: 0.5

   MO_WRITE (OCC)
      :ref:`apdx:OCC` |w---w| Do write coefficient matrices to external files for direct reading MOs in a subsequent job?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   MP2_OS_SCALE (OCC)
      :ref:`apdx:OCC` |w---w| MP2 opposite-spin scaling value

      * **Type**: double
      * **Default**: 6.0/5.0

   MP2_SOS_SCALE (OCC)
      :ref:`apdx:OCC` |w---w| MP2 Spin-opposite scaling (SOS) value

      * **Type**: double
      * **Default**: 1.3

   MP2_SOS_SCALE2 (OCC)
      :ref:`apdx:OCC` |w---w| Spin-opposite scaling (SOS) value for optimized-MP2 orbitals

      * **Type**: double
      * **Default**: 1.2

   MP2_SS_SCALE (OCC)
      :ref:`apdx:OCC` |w---w| MP2 same-spin scaling value

      * **Type**: double
      * **Default**: 1.0/3.0

   MP2_TYPE (OCC)
      :ref:`apdx:OCC` |w---w| Algorithm to use for non-OO MP2 computation

      * **Type**: string
      * **Possible Values**: DF, CONV
      * **Default**: DF

   NAT_ORBS (OCC)
      :ref:`apdx:OCC` |w---w| Do compute natural orbitals?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   OCC_ORBS_PRINT (OCC)
      :ref:`apdx:OCC` |w---w| Do print OCC orbital energies?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   OPT_METHOD (OCC)
      :ref:`apdx:OCC` |w---w| The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option.

      * **Type**: string
      * **Possible Values**: MSD, ORB\_RESP
      * **Default**: ORB\_RESP

   ORB_OPT (OCC)
      :ref:`apdx:OCC` |w---w| Do optimize the orbitals?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   ORB_RESP_SOLVER (OCC)
      :ref:`apdx:OCC` |w---w| The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method.

      * **Type**: string
      * **Possible Values**: PCG, LINEQ
      * **Default**: PCG

   ORTH_TYPE (OCC)
      :ref:`apdx:OCC` |w---w| The algorithm for orthogonalization of MOs

      * **Type**: string
      * **Possible Values**: GS, MGS
      * **Default**: MGS

   PCG_BETA_TYPE (OCC)
      :ref:`apdx:OCC` |w---w| Type of PCG beta parameter (Fletcher-Reeves or Polak-Ribiere).

      * **Type**: string
      * **Possible Values**: FLETCHER\_REEVES, POLAK\_RIBIERE
      * **Default**: FLETCHER\_REEVES

   PCG_CONVERGENCE (OCC)
      :ref:`apdx:OCC` |w---w| Convergence criterion for residual vector of preconditioned conjugate gradient method.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-6

   PCG_MAXITER (OCC)
      :ref:`apdx:OCC` |w---w| Maximum number of preconditioned conjugate gradient iterations.

      * **Type**: integer
      * **Default**: 30

   RMS_MOGRAD_CONVERGENCE (OCC)
      :ref:`apdx:OCC` |w---w| Convergence criterion for RMS orbital gradient. Default adjusts depending on |occ__e_convergence|.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-6

   R_CONVERGENCE (OCC)
      :ref:`apdx:OCC` |w---w| Convergence criterion for amplitudes (residuals).

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-5

   SCS_TYPE (OCC)
      :ref:`apdx:OCC` |w---w| Type of the SCS method

      * **Type**: string
      * **Possible Values**: SCS, SCSN, SCSVDW, SCSMI
      * **Default**: SCS

   SOS_TYPE (OCC)
      :ref:`apdx:OCC` |w---w| Type of the SOS method

      * **Type**: string
      * **Possible Values**: SOS, SOSPI
      * **Default**: SOS

   TPDM_ABCD_TYPE (OCC)
      :ref:`apdx:OCC` |w---w| How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix.

      * **Type**: string
      * **Possible Values**: DIRECT, COMPUTE
      * **Default**: DIRECT

   WFN_TYPE (OCC)
      :ref:`apdx:OCC` |w---w| Type of the wavefunction.

      * **Type**: string
      * **Possible Values**: OMP2, OMP3, OCEPA, OMP2.5
      * **Default**: OMP2

   CONSECUTIVE_BACKSTEPS (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Set number of consecutive backward steps allowed in optimization

      * **Type**: integer
      * **Default**: 0

   FIXED_BEND (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Specify angles between atoms to be fixed (eq. value specified)

      * **Type**: string
      * **Default**: No Default

   FIXED_DIHEDRAL (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Specify dihedral angles between atoms to be fixed (eq. value specified)

      * **Type**: string
      * **Default**: No Default

   FIXED_DISTANCE (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Specify distances between atoms to be fixed (eq. value specified)

      * **Type**: string
      * **Default**: No Default

   FROZEN_BEND (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Specify angles between atoms to be frozen (unchanged)

      * **Type**: string
      * **Default**: No Default

   FROZEN_DIHEDRAL (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Specify dihedral angles between atoms to be frozen (unchanged)

      * **Type**: string
      * **Default**: No Default

   FROZEN_DISTANCE (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Specify distances between atoms to be frozen (unchanged)

      * **Type**: string
      * **Default**: No Default

   GEOM_MAXITER (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Maximum number of geometry optimization steps

      * **Type**: integer
      * **Default**: 50

   INTERFRAG_STEP_LIMIT (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Maximum step size in bohr or radian along an interfragment coordinate

      * **Type**: double
      * **Default**: 0.4

   INTRAFRAG_STEP_LIMIT (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Initial maximum step size in bohr or radian along an internal coordinate

      * **Type**: double
      * **Default**: 0.4

   INTRAFRAG_STEP_LIMIT_MAX (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Upper bound for dynamic trust radius [au]

      * **Type**: double
      * **Default**: 1.0

   INTRAFRAG_STEP_LIMIT_MIN (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Lower bound for dynamic trust radius [au]

      * **Type**: double
      * **Default**: 0.001

   IRC_DIRECTION (OPTKING)
      :ref:`apdx:OPTKING` |w---w| IRC mapping direction

      * **Type**: string
      * **Possible Values**: FORWARD, BACKWARD
      * **Default**: FORWARD

   IRC_STEP_SIZE (OPTKING)
      :ref:`apdx:OPTKING` |w---w| IRC step size in bohr(amu)\ :math:`^{1/2}`.

      * **Type**: double
      * **Default**: 0.2

   IRC_STOP (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Decide when to stop IRC calculations

      * **Type**: string
      * **Possible Values**: ASK, STOP, GO
      * **Default**: STOP

   OPT_TYPE (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Specifies minimum search, transition-state search, or IRC following

      * **Type**: string
      * **Possible Values**: MIN, TS, IRC
      * **Default**: MIN

   RFO_FOLLOW_ROOT (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Do follow the initial RFO vector after the first step?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   RFO_ROOT (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Root for RFO to follow, 0 being lowest (for a minimum)

      * **Type**: integer
      * **Default**: 0

   STEP_TYPE (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Geometry optimization step type, either Newton-Raphson or Rational Function Optimization

      * **Type**: string
      * **Possible Values**: RFO, NR, SD, LINESEARCH\_STATIC
      * **Default**: RFO

   FLEXIBLE_G_CONVERGENCE (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Even if a user-defined threshold is set, allow for normal, flexible convergence criteria

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   G_CONVERGENCE (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless |optking__flexible_g_convergence| is also on. See Table :ref:`Geometry Convergence <table:optkingconv>` for details.

      * **Type**: string
      * **Possible Values**: QCHEM, MOLPRO, GAU, GAU\_LOOSE, GAU\_TIGHT, GAU\_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM\_LOOSE
      * **Default**: QCHEM

   MAX_DISP_G_CONVERGENCE (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units).

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1.2e-3

   MAX_ENERGY_G_CONVERGENCE (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Convergence criterion for geometry optmization: maximum energy change.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1.0e-6

   MAX_FORCE_G_CONVERGENCE (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Convergence criterion for geometry optmization: maximum force (internal coordinates, atomic units).

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 3.0e-4

   RMS_DISP_G_CONVERGENCE (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Convergence criterion for geometry optmization: rms displacement (internal coordinates, atomic units).

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1.2e-3

   RMS_FORCE_G_CONVERGENCE (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Convergence criterion for geometry optmization: rms force (internal coordinates, atomic units).

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 3.0e-4

   CART_HESS_READ (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Do read Cartesian Hessian? Only for experts - use |optking__full_hess_every| instead.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   FULL_HESS_EVERY (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian.

      * **Type**: integer
      * **Default**: -1

   HESS_UPDATE (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Hessian update scheme

      * **Type**: string
      * **Possible Values**: NONE, BFGS, MS, POWELL, BOFILL
      * **Default**: BFGS

   HESS_UPDATE_LIMIT (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Do limit the magnitude of changes caused by the Hessian update?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   HESS_UPDATE_LIMIT_MAX (OPTKING)
      :ref:`apdx:OPTKING` |w---w| If |optking__hess_update_limit| is true, changes to the Hessian from the update are limited to the larger of |optking__hess_update_limit_scale| * (the previous value) and HESS_UPDATE_LIMIT_MAX [au].

      * **Type**: double
      * **Default**: 1.00

   HESS_UPDATE_LIMIT_SCALE (OPTKING)
      :ref:`apdx:OPTKING` |w---w| If |optking__hess_update_limit| is true, changes to the Hessian from the update are limited to the larger of HESS_UPDATE_LIMIT_SCALE * (the previous value) and |optking__hess_update_limit_max| [au].

      * **Type**: double
      * **Default**: 0.50

   HESS_UPDATE_USE_LAST (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Number of previous steps to use in Hessian update, 0 uses all

      * **Type**: integer
      * **Default**: 1

   INTRAFRAG_HESS (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Model Hessian to guess intrafragment force constants

      * **Type**: string
      * **Possible Values**: FISCHER, SCHLEGEL, SIMPLE, LINDH
      * **Default**: SCHLEGEL

   ADD_AUXILIARY_BONDS (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Do add bond coordinates at nearby atoms for non-bonded systems?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   COVALENT_CONNECT (OPTKING)
      :ref:`apdx:OPTKING` |w---w| When determining connectivity, a bond is assigned if interatomic distance is less than (this number) * sum of covalent radii.

      * **Type**: double
      * **Default**: 1.3

   FRAG_MODE (OPTKING)
      :ref:`apdx:OPTKING` |w---w| For multi-fragment molecules, treat as single bonded molecule or via interfragment coordinates. A primary difference is that in ``MULTI`` mode, the interfragment coordinates are not redundant.

      * **Type**: string
      * **Possible Values**: SINGLE, MULTI
      * **Default**: SINGLE

   FREEZE_INTERFRAG (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Do freeze all interfragment modes?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   FREEZE_INTRAFRAG (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Do freeze all fragments rigid?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   H_BOND_CONNECT (OPTKING)
      :ref:`apdx:OPTKING` |w---w| For now, this is a general maximum distance for the definition of H-bonds

      * **Type**: double
      * **Default**: 4.3

   INTCOS_GENERATE_EXIT (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Do only generate the internal coordinates and then stop?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   INTERFRAGMENT_CONNECT (OPTKING)
      :ref:`apdx:OPTKING` |w---w| When connecting disparate fragments when frag_mode = SIMPLE, a "bond" is assigned if interatomic distance is less than (this number) * sum of covalent radii. The value is then increased until all the fragments are connected (directly or indirectly).

      * **Type**: double
      * **Default**: 1.8

   INTERFRAG_DIST_INV (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Do use :math:`\frac{1}{R_{AB}}` for the stretching coordinate between fragments? Otherwise, use :math:`R_{AB}`.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   INTERFRAG_HESS (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Model Hessian to guess interfragment force constants

      * **Type**: string
      * **Possible Values**: DEFAULT, FISCHER\_LIKE
      * **Default**: DEFAULT

   INTERFRAG_MODE (OPTKING)
      :ref:`apdx:OPTKING` |w---w| When interfragment coordinates are present, use as reference points either principal axes or fixed linear combinations of atoms.

      * **Type**: string
      * **Possible Values**: FIXED, INTERFRAGMENT
      * **Default**: FIXED

   FINAL_GEOM_WRITE (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Do save and print the geometry from the last projected step at the end of a geometry optimization? Otherwise (and by default), save and print the previous geometry at which was computed the gradient that satisfied the convergence criteria.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   KEEP_INTCOS (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Keep internal coordinate definition file.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   LINESEARCH_STATIC_MAX (OPTKING)
      :ref:`apdx:OPTKING` |w---w| If doing a static line search, this fixes the largest step, whose largest change in an internal coordinate is set to this value (in au)

      * **Type**: double
      * **Default**: 0.100

   LINESEARCH_STATIC_MIN (OPTKING)
      :ref:`apdx:OPTKING` |w---w| If doing a static line search, this fixes the shortest step, whose largest change in an internal coordinate is set to this value (in au)

      * **Type**: double
      * **Default**: 0.001

   LINESEARCH_STATIC_N (OPTKING)
      :ref:`apdx:OPTKING` |w---w| If doing a static line search, scan this many points.

      * **Type**: integer
      * **Default**: 8

   TEST_B (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Do test B matrix?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   TEST_DERIVATIVE_B (OPTKING)
      :ref:`apdx:OPTKING` |w---w| Do test derivative B matrix?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   ACTIVE (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| The number of active orbitals per irrep

      * **Type**: array
      * **Default**: No Default

   CC_NUM_THREADS (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| Number of threads

      * **Type**: integer
      * **Default**: 1

   CORR_ANSATZ (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| The ansatz to use for MRCC computations

      * **Type**: string
      * **Possible Values**: SR, MK, BW, APBW
      * **Default**: MK

   CORR_CCSD_T (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| The type of CCSD(T) computation to perform

      * **Type**: string
      * **Possible Values**: STANDARD, PITTNER
      * **Default**: STANDARD

   CORR_CHARGE (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| The molecular charge of the target state

      * **Type**: integer
      * **Default**: 0

   CORR_MULTP (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| The multiplicity, :math:`M_S(M_S+1)`, of the target state. Must be specified if different from the reference :math:`M_s`.

      * **Type**: integer
      * **Default**: 1

   CORR_WFN (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| The type of correlated wavefunction

      * **Type**: string
      * **Possible Values**: PT2, CCSD, MP2-CCSD, CCSD\_T
      * **Default**: CCSD

   COUPLING (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| The order of coupling terms to include in MRCCSDT computations

      * **Type**: string
      * **Possible Values**: NONE, LINEAR, QUADRATIC, CUBIC
      * **Default**: CUBIC

   COUPLING_TERMS (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| Do include the terms that couple the reference determinants?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   DAMPING_PERCENTAGE (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| The amount (percentage) of damping to apply to the amplitude updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20\% of the amplitudes from the previous iteration being mixed into the current iteration) can help in cases where oscillatory convergence is observed.

      * **Type**: double
      * **Default**: 0.0

   DIAGONALIZE_HEFF (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| Do diagonalize the effective Hamiltonian?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   DIAGONAL_CCSD_T (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| Do include the diagonal corrections in (T) computations?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   DIIS_MAX_VECS (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| Maximum number of error vectors stored for DIIS extrapolation

      * **Type**: integer
      * **Default**: 7

   DIIS_START (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| The number of DIIS vectors needed before extrapolation is performed

      * **Type**: integer
      * **Default**: 2

   E_CONVERGENCE (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| Convergence criterion for energy. See Table :ref:`Post-SCF Convergence <table:conv_corl>` for default convergence criteria for different calculation types.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-6

   FAVG_CCSD_T (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| Do use the averaged Fock matrix over all references in (T) computations?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   FOLLOW_ROOT (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| Which root of the effective hamiltonian is the target state?

      * **Type**: integer
      * **Default**: 1

   FROZEN_DOCC (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| The number of frozen occupied orbitals per irrep

      * **Type**: array
      * **Default**: No Default

   FROZEN_UOCC (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| The number of frozen virtual orbitals per irrep

      * **Type**: array
      * **Default**: No Default

   HEFF4 (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| Do include the fourth-order contributions to the effective Hamiltonian?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   HEFF_PRINT (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| Do print the effective Hamiltonian?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   LOCK_SINGLET (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| Do lock onto a singlet root?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   MAXITER (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| Maximum number of iterations to determine the amplitudes

      * **Type**: integer
      * **Default**: 100

   MP2_CCSD_METHOD (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| How to perform MP2_CCSD computations

      * **Type**: string
      * **Possible Values**: I, IA, II
      * **Default**: II

   MP2_GUESS (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| Do start from a MP2 guess?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   NO_SINGLES (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| Do disregard updating single excitation amplitudes?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   OFFDIAGONAL_CCSD_T (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| Do include the off-diagonal corrections in (T) computations?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   PT_ENERGY (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| The type of perturbation theory computation to perform

      * **Type**: string
      * **Possible Values**: SECOND\_ORDER, SCS\_SECOND\_ORDER, PSEUDO\_SECOND\_ORDER, SCS\_PSEUDO\_SECOND\_ORDER
      * **Default**: SECOND\_ORDER

   RESTRICTED_DOCC (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| The number of doubly occupied orbitals per irrep

      * **Type**: array
      * **Default**: No Default

   R_CONVERGENCE (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| Convergence criterion for amplitudes (residuals).

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-9

   SMALL_CUTOFF (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| 

      * **Type**: integer
      * **Default**: 0

   TIKHONOW_MAX (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| The cycle after which Tikhonow regularization is stopped. Set to zero to allow regularization in all iterations

      * **Type**: integer
      * **Default**: 5

   TIKHONOW_OMEGA (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| The shift to apply to the denominators, {\it c.f.} Taube and Bartlett, JCP, 130, 144112 (2009)

      * **Type**: double
      * **Default**: 0.0

   TRIPLES_ALGORITHM (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| The type of algorithm to use for (T) computations

      * **Type**: string
      * **Possible Values**: SPIN\_ADAPTED, RESTRICTED, UNRESTRICTED
      * **Default**: RESTRICTED

   TRIPLES_DIIS (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| Do use DIIS extrapolation to accelerate convergence for iterative triples excitations?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   USE_SPIN_SYM (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| Do use symmetry to map equivalent determinants onto each other, for efficiency?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   WFN_SYM (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| The symmetry of the target wavefunction, specified either by Sch\ |o_dots|\ nflies symbol, or irrep number (in Cotton ordering)

      * **Type**: string
      * **Possible Values**: A, AG, AU, AP, APP, A1, A2, B, BG, BU, B1, B2, B3, B1G, B2G, B3G, B1U, B2U, B3U, 0, 1, 2, 3, 4, 5, 6, 7, 8
      * **Default**: 1

   ZERO_INTERNAL_AMPS (PSIMRCC)
      :ref:`apdx:PSIMRCC` |w---w| Do zero the internal amplitudes, i.e., those that map reference determinants onto each other?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   AIO_CPHF (SAPT)
      :ref:`apdx:SAPT` |w---w| Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   AIO_DF_INTS (SAPT)
      :ref:`apdx:SAPT` |w---w| Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   BASIS (SAPT)
      :ref:`apdx:SAPT` |w---w| Primary basis set, describes the monomer molecular orbitals

      * **Type**: string
      * **Possible Values**: :ref:`basis string <apdx:basisElement>`
      * **Default**: No Default

   CCD_E_CONVERGENCE (SAPT)
      :ref:`apdx:SAPT` |w---w| E converge value for CCD

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-8

   CCD_MAXITER (SAPT)
      :ref:`apdx:SAPT` |w---w| Max CCD iterations

      * **Type**: integer
      * **Default**: 50

   CCD_T_CONVERGENCE (SAPT)
      :ref:`apdx:SAPT` |w---w| Convergence tolerance for CCD amplitudes

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-8

   DENOMINATOR_ALGORITHM (SAPT)
      :ref:`apdx:SAPT` |w---w| Denominator algorithm for PT methods. Laplace transformations are slightly more efficient.

      * **Type**: string
      * **Possible Values**: LAPLACE, CHOLESKY
      * **Default**: LAPLACE

   DENOMINATOR_DELTA (SAPT)
      :ref:`apdx:SAPT` |w---w| Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the :math:`E_{disp}^{(20)}` and :math:`E_{exch-disp}^{(20)}` evaluation.

      * **Type**: double
      * **Default**: 1.0e-6

   DF_BASIS_ELST (SAPT)
      :ref:`apdx:SAPT` |w---w| Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to |sapt__df_basis_sapt|.

      * **Type**: string
      * **Possible Values**: :ref:`basis string <apdx:basisElement>`
      * **Default**: No Default

   DF_BASIS_SAPT (SAPT)
      :ref:`apdx:SAPT` |w---w| Auxiliary basis set for SAPT density fitting computations. :ref:`Defaults <apdx:basisFamily>` to a RI basis.

      * **Type**: string
      * **Possible Values**: :ref:`basis string <apdx:basisElement>`
      * **Default**: No Default

   D_CONVERGENCE (SAPT)
      :ref:`apdx:SAPT` |w---w| Convergence criterion for residual of the CPHF coefficients in the SAPT :math:`E_{ind,resp}^{(20)}` term.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-8

   E_CONVERGENCE (SAPT)
      :ref:`apdx:SAPT` |w---w| Convergence criterion for energy (change) in the SAPT :math:`E_{ind,resp}^{(20)}` term during solution of the CPHF equations.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-10

   FREEZE_CORE (SAPT)
      :ref:`apdx:SAPT` |w---w| The scope of core orbitals to freeze in evaluation of SAPT :math:`E_{disp}^{(20)}` and :math:`E_{exch-disp}^{(20)}` terms. Recommended true for all SAPT computations

      * **Type**: string
      * **Possible Values**: FALSE, TRUE
      * **Default**: FALSE

   INTS_TOLERANCE (SAPT)
      :ref:`apdx:SAPT` |w---w| Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn't much to be gained from loosening it, especially for higher-order SAPT.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1.0e-12

   MAXITER (SAPT)
      :ref:`apdx:SAPT` |w---w| Maxmum number of CPHF iterations

      * **Type**: integer
      * **Default**: 50

   MAX_CCD_DIISVECS (SAPT)
      :ref:`apdx:SAPT` |w---w| Maximum number of vectors used in CCD-DIIS

      * **Type**: integer
      * **Default**: 10

   MIN_CCD_DIISVECS (SAPT)
      :ref:`apdx:SAPT` |w---w| Minimumnumber of vectors used in CCD-DIIS

      * **Type**: integer
      * **Default**: 4

   NAT_ORBS_T2 (SAPT)
      :ref:`apdx:SAPT` |w---w| Do use MP2 natural orbital approximations for the :math:`v^4` block of two-electron integrals in the evaluation of second-order T2 amplitudes? Recommended true for all SAPT computations.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   NAT_ORBS_T3 (SAPT)
      :ref:`apdx:SAPT` |w---w| Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   NAT_ORBS_V4 (SAPT)
      :ref:`apdx:SAPT` |w---w| Do use MP2 natural orbital approximations for the :math:`v^4` block of two-electron integrals in the evaluation of CCD T2 amplitudes? Recommended true for all SAPT computations.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   NO_RESPONSE (SAPT)
      :ref:`apdx:SAPT` |w---w| Don't solve the CPHF equations? Evaluate :math:`E_{ind}^{(20)}` and :math:`E_{exch-ind}^{(20)}` instead of their response-including coupterparts. Only turn on this option if the induction energy is not going to be used.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   OCC_TOLERANCE (SAPT)
      :ref:`apdx:SAPT` |w---w| Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for in each of the above three truncations

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1.0e-6

   PRINT (SAPT)
      :ref:`apdx:SAPT` |w---w| The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed.

      * **Type**: integer
      * **Default**: 1

   SAPT_LEVEL (SAPT)
      :ref:`apdx:SAPT` |w---w| The level of theory for SAPT

      * **Type**: string
      * **Possible Values**: SAPT0, SAPT2, SAPT2+, SAPT2+3
      * **Default**: SAPT0

   SAPT_MEM_CHECK (SAPT)
      :ref:`apdx:SAPT` |w---w| Do force SAPT2 and higher to die if it thinks there isn't enough memory? Turning this off is ill-advised.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   SAPT_MEM_SAFETY (SAPT)
      :ref:`apdx:SAPT` |w---w| Memory safety

      * **Type**: double
      * **Default**: 0.9

   SAPT_OS_SCALE (SAPT)
      :ref:`apdx:SAPT` |w---w| The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for :math:`E_{disp}^{(20)}` and :math:`E_{exch-disp}^{(20)}` terms.

      * **Type**: double
      * **Default**: 6.0/5.0

   SAPT_SS_SCALE (SAPT)
      :ref:`apdx:SAPT` |w---w| The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for :math:`E_{disp}^{(20)}` and :math:`E_{exch-disp}^{(20)}` terms.

      * **Type**: double
      * **Default**: 1.0/3.0

   BASIS (SCF)
      :ref:`apdx:SCF` |w---w| Primary basis set

      * **Type**: string
      * **Possible Values**: :ref:`basis string <apdx:basisElement>`
      * **Default**: No Default

   CHOLESKY_TOLERANCE (SCF)
      :ref:`apdx:SCF` |w---w| Tolerance for Cholesky decomposition of the ERI tensor

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-4

   DF_BASIS_SCF (SCF)
      :ref:`apdx:SCF` |w---w| Auxiliary basis set for SCF density fitting computations. :ref:`Defaults <apdx:basisFamily>` to a JKFIT basis.

      * **Type**: string
      * **Possible Values**: :ref:`basis string <apdx:basisElement>`
      * **Default**: No Default

   DF_SCF_GUESS (SCF)
      :ref:`apdx:SCF` |w---w| Use DF integrals tech to converge the SCF before switching to a conventional tech

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   GUESS (SCF)
      :ref:`apdx:SCF` |w---w| The type of guess orbitals. Defaults to CORE except for geometry optimizations, in which case READ becomes the default after the first geometry step.

      * **Type**: string
      * **Possible Values**: CORE, GWH, SAD, READ
      * **Default**: CORE

   INTS_TOLERANCE (SCF)
      :ref:`apdx:SCF` |w---w| Minimum absolute value below which TEI are neglected.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 0.0

   MOLDEN_WRITE (SCF)
      :ref:`apdx:SCF` |w---w| Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by |globals__writer_file_label| (if set), or else by the name of the output file plus the name of the current molecule.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   PRINT_BASIS (SCF)
      :ref:`apdx:SCF` |w---w| Flag to print the basis set.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   PRINT_MOS (SCF)
      :ref:`apdx:SCF` |w---w| Flag to print the molecular orbitals.

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   REFERENCE (SCF)
      :ref:`apdx:SCF` |w---w| Reference wavefunction type

      * **Type**: string
      * **Possible Values**: RHF, ROHF, UHF, CUHF, RKS, UKS
      * **Default**: RHF

   SAVE_JK (SCF)
      :ref:`apdx:SCF` |w---w| Keep JK object for later use?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   SCF_MEM_SAFETY_FACTOR (SCF)
      :ref:`apdx:SCF` |w---w| Memory safety factor for allocating JK

      * **Type**: double
      * **Default**: 0.75

   SCF_TYPE (SCF)
      :ref:`apdx:SCF` |w---w| What algorithm to use for the SCF computation. See Table :ref:`SCF Convergence & Algorithm <table:conv_scf>` for default algorithm for different calculation types.

      * **Type**: string
      * **Possible Values**: DIRECT, DF, PK, OUT\_OF\_CORE, FAST\_DF, CD
      * **Default**: PK

   S_ORTHOGONALIZATION (SCF)
      :ref:`apdx:SCF` |w---w| SO orthogonalization: symmetric or canonical?

      * **Type**: string
      * **Possible Values**: SYMMETRIC, CANONICAL
      * **Default**: SYMMETRIC

   S_TOLERANCE (SCF)
      :ref:`apdx:SCF` |w---w| Minimum S matrix eigenvalue to be used before compensating for linear dependencies.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-7

   BASIS_GUESS (SCF)
      :ref:`apdx:SCF` |w---w| Accelerate convergence by performing a preliminary scf with this small basis set followed by projection into the full target basis. A value of ``TRUE`` turns on projection using the 3-21G small basis set.

      * **Type**: string
      * **Default**: FALSE

   DAMPING_CONVERGENCE (SCF)
      :ref:`apdx:SCF` |w---w| The density convergence threshold after which damping is no longer performed, if it is enabled. It is recommended to leave damping on until convergence, which is the default.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1.0e-18

   DAMPING_PERCENTAGE (SCF)
      :ref:`apdx:SCF` |w---w| The amount (percentage) of damping to apply to the early density updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20\% of the previous iteration's density being mixed into the current density) could help to solve problems with oscillatory convergence.

      * **Type**: double
      * **Default**: 100.0

   DF_BASIS_GUESS (SCF)
      :ref:`apdx:SCF` |w---w| When |scf__basis_guess| is active, run the preliminary scf in density-fitted mode with this as fitting basis for the small basis set. A value of ``TRUE`` turns on density fitting with the cc-pVDZ-RI basis set (when available for all elements).

      * **Type**: string
      * **Possible Values**: :ref:`basis string <apdx:basisElement>`
      * **Default**: FALSE

   DIIS (SCF)
      :ref:`apdx:SCF` |w---w| Do use DIIS extrapolation to accelerate convergence?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   DIIS_MAX_VECS (SCF)
      :ref:`apdx:SCF` |w---w| Maximum number of error vectors stored for DIIS extrapolation

      * **Type**: integer
      * **Default**: 10

   DIIS_MIN_VECS (SCF)
      :ref:`apdx:SCF` |w---w| Minimum number of error vectors stored for DIIS extrapolation

      * **Type**: integer
      * **Default**: 2

   DIIS_START (SCF)
      :ref:`apdx:SCF` |w---w| The minimum iteration to start storing DIIS vectors

      * **Type**: integer
      * **Default**: 1

   D_CONVERGENCE (SCF)
      :ref:`apdx:SCF` |w---w| Convergence criterion for SCF density, which is defined as the RMS value of the orbital gradient. See Table :ref:`SCF Convergence & Algorithm <table:conv_scf>` for default convergence criteria for different calculation types.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-6

   E_CONVERGENCE (SCF)
      :ref:`apdx:SCF` |w---w| Convergence criterion for SCF energy. See Table :ref:`SCF Convergence & Algorithm <table:conv_scf>` for default convergence criteria for different calculation types.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-6

   FAIL_ON_MAXITER (SCF)
      :ref:`apdx:SCF` |w---w| Fail if we reach maxiter without converging?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   MAXITER (SCF)
      :ref:`apdx:SCF` |w---w| Maximum number of iterations

      * **Type**: integer
      * **Default**: 100

   MOM_OCC (SCF)
      :ref:`apdx:SCF` |w---w| The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta)

      * **Type**: array
      * **Default**: No Default

   MOM_START (SCF)
      :ref:`apdx:SCF` |w---w| The iteration to start MOM on (or 0 for no MOM)

      * **Type**: integer
      * **Default**: 0

   MOM_VIR (SCF)
      :ref:`apdx:SCF` |w---w| The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta)

      * **Type**: array
      * **Default**: No Default

   STABILITY_ANALYSIS (SCF)
      :ref:`apdx:SCF` |w---w| Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attemp to follow the eigenvector and re-run the computations to find a stable solution.

      * **Type**: string
      * **Possible Values**: NONE, CHECK, FOLLOW
      * **Default**: NONE

   FRAC_DIIS (SCF)
      :ref:`apdx:SCF` |w---w| Do use DIIS extrapolation to accelerate convergence in frac?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   FRAC_LOAD (SCF)
      :ref:`apdx:SCF` |w---w| Do recompute guess from stored orbitals?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   FRAC_OCC (SCF)
      :ref:`apdx:SCF` |w---w| The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta)

      * **Type**: array
      * **Default**: No Default

   FRAC_RENORMALIZE (SCF)
      :ref:`apdx:SCF` |w---w| Do renormalize C matrices prior to writing to checkpoint?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   FRAC_START (SCF)
      :ref:`apdx:SCF` |w---w| The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation)

      * **Type**: integer
      * **Default**: 0

   FRAC_VAL (SCF)
      :ref:`apdx:SCF` |w---w| The occupations of the orbital indices specified above (\ :math:`0.0\ge occ \ge 1.0`\ )

      * **Type**: array
      * **Default**: No Default

   EXTERN (SCF)
      :ref:`apdx:SCF` |w---w| An ExternalPotential (built by Python or NULL/None)

      * **Type**: python
      * **Default**: No Default

   ONEPOT_GRID_READ (SCF)
      :ref:`apdx:SCF` |w---w| Read an external potential from the .dx file?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   PERTURB_H (SCF)
      :ref:`apdx:SCF` |w---w| Do perturb the Hamiltonian?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   PERTURB_MAGNITUDE (SCF)
      :ref:`apdx:SCF` |w---w| Size of the perturbation (applies only to dipole perturbations)

      * **Type**: double
      * **Default**: 0.0

   PERTURB_WITH (SCF)
      :ref:`apdx:SCF` |w---w| The operator used to perturb the Hamiltonian, if requested

      * **Type**: string
      * **Possible Values**: DIPOLE\_X, DIPOLE\_Y, DIPOLE\_Z, EMBPOT, SPHERE, DX
      * **Default**: DIPOLE\_X

   PHI_POINTS (SCF)
      :ref:`apdx:SCF` |w---w| Number of azimuthal grid points for sphereical potential integration

      * **Type**: integer
      * **Default**: 360

   RADIUS (SCF)
      :ref:`apdx:SCF` |w---w| Radius (bohr) of a hard-sphere external potential

      * **Type**: double
      * **Default**: 10.0

   R_POINTS (SCF)
      :ref:`apdx:SCF` |w---w| Number of radial grid points for sphereical potential integration

      * **Type**: integer
      * **Default**: 100

   THETA_POINTS (SCF)
      :ref:`apdx:SCF` |w---w| Number of colatitude grid points for sphereical potential integration

      * **Type**: integer
      * **Default**: 360

   THICKNESS (SCF)
      :ref:`apdx:SCF` |w---w| Thickness (bohr) of a hard-sphere external potential

      * **Type**: double
      * **Default**: 20.0

   DF_BUMP_R0 (SCF)
      :ref:`apdx:SCF` |w---w| Bump function min radius

      * **Type**: double
      * **Default**: 0.0

   DF_BUMP_R1 (SCF)
      :ref:`apdx:SCF` |w---w| Bump function max radius

      * **Type**: double
      * **Default**: 0.0

   DF_DOMAINS (SCF)
      :ref:`apdx:SCF` |w---w| FastDF geometric fitting domain selection algorithm

      * **Type**: string
      * **Possible Values**: DIATOMIC, SPHERES
      * **Default**: DIATOMIC

   DF_INTS_NUM_THREADS (SCF)
      :ref:`apdx:SCF` |w---w| Number of threads for integrals (may be turned down if memory is an issue). 0 is blank

      * **Type**: integer
      * **Default**: 0

   DF_METRIC (SCF)
      :ref:`apdx:SCF` |w---w| FastDF Fitting Metric

      * **Type**: string
      * **Possible Values**: COULOMB, EWALD, OVERLAP
      * **Default**: COULOMB

   DF_THETA (SCF)
      :ref:`apdx:SCF` |w---w| FastDF SR Ewald metric range separation parameter

      * **Type**: double
      * **Default**: 1.0

   SAD_D_CONVERGENCE (SCF)
      :ref:`apdx:SCF` |w---w| Convergence criterion for SCF density in SAD Guess.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-5

   SAD_E_CONVERGENCE (SCF)
      :ref:`apdx:SCF` |w---w| Convergence criterion for SCF energy in SAD Guess.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-5

   DFT_ALPHA (SCF)
      :ref:`apdx:SCF` |w---w| The DFT Exact-exchange parameter

      * **Type**: double
      * **Default**: 0.0

   DFT_BASIS_TOLERANCE (SCF)
      :ref:`apdx:SCF` |w---w| DFT basis cutoff.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1.0e-12

   DFT_BS_RADIUS_ALPHA (SCF)
      :ref:`apdx:SCF` |w---w| Factor for effective BS radius in radial grid.

      * **Type**: double
      * **Default**: 1.0

   DFT_CUSTOM_FUNCTIONAL (SCF)
      :ref:`apdx:SCF` |w---w| A custom DFT functional object (built by Python or NULL/None)

      * **Type**: python
      * **Default**: No Default

   DFT_DISPERSION_PARAMETERS (SCF)
      :ref:`apdx:SCF` |w---w| Parameters defining the dispersion correction. See Table :ref:`-D Functionals <table:dft_disp>` for default values and Table :ref:`Dispersion Corrections <table:dashd>` for the order in which parameters are to be specified in this array option.

      * **Type**: array
      * **Default**: No Default

   DFT_FUNCTIONAL (SCF)
      :ref:`apdx:SCF` |w---w| The DFT combined functional name, e.g. B3LYP, or GEN to use a python reference to a custom functional specified by DFT_CUSTOM_FUNCTIONAL.

      * **Type**: string
      * **Default**: No Default

   DFT_NUCLEAR_SCHEME (SCF)
      :ref:`apdx:SCF` |w---w| Nuclear Scheme.

      * **Type**: string
      * **Possible Values**: TREUTLER, BECKE, NAIVE, STRATMANN
      * **Default**: TREUTLER

   DFT_OMEGA (SCF)
      :ref:`apdx:SCF` |w---w| The DFT Range-separation parameter

      * **Type**: double
      * **Default**: 0.0

   DFT_RADIAL_POINTS (SCF)
      :ref:`apdx:SCF` |w---w| Number of radial points.

      * **Type**: integer
      * **Default**: 75

   DFT_RADIAL_SCHEME (SCF)
      :ref:`apdx:SCF` |w---w| Radial Scheme.

      * **Type**: string
      * **Possible Values**: TREUTLER, BECKE, MULTIEXP, EM, MURA
      * **Default**: TREUTLER

   DFT_SPHERICAL_POINTS (SCF)
      :ref:`apdx:SCF` |w---w| Number of spherical points (A :ref:`Lebedev Points <table:lebedevorder>` number).

      * **Type**: integer
      * **Default**: 302

   DFT_SPHERICAL_SCHEME (SCF)
      :ref:`apdx:SCF` |w---w| Spherical Scheme.

      * **Type**: string
      * **Possible Values**: LEBEDEV
      * **Default**: LEBEDEV

   CACHELEVEL (STABILITY)
      :ref:`apdx:STABILITY` |w---w| 

      * **Type**: integer
      * **Default**: 2

   FOLLOW (STABILITY)
      :ref:`apdx:STABILITY` |w---w| Do follow the most negative eigenvalue of the Hessian towards a lower energy HF solution? Follow a UHF :math:`\rightarrow` UHF instability of same symmetry?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   NUM_VECS_PRINT (STABILITY)
      :ref:`apdx:STABILITY` |w---w| Number of lowest MO Hessian eigenvalues to print

      * **Type**: integer
      * **Default**: 0

   REFERENCE (STABILITY)
      :ref:`apdx:STABILITY` |w---w| Reference wavefunction type

      * **Type**: string
      * **Possible Values**: RHF, UHF, ROHF
      * **Default**: RHF

   ROTATION_SCHEME (STABILITY)
      :ref:`apdx:STABILITY` |w---w| Method for following eigenvectors, either 0 by angles or 1 by antisymmetric matrix.

      * **Type**: integer
      * **Default**: 0

   SCALE (STABILITY)
      :ref:`apdx:STABILITY` |w---w| Scale factor (between 0 and 1) for orbital rotation step

      * **Type**: double
      * **Default**: 0.5

   P (THERMO)
      :ref:`apdx:THERMO` |w---w| Pressure in Pascal for thermodynamic analysis.

      * **Type**: double
      * **Default**: 101325

   T (THERMO)
      :ref:`apdx:THERMO` |w---w| Temperature in Kelvin for thermodynamic analysis.

      * **Type**: double
      * **Default**: 298.15

   AA_M_FILE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| MO basis (PQ|RS) type two-electron integrals file

      * **Type**: integer
      * **Default**: PSIF\_MO\_AA\_TEI

   AB_M_FILE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| MO basis (PQ|rs) type two-electron integrals file

      * **Type**: integer
      * **Default**: PSIF\_MO\_AB\_TEI

   AO_BASIS (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| The algorithm to use for the :math:`\left<VV||VV\right>` terms

      * **Type**: string
      * **Possible Values**: NONE, DISK, DIRECT
      * **Default**: NONE

   BB_M_FILE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| MO basis (pq|rs) type two-electron integrals file

      * **Type**: integer
      * **Default**: PSIF\_MO\_BB\_TEI

   CHECK_C_ORTHONORM (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Do check MO orthogonality condition?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   DELETE_AO (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Do delete AO integral files?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   DELETE_RESTR_DOCC (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Do delete restricted doubly occupieds?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   DELETE_TPDM (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Do delete TPDM file?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   DO_ALL_TEI (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Do transform all TEIs

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   FIRST_TMP_FILE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| First temporary file

      * **Type**: integer
      * **Default**: 150

   FZC_A_FILE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Alpha-spin frozen-core file

      * **Type**: integer
      * **Default**: PSIF\_OEI

   FZC_B_FILE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Beta-spin frozen-core file

      * **Type**: integer
      * **Default**: PSIF\_OEI

   FZC_FILE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Frozen-core file

      * **Type**: integer
      * **Default**: PSIF\_OEI

   INTS_TOLERANCE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Minimum absolute value below which integrals are neglected.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-14

   IVO (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Do form improved virtual orbitals (IVO)?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   J_FILE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Half-transformed integrals

      * **Type**: integer
      * **Default**: 91

   KEEP_J (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Do keep half-transformed integrals?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   KEEP_PRESORT (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Do keep presort file?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   LAGRAN_DOUBLE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Do multiply the MO-lagrangian by 2.0?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   LAGRAN_HALVE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Do divide the MO-lagrangian by 2.0?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   LAG_IN_FILE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| MO-basis MO-lagrangian file

      * **Type**: integer
      * **Default**: PSIF\_MO\_LAG

   MAX_BUCKETS (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Maximum buckets

      * **Type**: integer
      * **Default**: 499

   MODE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| The way of transformation, from ao basis to mo basis or vice versa

      * **Type**: string
      * **Possible Values**: TO\_MO, TO\_AO
      * **Default**: TO\_MO

   MOORDER (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Numbering of MOs for reordering requests?

      * **Type**: array
      * **Default**: No Default

   MP2R12A (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Transformations for explicitly-correlated MP2 methods

      * **Type**: string
      * **Possible Values**: MP2R12AERI, MP2R12AR12, MP2R12AR12T1
      * **Default**: MP2R12AERI

   M_FILE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Output integrals file

      * **Type**: integer
      * **Default**: 0

   OEI_A_FILE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Alpha-spin one-electron parameters file

      * **Type**: integer
      * **Default**: PSIF\_OEI

   OEI_B_FILE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Beta-spin one-electron parameters file

      * **Type**: integer
      * **Default**: PSIF\_OEI

   OEI_FILE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| One-electron parameters file

      * **Type**: integer
      * **Default**: PSIF\_OEI

   OPDM_IN_FILE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| MO-basis one-particle density matrix file

      * **Type**: integer
      * **Default**: PSIF\_MO\_OPDM

   OPDM_OUT_FILE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| AO-basis one-particle density matrix file

      * **Type**: integer
      * **Default**: PSIF\_AO\_OPDM

   PITZER (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Do use Pitzer ordering?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   PRESORT_FILE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| SO-basis presort file

      * **Type**: integer
      * **Default**: PSIF\_SO\_PRESORT

   PRINT_LVL (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| The amount of information to print to the output file. 1 prints basic information, and higher levels print more information. A value of 5 will print very large amounts of debugging information.

      * **Type**: integer
      * **Default**: 1

   PRINT_MOS (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Do print MOs?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   PRINT_OE_INTEGRALS (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Do print one-electron integrals?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   PRINT_REORDER (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Do print reordered MOs?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   PRINT_SORTED_OE_INTS (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Do print sorted one-electron integrals?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   PRINT_SORTED_TE_INTS (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Do print sorted two-electron integrals (TEIs)?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   PRINT_TE_INTEGRALS (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Do print two-electron integrals?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   PSIMRCC (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Do specific arrangements for PSIMRCC?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   QRHF (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Do form quasi RHF (QRHF) orbitals?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   REFERENCE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Reference wavefunction type

      * **Type**: string
      * **Default**: RHF

   REORDER (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Do reorder MOs?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   RESTRICTED_DOCC (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF)

      * **Type**: array
      * **Default**: No Default

   RESTRICTED_UOCC (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF)

      * **Type**: array
      * **Default**: No Default

   SORTED_TEI_FILE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| MO-basis sorted two-electron integrals file

      * **Type**: integer
      * **Default**: PSIF\_MO\_TEI

   SO_S_FILE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| SO basis overlap matrix file

      * **Type**: integer
      * **Default**: PSIF\_OEI

   SO_TEI_FILE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| SO basis two-electron integrals file

      * **Type**: integer
      * **Default**: PSIF\_SO\_TEI

   SO_T_FILE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| SO basis kinetic energy matrix file

      * **Type**: integer
      * **Default**: PSIF\_OEI

   SO_V_FILE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| SO basis potential energy matrix file

      * **Type**: integer
      * **Default**: PSIF\_OEI

   TPDM_ADD_REF (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| Do add reference contribution to TPDM?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   TPDM_FILE (TRANSQT)
      :ref:`apdx:TRANSQT` |w---w| MO-basis two-particle density matrix file

      * **Type**: integer
      * **Default**: PSIF\_MO\_TPDM

   AO_BASIS (TRANSQT2)
      :ref:`apdx:TRANSQT2` |w---w| The algorithm to use for the :math:`\left<VV||VV\right>` terms

      * **Type**: string
      * **Possible Values**: NONE, DISK, DIRECT
      * **Default**: NONE

   DELETE_TEI (TRANSQT2)
      :ref:`apdx:TRANSQT2` |w---w| Boolean to delete the SO-basis two-electron integral file after the transformation

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   INTS_TOLERANCE (TRANSQT2)
      :ref:`apdx:TRANSQT2` |w---w| Minimum absolute value below which integrals are neglected.

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-14

   PRINT_TEI (TRANSQT2)
      :ref:`apdx:TRANSQT2` |w---w| Do print two-electron integrals (TEIs)?

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   REFERENCE (TRANSQT2)
      :ref:`apdx:TRANSQT2` |w---w| Reference wavefunction type

      * **Type**: string
      * **Default**: RHF

   SEMICANONICAL (TRANSQT2)
      :ref:`apdx:TRANSQT2` |w---w| Convert ROHF MOs to semicanonical MOs

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true


   DEBUG (GLOBALS)
      :ref:`apdx:GLOBALS` **(Expert)** |w---w| The amount of information to print to the output file 

      * **Type**: integer
      * **Default**: 0

   DERTYPE (GLOBALS)
      :ref:`apdx:GLOBALS` **(Expert)** |w---w| Derivative level 

      * **Type**: string
      * **Possible Values**: NONE, FIRST, SECOND, RESPONSE
      * **Default**: NONE

   DIE_IF_NOT_CONVERGED (GLOBALS)
      :ref:`apdx:GLOBALS` **(Expert)** |w---w| PSI4 dies if energy does not converge. 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   MAT_NUM_COLUMN_PRINT (GLOBALS)
      :ref:`apdx:GLOBALS` **(Expert)** |w---w| Number of columns to print in calls to ``Matrix::print_mat``. 

      * **Type**: integer
      * **Default**: 5

   WFN (GLOBALS)
      :ref:`apdx:GLOBALS` **(Expert)** |w---w| Wavefunction type 

      * **Type**: string
      * **Default**: SCF

   AEL (CCDENSITY)
      :ref:`apdx:CCDENSITY` **(Expert)** |w---w| Do compute the approximate excitation level? See Stanton and Bartlett, JCP, 98, 1993, 7034. 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   WFN (CCDENSITY)
      :ref:`apdx:CCDENSITY` **(Expert)** |w---w| Wavefunction type 

      * **Type**: string
      * **Default**: SCF

   XI_CONNECT (CCDENSITY)
      :ref:`apdx:CCDENSITY` **(Expert)** |w---w| Do require :math:`\bar{H}` and :math:`R` to be connected? 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   AO_BASIS (CCENERGY)
      :ref:`apdx:CCENERGY` **(Expert)** |w---w| The algorithm to use for the :math:`\left<VV||VV\right>` terms If AO_BASIS is ``NONE``, the MO-basis integrals will be used; if AO_BASIS is ``DISK``, the AO-basis integrals stored on disk will be used; if AO_BASIS is ``DIRECT``, the AO-basis integrals will be computed on the fly as necessary. NB: The ``DIRECT`` option is not fully implemented and should only be used by experts. Default is NONE. Note: The developers recommend use of this keyword only as a last resort because it significantly slows the calculation. The current algorithms for handling the MO-basis four-virtual-index integrals have been significantly improved and are preferable to the AO-based approach. 

      * **Type**: string
      * **Possible Values**: NONE, DISK, DIRECT
      * **Default**: NONE

   FORCE_RESTART (CCENERGY)
      :ref:`apdx:CCENERGY` **(Expert)** |w---w| Do restart the coupled-cluster iterations even if MO phases are screwed up? 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   WFN (CCENERGY)
      :ref:`apdx:CCENERGY` **(Expert)** |w---w| Wavefunction type 

      * **Type**: string
      * **Default**: LMP2

   EXCITATION_RANGE (CCEOM)
      :ref:`apdx:CCEOM` **(Expert)** |w---w| The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation 

      * **Type**: integer
      * **Default**: 2

   WFN (CCEOM)
      :ref:`apdx:CCEOM` **(Expert)** |w---w| Wavefunction type 

      * **Type**: string
      * **Possible Values**: EOM\_CCSD, EOM\_CC2, EOM\_CC3
      * **Default**: EOM\_CCSD

   WFN (CCHBAR)
      :ref:`apdx:CCHBAR` **(Expert)** |w---w| Wavefunction type 

      * **Type**: string
      * **Default**: SCF

   JOBTYPE (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` **(Expert)** |w---w| Type of job being performed 

      * **Type**: string
      * **Default**: No Default

   WFN (CCLAMBDA)
      :ref:`apdx:CCLAMBDA` **(Expert)** |w---w| Wavefunction type 

      * **Type**: string
      * **Default**: NONE

   WFN (CCRESPONSE)
      :ref:`apdx:CCRESPONSE` **(Expert)** |w---w| Wavefunction type 

      * **Type**: string
      * **Default**: SCF

   WFN (CCSORT)
      :ref:`apdx:CCSORT` **(Expert)** |w---w| Wavefunction type 

      * **Type**: string
      * **Default**: No Default

   WFN (CCTRIPLES)
      :ref:`apdx:CCTRIPLES` **(Expert)** |w---w| Wavefunction type 

      * **Type**: string
      * **Default**: SCF

   JOBTYPE (CPHF)
      :ref:`apdx:CPHF` **(Expert)** |w---w| Type of job being performed 

      * **Type**: string
      * **Default**: SP

   WFN (CPHF)
      :ref:`apdx:CPHF` **(Expert)** |w---w| Wavefunction type 

      * **Type**: string
      * **Possible Values**: MP2
      * **Default**: MP2

   CACHELEVEL (DCFT)
      :ref:`apdx:DCFT` **(Expert)** |w---w| Controls how to cache quantities within the DPD library 

      * **Type**: integer
      * **Default**: 2

   DAMPING_PERCENTAGE (DCFT)
      :ref:`apdx:DCFT` **(Expert)** |w---w| The amount (percentage) of damping to apply to the orbital update procedure: 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20\% of the previous iteration's density being mixed into the current iteration) can help in cases where oscillatory convergence is observed. 

      * **Type**: double
      * **Default**: 0.0

   DCFT_GUESS (DCFT)
      :ref:`apdx:DCFT` **(Expert)** |w---w| Whether to read the orbitals from a previous computation, or to compute an MP2 guess 

      * **Type**: string
      * **Possible Values**: CC, BCC, MP2
      * **Default**: MP2

   DIIS_MAX_VECS (DCFT)
      :ref:`apdx:DCFT` **(Expert)** |w---w| Maximum number of error vectors stored for DIIS extrapolation 

      * **Type**: integer
      * **Default**: 6

   DIIS_MIN_VECS (DCFT)
      :ref:`apdx:DCFT` **(Expert)** |w---w| Minimum number of error vectors stored for DIIS extrapolation 

      * **Type**: integer
      * **Default**: 3

   IGNORE_TAU (DCFT)
      :ref:`apdx:DCFT` **(Expert)** |w---w| Controls whether to ignore terms containing non-idempotent contribution to OPDM or not (for debug puproses only). For practical applications only the default must be used 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   INTS_TOLERANCE (DCFT)
      :ref:`apdx:DCFT` **(Expert)** |w---w| Minimum absolute value below which integrals are neglected 

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-14

   LOCK_OCC (DCFT)
      :ref:`apdx:DCFT` **(Expert)** |w---w| Controls whether to force the occupation to be that of the SCF guess. For practical applications only the default must be used 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   MO_RELAX (DCFT)
      :ref:`apdx:DCFT` **(Expert)** |w---w| Controls whether to relax the orbitals during the energy computation or not (for debug puproses only). For practical applications only the default must be used 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   RELAX_GUESS_ORBITALS (DCFT)
      :ref:`apdx:DCFT` **(Expert)** |w---w| Controls whether to relax the guess orbitals by taking the guess density cumulant and performing orbital update on the first macroiteration (for ALOGRITHM = TWOSTEP only) 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   RELAX_TAU (DCFT)
      :ref:`apdx:DCFT` **(Expert)** |w---w| Controls whether to relax tau during the cumulant updates or not 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   STABILITY_ADD_VECTORS (DCFT)
      :ref:`apdx:DCFT` **(Expert)** |w---w| The number of vectors that can be added simultaneously into the subspace for Davidson's diagonalization in stability check 

      * **Type**: integer
      * **Default**: 20

   STABILITY_AUGMENT_SPACE_TOL (DCFT)
      :ref:`apdx:DCFT` **(Expert)** |w---w| The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check 

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 0.1

   STABILITY_CHECK (DCFT)
      :ref:`apdx:DCFT` **(Expert)** |w---w| Performs stability analysis of the DCFT energy 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   STABILITY_CONVERGENCE (DCFT)
      :ref:`apdx:DCFT` **(Expert)** |w---w| Controls the convergence of the Davidson's diagonalization in stability check 

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-4

   STABILITY_MAX_SPACE_SIZE (DCFT)
      :ref:`apdx:DCFT` **(Expert)** |w---w| The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the convergence (STABILITY_CONVERGENCE) is not satisfied 

      * **Type**: integer
      * **Default**: 200

   STABILITY_N_EIGENVALUES (DCFT)
      :ref:`apdx:DCFT` **(Expert)** |w---w| The number of Hessian eigenvalues computed during the stability check 

      * **Type**: integer
      * **Default**: 3

   STABILITY_N_GUESS_VECTORS (DCFT)
      :ref:`apdx:DCFT` **(Expert)** |w---w| The number of guess vectors used for Davidson's diagonalization in stability check 

      * **Type**: integer
      * **Default**: 20

   TIKHONOW_OMEGA (DCFT)
      :ref:`apdx:DCFT` **(Expert)** |w---w| The shift applied to the denominator in the density cumulant update iterations 

      * **Type**: double
      * **Default**: 0.0

   TPDM (DCFT)
      :ref:`apdx:DCFT` **(Expert)** |w---w| Controls whether to compute unrelaxed two-particle density matrix at the end of the energy computation 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   SIGMA_OVERLAP (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Do print the sigma overlap matrix? Not generally useful. 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   WFN (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Wavefunction type. This should be set automatically from the calling Psithon function. 

      * **Type**: string
      * **Possible Values**: DETCI, CI, ZAPTN, DETCAS, CASSCF, RASSCF
      * **Default**: DETCI

   EX_ALLOW (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| An array of length |detci__ex_level| specifying whether each excitation type (S,D,T, etc.) is allowed (1 is allowed, 0 is disallowed). Used to specify non-standard CI spaces such as CIST. 

      * **Type**: array
      * **Default**: No Default

   MIXED (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Do allow "mixed" RAS II/RAS III excitations into the CI space? If FALSE, then if there are any electrons in RAS III, then the number of holes in RAS I cannot exceed the given excitation level |detci__ex_level|. 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   MIXED4 (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Do allow "mixed" excitations involving RAS IV into the CI space. Useful to specify a split-virtual CISD[TQ] computation. If FALSE, then if there are any electrons in RAS IV, then the number of holes in RAS I cannot exceed the given excitation level |detci__ex_level|. 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   R4S (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Do restrict strings with :math:`e-` in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., |detci__ex_level|), or else the string is discarded. 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   RAS1 (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| An array giving the number of orbitals per irrep for RAS1 

      * **Type**: array
      * **Default**: No Default

   RAS2 (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| An array giving the number of orbitals per irrep for RAS2 

      * **Type**: array
      * **Default**: No Default

   RAS3 (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| An array giving the number of orbitals per irrep for RAS3 

      * **Type**: array
      * **Default**: No Default

   RAS4 (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| An array giving the number of orbitals per irrep for RAS4 

      * **Type**: array
      * **Default**: No Default

   SF_RESTRICT (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Do eliminate determinants not valid for spin-complete spin-flip CI's? [see J. S. Sears et al, J. Chem. Phys. 118, 9084-9094 (2003)] 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   H0_BLOCKSIZE (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| This parameter specifies the size of the H0 block of the Hamiltonian which is solved exactly. The n determinants with the lowest SCF energy are selected, and a submatrix of the Hamiltonian is formed using these determinants. This submatrix is used to accelerate convergence of the CI iterations in the OLSEN and MITRUSHENKOV iteration schemes, and also to find a good starting guess for the SEM method if |detci__guess_vector| is ``H0_BLOCK``. Defaults to 400. Note that the program may change the given size for Ms=0 cases (|detci__ms0| is TRUE) if it determines that the H0 block includes only one member of a pair of determinants related by time reversal symmetry. For very small block sizes, this could conceivably eliminate the entire H0 block; the program should print warnings if this occurs. 

      * **Type**: integer
      * **Default**: 400

   H0_BLOCK_COUPLING (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Do use coupling block in preconditioner? 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   H0_BLOCK_COUPLING_SIZE (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Parameters which specifies the size of the coupling block within the generalized davidson preconditioner. 

      * **Type**: integer
      * **Default**: 0

   H0_GUESS_SIZE (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| size of H0 block for initial guess 

      * **Type**: integer
      * **Default**: 400

   HD_AVG (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| How to average H diag energies over spin coupling sets. ``HD_EXACT`` uses the exact diagonal energies which results in expansion vectors which break spin symmetry. ``HD_KAVE`` averages the diagonal energies over a spin-coupling set yielding spin pure expansion vectors. ``ORB_ENER`` employs the sum of orbital energy approximation giving spin pure expansion vectors but usually doubles the number of Davidson iterations. ``EVANGELISTI`` uses the sums and differences of orbital energies with the SCF reference energy to produce spin pure expansion vectors. ``LEININGER`` approximation which subtracts the one-electron contribution from the orbital energies, multiplies by 0.5, and adds the one-electron contribution back in, producing spin pure expansion vectors and developed by Matt Leininger and works as well as ``EVANGELISTI``. 

      * **Type**: string
      * **Possible Values**: EVANGELISTI, HD\_EXACT, HD\_KAVE, ORB\_ENER, LEININGER, Z\_KAVE
      * **Default**: EVANGELISTI

   OPDM_KE (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Do compute the kinetic energy contribution from the correlated part of the one-particle density matrix? 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   FOLLOW_VECTOR (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| In following a particular root (see |detci__follow_root|), sometimes the root number changes. To follow a root of a particular character, one can specify a list of determinants and their coefficients, and the code will follow the root with the closest overlap. The user specifies arrays containing the absolute alpha string indices (A_i below), absolute beta indices (B_i below), and CI coefficients (C_i below) to form the desired vector. The format is FOLLOW_VECTOR = [ [[A_1, B_1], C_1], [[A_2, B_2], C_2], ...]. 

      * **Type**: array
      * **Default**: No Default

   FILTER_GUESS (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Do invoke the FILTER_GUESS options that are used to filter out some trial vectors which may not have the appropriate phase convention between two determinants? This is useful to remove, e.g., delta states when a sigma state is desired. The user inputs two determinants (by giving the absolute alpha string number and beta string number for each), and also the desired phase between these two determinants for guesses which are to be kept. FILTER_GUESS = TRUE turns on the filtering routine. Requires additional keywords |detci__filter_guess_det1|, |detci__filter_guess_det2|, and |detci__filter_guess_sign|. 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   FILTER_GUESS_DET1 (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Array specifying the absolute alpha string number and beta string number for the first determinant in the filter procedure. (See |detci__filter_guess|). 

      * **Type**: array
      * **Default**: No Default

   FILTER_GUESS_DET2 (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Array specifying the absolute alpha string number and beta string number for the second determinant in the filter procedure. (See |detci__filter_guess|). 

      * **Type**: array
      * **Default**: No Default

   FILTER_GUESS_SIGN (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| The required phase (1 or -1) between the two determinants specified by |detci__filter_guess_det1| and |detci__filter_guess_det2|. 

      * **Type**: integer
      * **Default**: 1

   FILTER_ZERO_DET (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| If present, the code will try to filter out a particular determinant by setting its CI coefficient to zero. FILTER_ZERO_DET = [alphastr, betastr] specifies the absolute alpha and beta string numbers of the target determinant. This could be useful for trying to exclude states that have a nonzero CI coefficient for the given determinant. However, this option was experimental and may not be effective. 

      * **Type**: array
      * **Default**: No Default

   GUESS_VECTOR (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Guess vector type. Accepted values are ``UNIT`` for a unit vector guess (|detci__num_roots| and |detci__num_init_vecs| must both be 1); ``H0_BLOCK`` to use eigenvectors from the H0 BLOCK submatrix (default); ``DFILE`` to use NUM_ROOTS previously converged vectors in the D file; ``IMPORT`` to import a guess previously exported from a CI computation (possibly using a different CI space) 

      * **Type**: string
      * **Possible Values**: UNIT, H0\_BLOCK, DFILE, IMPORT
      * **Default**: H0\_BLOCK

   NUM_INIT_VECS (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| The number of initial vectors to use in the CI iterative procedure. Defaults to the number of roots. 

      * **Type**: integer
      * **Default**: 0

   REFERENCE_SYM (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Irrep for CI vectors; -1 = find automatically. This option allows the user to look for CI vectors of a different irrep than the reference. This probably only makes sense for Full CI, and it would probably not work with unit vector guesses. Numbering starts from zero for the totally-symmetric irrep. 

      * **Type**: integer
      * **Default**: -1

   HD_OTF (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Do compute the diagonal elements of the Hamiltonian matrix on-the-fly? Otherwise, a diagonal element vector is written to a separate file on disk. 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   NO_DFILE (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Do use the last vector space in the BVEC file to write scratch DVEC rather than using a separate DVEC file? (Only possible if |detci__num_roots| = 1.) 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   MPN_ORDER_SAVE (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| If 0, save the MPn energy; if 1, save the MP(2n-1) energy (if available from |detci__mpn_wigner| = true); if 2, save the MP(2n-2) energy (if available from |detci__mpn_wigner| = true). 

      * **Type**: integer
      * **Default**: 0

   MPN_SCHMIDT (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Do employ an orthonormal vector space rather than storing the kth order wavefunction? 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   MPN_WIGNER (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Do use Wigner formulas in the :math:`E_{text{mp}n}` series? 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   PERTURB_MAGNITUDE (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| The magnitude of perturbation :math:`z` in :math:`H = H_0 + z H_1` 

      * **Type**: double
      * **Default**: 1.0

   CC_FIX_EXTERNAL (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Do fix amplitudes involving RAS I or RAS IV? Useful in mixed MP2-CC methods. 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   CC_FIX_EXTERNAL_MIN (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Number of external indices before amplitude gets fixed by |detci__cc_fix_external|. Experimental. 

      * **Type**: integer
      * **Default**: 1

   CC_MACRO (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| CC_MACRO = [ [ex_lvl, max_holes_I, max_parts_IV, max_I+IV], [ex_lvl, max_holes_I, max_parts_IV, max_I+IV], ... ] Optional additional restrictions on allowed exictations in coupled-cluster computations, based on macroconfiguration selection. For each sub-array, [ex_lvl, max_holes_I, max_parts_IV, max_I+IV], eliminate cluster amplitudes in which: [the excitation level (holes in I + II) is equal to ex_lvl] AND [there are more than max_holes_I holes in RAS I, there are more than max_parts_IV particles in RAS IV, OR there are more than max_I+IV quasiparticles in RAS I + RAS IV]. 

      * **Type**: array
      * **Default**: No Default

   CC_MIXED (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Do ignore block if num holes in RAS I and II is :math:`>` cc_ex_lvl and if any indices correspond to RAS I or IV (i.e., include only all-active higher excitations)? 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   CC_UPDATE_EPS (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Do update T amplitudes with orbital eigenvalues? (Usually would do this). Not doing this is experimental. 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   CC_VARIATIONAL (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Do use variational energy expression in CC computation? Experimental. 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   BENDAZZOLI (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Do use some routines based on the papers of Bendazzoli et al. to calculate sigma? Seems to be slower and not worthwhile; may disappear eventually. Works only for full CI and I don't remember if I could see how their clever scheme might be extended to RAS in general. 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   FCI_STRINGS (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Do store strings specifically for FCI? (Defaults to TRUE for FCI.) 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   REPL_OTF (DETCI)
      :ref:`apdx:DETCI` **(Expert)** |w---w| Do string replacements on the fly in DETCI? Can save a gigantic amount of memory (especially for truncated CI's) but is somewhat flaky and hasn't been tested for a while. It may work only works for certain classes of RAS calculations. The current code is very slow with this option turned on. 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   DF_INTS_IO (DFMP2)
      :ref:`apdx:DFMP2` **(Expert)** |w---w| IO caching for CP corrections, etc 

      * **Type**: string
      * **Possible Values**: NONE, SAVE, LOAD
      * **Default**: NONE

   MADMP2_SLEEP (DFMP2)
      :ref:`apdx:DFMP2` **(Expert)** |w---w| A helpful option, used only in debugging the MADNESS version 

      * **Type**: integer
      * **Default**: 0

   CEPA_LEVEL (FNOCC)
      :ref:`apdx:FNOCC` **(Expert)** |w---w| Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won't have any effect on the procedure. 

      * **Type**: string
      * **Default**: CEPA(0)

   COMPUTE_MP4_TRIPLES (FNOCC)
      :ref:`apdx:FNOCC` **(Expert)** |w---w| Do compute MP4 triples contribution? 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   COMPUTE_TRIPLES (FNOCC)
      :ref:`apdx:FNOCC` **(Expert)** |w---w| Do compute triples contribution? 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   RUN_CCSD (FNOCC)
      :ref:`apdx:FNOCC` **(Expert)** |w---w| do ccsd rather than qcisd? 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   RUN_CEPA (FNOCC)
      :ref:`apdx:FNOCC` **(Expert)** |w---w| Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won't have any effect on the procedure. 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   RUN_MP2 (FNOCC)
      :ref:`apdx:FNOCC` **(Expert)** |w---w| do only evaluate mp2 energy? 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   RUN_MP3 (FNOCC)
      :ref:`apdx:FNOCC` **(Expert)** |w---w| do only evaluate mp3 energy? 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   RUN_MP4 (FNOCC)
      :ref:`apdx:FNOCC` **(Expert)** |w---w| do only evaluate mp4 energy? 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   USE_DF_INTS (FNOCC)
      :ref:`apdx:FNOCC` **(Expert)** |w---w| Use 3-index integrals to generate 4-index ERI's? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   ROTATE_MO_ANGLE (MCSCF)
      :ref:`apdx:MCSCF` **(Expert)** |w---w| For orbital rotations after convergence, the angle (in degrees) by which to rotate. 

      * **Type**: double
      * **Default**: 0.0

   ROTATE_MO_IRREP (MCSCF)
      :ref:`apdx:MCSCF` **(Expert)** |w---w| For orbital rotations after convergence, irrep (1-based, Cotton order) of the orbitals to rotate. 

      * **Type**: integer
      * **Default**: 1

   ROTATE_MO_P (MCSCF)
      :ref:`apdx:MCSCF` **(Expert)** |w---w| For orbital rotations after convergence, number of the first orbital (1-based) to rotate. 

      * **Type**: integer
      * **Default**: 1

   ROTATE_MO_Q (MCSCF)
      :ref:`apdx:MCSCF` **(Expert)** |w---w| For orbital rotations after convergence, number of the second orbital (1-based) to rotate. 

      * **Type**: integer
      * **Default**: 2

   MRCC_METHOD (MRCC)
      :ref:`apdx:MRCC` **(Expert)** |w---w| If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with :py:func:`~driver.energy`. This becomes CC/CI (option \#5) in fort.56 .. table:: MRCC methods +-------+--------------+-------------------------------------------------------------+ + Value + Method + Description + +=======+==============+=============================================================+ + 1 + CC + + +-------+--------------+-------------------------------------------------------------+ + 2 + CC(n-1)[n] + + +-------+--------------+-------------------------------------------------------------+ + 3 + CC(n-1)(n) + (CC(n-1)[n] energy is also calculated) + +-------+--------------+-------------------------------------------------------------+ + 4 + CC(n-1)(n)_L + (CC(n-1)[n] and CC(n-1)(n) energies are also calculated) + +-------+--------------+-------------------------------------------------------------+ + 5 + CC(n)-1a + + +-------+--------------+-------------------------------------------------------------+ + 6 + CC(n)-1b + + +-------+--------------+-------------------------------------------------------------+ + 7 + CCn + + +-------+--------------+-------------------------------------------------------------+ + 8 + CC(n)-3 + + +-------+--------------+-------------------------------------------------------------+ 

      * **Type**: integer
      * **Default**: 1

   MRCC_OMP_NUM_THREADS (MRCC)
      :ref:`apdx:MRCC` **(Expert)** |w---w| Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable :envvar:`OMP_NUM_THREADS` is set prior to calling PSI4 then that value is used. When set, this option overrides everything. Be aware the ``-n`` command-line option described in section :ref:`sec:threading` does not affect MRCC. 

      * **Type**: integer
      * **Default**: 1

   MRCC_RESTART (MRCC)
      :ref:`apdx:MRCC` **(Expert)** |w---w| The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes ``rest`` (option \#4) in fort.56. 

      * **Type**: integer
      * **Default**: 0

   PERTURB_CBS (PSIMRCC)
      :ref:`apdx:PSIMRCC` **(Expert)** |w---w| Do compute the perturbative corrections for basis set incompleteness? 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   PERTURB_CBS_COUPLING (PSIMRCC)
      :ref:`apdx:PSIMRCC` **(Expert)** |w---w| Do include the terms that couple different reference determinants in perturbative CBS correction computations? 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   TIKHONOW_TRIPLES (PSIMRCC)
      :ref:`apdx:PSIMRCC` **(Expert)** |w---w| Do use Tikhonow regularization in (T) computations? 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   USE_SPIN_SYMMETRY (PSIMRCC)
      :ref:`apdx:PSIMRCC` **(Expert)** |w---w| Whether to use spin symmetry to map equivalent configurations onto each other, for efficiency 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   DO_CCD_DISP (SAPT)
      :ref:`apdx:SAPT` **(Expert)** |w---w| Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3? 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   DO_MBPT_DISP (SAPT)
      :ref:`apdx:SAPT` **(Expert)** |w---w| Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD? 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: true

   DO_THIRD_ORDER (SAPT)
      :ref:`apdx:SAPT` **(Expert)** |w---w| Do compute third-order corrections? 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   WFN (SCF)
      :ref:`apdx:SCF` **(Expert)** |w---w| Wavefunction type 

      * **Type**: string
      * **Possible Values**: SCF
      * **Default**: SCF

   FOLLOW_STEP_SCALE (SCF)
      :ref:`apdx:SCF` **(Expert)** |w---w| When using STABILITY_ANALYSIS = FOLLOW, how much to scale the step along the eigenvector by. 

      * **Type**: double
      * **Default**: 0.5

   DISTRIBUTED_MATRIX (SCF)
      :ref:`apdx:SCF` **(Expert)** |w---w| The dimension sizes of the distributed matrix 

      * **Type**: array
      * **Default**: No Default

   PARALLEL (SCF)
      :ref:`apdx:SCF` **(Expert)** |w---w| Do run in parallel? 

      * **Type**: :ref:`boolean <op_c_boolean>`
      * **Default**: false

   PROCESS_GRID (SCF)
      :ref:`apdx:SCF` **(Expert)** |w---w| The dimension sizes of the processor grid 

      * **Type**: array
      * **Default**: No Default

   TILE_SZ (SCF)
      :ref:`apdx:SCF` **(Expert)** |w---w| The tile size for the distributed matrices 

      * **Type**: integer
      * **Default**: 512

   SAPT (SCF)
      :ref:`apdx:SCF` **(Expert)** |w---w| Are going to do SAPT? If so, what part? 

      * **Type**: string
      * **Possible Values**: FALSE, 2-DIMER, 2-MONOMER\_A, 2-MONOMER\_B, 3-TRIMER, 3-DIMER\_AB, 3-DIMER\_BC, 3-DIMER\_AC, 3-MONOMER\_A, 3-MONOMER\_B, 3-MONOMER\_C
      * **Default**: FALSE

   DF_FITTING_CONDITION (SCF)
      :ref:`apdx:SCF` **(Expert)** |w---w| Fitting Condition 

      * **Type**: double
      * **Default**: 1.0e-12

   DF_INTS_IO (SCF)
      :ref:`apdx:SCF` **(Expert)** |w---w| IO caching for CP corrections, etc 

      * **Type**: string
      * **Possible Values**: NONE, SAVE, LOAD
      * **Default**: NONE

   SAD_CHOL_TOLERANCE (SCF)
      :ref:`apdx:SCF` **(Expert)** |w---w| SAD Guess Cholesky Cutoff (for eliminating redundancies). 

      * **Type**: :ref:`conv double <op_c_conv>`
      * **Default**: 1e-7

   SAD_F_MIX_START (SCF)
      :ref:`apdx:SCF` **(Expert)** |w---w| SAD Guess F-mix Iteration Start 

      * **Type**: integer
      * **Default**: 50

   SAD_MAXITER (SCF)
      :ref:`apdx:SCF` **(Expert)** |w---w| Maximum number of SAD guess iterations 

      * **Type**: integer
      * **Default**: 50

   SAD_PRINT (SCF)
      :ref:`apdx:SCF` **(Expert)** |w---w| The amount of SAD information to print to the output 

      * **Type**: integer
      * **Default**: 0

   DFT_BLOCK_MAX_POINTS (SCF)
      :ref:`apdx:SCF` **(Expert)** |w---w| The maximum number of grid points per evaluation block. 

      * **Type**: integer
      * **Default**: 5000

   DFT_BLOCK_MAX_RADIUS (SCF)
      :ref:`apdx:SCF` **(Expert)** |w---w| The maximum radius to terminate subdivision of an octree block [au]. 

      * **Type**: double
      * **Default**: 3.0

   DFT_BLOCK_MIN_POINTS (SCF)
      :ref:`apdx:SCF` **(Expert)** |w---w| The minimum number of grid points per evaluation block. 

      * **Type**: integer
      * **Default**: 1000

   DFT_BLOCK_SCHEME (SCF)
      :ref:`apdx:SCF` **(Expert)** |w---w| The blocking scheme for DFT. 

      * **Type**: string
      * **Possible Values**: NAIVE, OCTREE
      * **Default**: OCTREE

   DFT_GRID_NAME (SCF)
      :ref:`apdx:SCF` **(Expert)** |w---w| The DFT grid specification, such as SG1.

      * **Type**: string
      * **Possible Values**: SG0, SG1
      * **Default**: No Default

   DFT_PRUNING_ALPHA (SCF)
      :ref:`apdx:SCF` **(Expert)** |w---w| Spread alpha for logarithmic pruning. 

      * **Type**: double
      * **Default**: 1.0

   DFT_PRUNING_SCHEME (SCF)
      :ref:`apdx:SCF` **(Expert)** |w---w| Pruning Scheme. 

      * **Type**: string
      * **Possible Values**: FLAT, P\_GAUSSIAN, D\_GAUSSIAN, P\_SLATER, D\_SLATER, LOG\_GAUSSIAN, LOG\_SLATER
      * **Default**: FLAT

   RAS1 (TRANSQT)
      :ref:`apdx:TRANSQT` **(Expert)** |w---w| An array giving the number of orbitals per irrep for RAS1 

      * **Type**: array
      * **Default**: No Default

   RAS2 (TRANSQT)
      :ref:`apdx:TRANSQT` **(Expert)** |w---w| An array giving the number of orbitals per irrep for RAS2 

      * **Type**: array
      * **Default**: No Default

   RAS3 (TRANSQT)
      :ref:`apdx:TRANSQT` **(Expert)** |w---w| An array giving the number of orbitals per irrep for RAS3 

      * **Type**: array
      * **Default**: No Default

   RAS4 (TRANSQT)
      :ref:`apdx:TRANSQT` **(Expert)** |w---w| An array giving the number of orbitals per irrep for RAS4 

      * **Type**: array
      * **Default**: No Default

   WFN (TRANSQT)
      :ref:`apdx:TRANSQT` **(Expert)** |w---w| Wavefunction type 

      * **Type**: string
      * **Default**: CCSD

   CACHELEVEL (TRANSQT2)
      :ref:`apdx:TRANSQT2` **(Expert)** |w---w| Controls how to cache quantities within the DPD library 

      * **Type**: integer
      * **Default**: 2

   WFN (TRANSQT2)
      :ref:`apdx:TRANSQT2` **(Expert)** |w---w| Wavefunction type 

      * **Type**: string
      * **Default**: No Default


